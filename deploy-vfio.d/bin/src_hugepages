#!/bin/false

#
# Filename:       src_hugepages
# Description:    Set Hugepage count and size.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# TODO:
# - [x] develop.
# - [ ] test.
#

#
# sources
#
  declare -g SRC_STR_SCRIPT_DIR="/usr/local/bin/"
  declare -g SRC_STR_SCRIPT_BIN_DIR="${SRC_STR_SCRIPT_DIR}deploy-vfio.d/"

  source "${SRC_STR_SCRIPT_BIN_DIR}src_print"

#
# logic
#
  #
  # DESC:   Main execution.
  # $1:     the Hugepage size as a string.
  # $2:     the Hugepage count size in kilobytes as an int reference.
  # $3:     the Hugepage count as an int reference.
  # $4:     the maximum free memory in kilobytes as an int.
  # RETURN: If install is successful, return 0.
  #         If install is not successful, return 1.
  #         If any exception occurs, return 2.
  #
    function src_hugepages_main
    {
      local -r str_setup_name="Static Hugepages"
      local -r str_fail="Could not setup ${str_setup_name}."

      echo
      echo -e "${SRC_PRINT_STR_SET_COLOR_YELLOW}Hugepage${SRC_PRINT_STR_SET_ESCAPE}"\
        "is a feature which statically allocates system memory to pagefiles."\
        "\nGuest(s) can use Hugepage to a peformance benefit."\
        "\nThe greater the Hugepage size, the less fragmentation of memory, and the "\
        "less latency/overhead of system memory-access."\
        "\n${SRC_PRINT_STR_SET_COLOR_YELLOW}NOTE:${SRC_PRINT_STR_SET_ESCAPE} It is "\
        "recommended to use a size which is a multiple of an individual memory "\
        "channel/stick."\
        "\n${SRC_PRINT_STR_SET_COLOR_YELLOW}Example:${SRC_PRINT_STR_SET_ESCAPE} Four"\
        " (4) channels of 8 GB each, use 1x, 2x, or 3x (8 GB, 16 GB, or 24 GB)."\
        "\n${SRC_PRINT_STR_SET_COLOR_YELLOW}NOTE:${SRC_PRINT_STR_SET_ESCAPE} If this"\
        " is skipped, the equivalent Libvirt hook for dynamic allocation will be "\
        "installed.\n"

      local -ir int_maximum_free_memory_in_kib="${4}"

      if ! is_int "${int_maximum_free_memory_in_kib}" \
        || [[ "${int_maximum_free_memory_in_kib}" -le 0 ]]; then
        log_invalid_parameter "int_maximum_free_memory_in_kib"
        print_and_log_warn "Maximum free memory value is not valid."
        return 2
      fi

      local -n ref_int_hugepages_count="${3}"

      if ! is_reference "${ref_int_hugepages_count}"; then
        log_invalid_parameter "ref_int_hugepages_count"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -n ref_int_hugepages_count_size_in_kib="${2}"

      if ! is_reference "${ref_int_hugepages_count_size_in_kib}"; then
        log_invalid_parameter "ref_int_hugepages_count_size_in_kib"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -ir str_hugepages_size="${1}"

      if ! is_string "${str_hugepages_size}"; then
        log_invalid_parameter "str_hugepages_size"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      if ! ask_yes_or_no \
        "Setup ${SET_COLOR_YELLOW}${str_setup_name}${SRC_PRINT_STR_SET_ESCAPE}?"; then
        print_and_log_output "Skipped ${str_setup_name} setup."
        return 1
      fi

      print_and_log_work "Executing ${str_setup_name} setup."

      if ! src_hugepages_get_kilobytes_size_prompt \
          "${str_hugepages_size}" \
          "ref_int_hugepages_count_size_in_kib" \
        || ! src_hugepages_get_count_prompt \
          "ref_int_hugepages_count_size_in_kib" \
          "ref_int_hugepages_count" \
          "${int_maximum_free_memory_in_kib}"; then
        print_and_log_fail "${str_fail}"
      fi

      print_and_log_pass "Setup ${str_setup_name}."
      return 0
    }

  #
  # DESC:   Is the Hugepage count valid.
  # $1:     the Hugepage count size in kilobytes as an int.
  # $2:     the Hugepage count as an int.
  # $3:     the maximum free memory in kilobytes as an int.
  # RETURN: If Hugepage count is valid, return 0.
  #         If Hugepage count is not valid, return 1.
  #         If any exceptions occur, return 2.
  #
    function src_hugepages_get_count
    {
      local -r str_warn="Cannot validate Hugepage count."
      local -r int_maximum_free_memory_in_kib="${3}"

      if ! is_int "${int_maximum_free_memory_in_kib}" \
        || [[ "${int_maximum_free_memory_in_kib}" -le 0 ]]; then
        log_invalid_parameter "int_maximum_free_memory_in_kib"
        print_and_log_warn "Maximum free memory value is not valid."
        return 2
      fi

      local -ir int_hugepages_count="${2}"

      if ! is_int "${int_hugepages_count}"; then
        log_invalid_parameter "int_hugepages_count"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -ir int_hugepages_size_in_kib="${1}"

      if ! is_int "${int_hugepages_size_in_kib}" \
        || [[ "${int_maximum_free_memory_in_kib}" -le 0 ]]; then
        log_invalid_parameter "int_hugepages_size_in_kib"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -ir int_total_hugepages_size_in_kib=$(( \
        int_hugepages_count * int_hugepages_size_in_kib \
      ))

      if [[ "${int_total_hugepages_size_in_kib}" -ge \
        "${int_maximum_free_memory_in_kib}" ]]; then
        log_invalid_parameter "int_total_hugepages_size_in_kib"
        print_and_log_warn "Hugepage count is exceeds free memory."
        return 1
      fi

      log_output "Hugepage count is valid."
      return 0
    }

  #
  # DESC:   Prompt to set the Hugepage count.
  # $1:     the Hugepage count size in kilobytes as an int reference.
  # $2:     the Hugepage count as an int reference.
  # $3:     the maximum free memory in kilobytes as an int.
  # RETURN: If Hugepage count is valid, return 0.
  #         If Hugepage count is not valid, return 1.
  #         If any exceptions occur, return 2.
  #
    function src_hugepages_get_count_prompt
    {
      local -r str_warn="Cannot validate Hugepage count."
      local -r int_maximum_free_memory_in_kib="${3}"

      if ! is_int "${int_maximum_free_memory_in_kib}" \
        || [[ "${int_maximum_free_memory_in_kib}" -le 0 ]]; then
        log_invalid_parameter "int_maximum_free_memory_in_kib"
        print_and_log_warn "Maximum free memory value is not valid."
        return 2
      fi

      local -n ref_int_prompt_hugepages_count="${2}"

      if ! is_reference "${ref_int_prompt_hugepages_count}"; then
        log_invalid_parameter "ref_int_prompt_hugepages_count"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -n ref_int_prompt_hugepage_count_size_in_kib="${1}"

      if ! is_reference "${ref_int_prompt_hugepage_count_size_in_kib}"; then
        log_invalid_parameter "ref_int_prompt_hugepage_count_size_in_kib"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local str_answer=0

      if is_int "${ref_int_prompt_hugepage_count_size_in_kib}"; then
        if [[ "${ref_int_prompt_hugepage_count_size_in_kib}" -le 0 ]]; then
          log_invalid_parameter "ref_int_prompt_hugepage_count_size_in_kib"
          print_and_log_warn "${str_warn}"
          return 2
        fi

        if ! src_hugepages_get_count \
            "${str_answer}" \
            "${ref_int_prompt_hugepages_count}" \
            "${int_maximum_free_memory_in_kib}"; then
          log_invalid_parameter "ref_int_prompt_hugepages_count"
          print_and_log_warn "${str_warn}"
          return 2
        fi

        ref_int_prompt_hugepages_count="${str_answer}"
        log_output "Hugepage count is valid."
        return 0
      fi

      local -ir int_maximum_hugepage_count=$( \
        printf "%.0f" $( \
          echo "scale=2;${int_maximum_free_memory_in_kib}/"\
            "${ref_int_prompt_hugepages_size_in_kib} | bc" \
        ) \
      )

      if ! is_int "${int_maximum_hugepage_count}"; then
        log_invalid_parameter "int_max_hugepage_count"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -ir int_max_tries=2

      for int_counter in $( seq 0 "${int_max_tries}" ); do
        read -r -p "Enter Hugepage count [1-${int_maximum_hugepage_count}]: " \
          str_answer

        if ! src_hugepages_get_count \
          "${str_answer}" \
          "${ref_int_prompt_hugepages_count}" \
          "${int_maximum_free_memory_in_kib}"; then
          continue
        fi

        ref_int_prompt_hugepages_count="${str_answer}"
        log_output "Hugepage count is valid."
        return 0
      done

      log_invalid_parameter "ref_int_prompt_hugepages_count"
      print_and_log_warn "${str_warn}"
      return 1
    }

  #
  # DESC:   Get the Hugepage size in kilobytes.
  # $1:     the Hugepage size as a string.
  # $2:     the Hugepage size in kilobytes as an int reference.
  # RETURN: If Hugepage size is valid, return 0.
  #         If Hugepage size is not valid, return 1.
  #         If any exceptions occur, return 2.
  #
    function src_hugepages_get_kilobytes_size
    {
      local -r str_warn="Cannot validate Hugepage size."
      local -ir int_two_by_exponent_of_ten=$(( 2 ** 10 ))
      local -n ref_int_hugepages_size_in_kib="${2}"

      if ! is_reference "${ref_int_hugepages_size_in_kib}"; then
        log_invalid_parameter "int_hugepages_size_in_kib"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -u str_hugepages_size="${1}"

      case "${str_hugepages_size}" in
        "4K" )
          ref_int_hugepages_size_in_kib="${int_two_by_exponent_of_ten}"
          print_and_log_output "Set Hugepage size to four kilobytes."
          return 0
          ;;

        "2M" )
          ref_int_hugepages_size_in_kib=$(( int_two_by_exponent_of_ten ** 2 ))
          ref_int_hugepages_size_in_kib=$(( ref_int_hugepages_size_in_kib * 2 ))
          print_and_log_output "Set Hugepage size to two megabytes."
          return 0
          ;;

        "1G" )
          ref_int_hugepages_size_in_kib=$(( int_two_by_exponent_of_ten ** 3 ))
          print_and_log_output "Set Hugepage size to one gigabyte."
          return 0
          ;;

        * )
          log_invalid_parameter "str_hugepages_size"
          print_and_log_warn "Invalid Hugepage size."
          return 1
          ;;
      esac
    }

  #
  # DESC:   Prompt to get the Hugepage size in kilobytes.
  # $1:     the Hugepage size as a string.
  # $2:     the Hugepage size in kilobytes as an int reference.
  # RETURN: If Hugepage size is valid, return 0.
  #         If Hugepage size is not valid, return 1.
  #         If any exceptions occur, return 2.
  #
    function src_hugepages_get_kilobytes_size_prompt
    {
      local -r str_warn="Cannot set Hugepage size."
      local -n ref_int_prompt_hugepages_size_in_kib="${2}"

      if ! is_reference "${ref_int_prompt_hugepages_size_in_kib}"; then
        log_invalid_parameter "ref_int_prompt_hugepages_size_in_kib"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      local -n ref_str_prompt_hugepages_size="${1}"

      if ! is_reference "${ref_str_prompt_hugepages_size}"; then
        log_invalid_parameter "ref_str_prompt_hugepages_size"
        print_and_log_warn "${str_warn}"
        return 2
      fi

      if is_string "${ref_str_prompt_hugepages_size}"; then
        if ! src_hugepages_get_kilobytes_size \
          "${ref_str_prompt_hugepages_size}" \
          "ref_int_prompt_hugepages_size_in_kib"; then
          log_invalid_parameter "ref_int_prompt_hugepages_size_in_kib"
          return 1
        fi

        return 0
      fi

      local -ir int_max_tries=2

      for int_counter in $( seq 0 "${int_max_tries}" ); do
        read -r -p "Enter Hugepage size [4K/2M/1G]: " \
          ref_str_prompt_hugepages_size

        if ! src_hugepages_get_kilobytes_size \
          "${ref_str_prompt_hugepages_size}" \
          "ref_int_hugepages_size_in_kib"; then
          continue
        fi

        return 0
      done

      log_invalid_parameter "ref_int_hugepages_size_in_kib"
      print_and_log_warn "${str_warn}"
      return 1
    }