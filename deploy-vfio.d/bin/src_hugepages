#!/bin/false

#
# Filename:       src_hugepages
# Description:    Set Hugepages count and size.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#


#
# TODO:
# - [ ] add comments.
# - [ ] migrate code.
# - [ ] refactor.
# - [ ] test.
#

#
# sources
#
  declare -g SRC_STR_SCRIPT_DIR="/usr/local/bin/"
  declare -g SRC_STR_SCRIPT_BIN_DIR="${SRC_STR_SCRIPT_DIR}deploy-vfio.d/"

  source "${SRC_STR_SCRIPT_BIN_DIR}src_print"
  source "${SRC_STR_SCRIPT_BIN_DIR}src_memory"

#
# setter logic
#
  #
  # DESC: globals
  #
    function set_globals
    {
      if [[ "${SRC_HUGEPAGES_BOOL_SET_GLOBALS}" == true ]]; then
        return 0
      fi

      declare -g SRC_HUGEPAGES_BOOL_SET_GLOBALS=true

      declare -gA SRC_HUGEPAGES_DICT_HUGEPAGE_SIZE_AND_KIB=( )
      SRC_HUGEPAGES_DICT_HUGEPAGE_SIZE_AND_KIB["4K"]=4
      SRC_HUGEPAGES_DICT_HUGEPAGE_SIZE_AND_KIB["2M"]=2048                             # NOTE: 2 * 1024
      SRC_HUGEPAGES_DICT_HUGEPAGE_SIZE_AND_KIB["1G"]=1048576                          # NOTE: 1 * 1024 * 1024

      declare -g SRC_HUGEPAGES_BOOL_DO_SETUP=false
      declare -g SRC_HUGEPAGES_BOOL_DO_USE_FOUR_KIB_HUGEPAGES=false
      declare -g SRC_HUGEPAGES_BOOL_DO_USE_TWO_MIB_HUGEPAGES=false
      declare -g SRC_HUGEPAGES_BOOL_DO_USE_ONE_GIB_HUGEPAGES=true
      declare -g SRC_HUGEPAGES_BOOL_IS_COUNT_SET=false
      declare -g SRC_HUGEPAGES_BOOL_IS_SIZE_SET=false

      declare -gi SRC_HUGEPAGES_INT_ALLOCATED_MEMORY=0

      declare -gi SRC_HUGEPAGES_INT_HUGEPAGES_COUNT=$( \
        cat /proc/meminfo | grep --ignore-case hugepagesize | \
        cut --delimiter ':' --fields 2 | awk 'END {print $1}' \
      )

      declare -gi SRC_HUGEPAGES_INT_MAX_COUNT=0
      declare -gi SRC_HUGEPAGES_INT_MIN_COUNT=0

      declare -gi SRC_HUGEPAGES_INT_MAX_SIZE_IN_KIB=$( \
        cat /proc/meminfo | grep MemTotal | cut --delimiter ":" --fields 2 | \
        awk 'END {print $1}' \
      )

      declare -gi SRC_HUGEPAGES_INT_MIN_SIZE_IN_KIB=$(( \
        4 * ${SRC_MEMORY_INT_ONE_GIB_IN_KIB} \
      ))

      declare -gi SRC_HUGEPAGES_INT_SIZE_IN_KIB=$( \
        cat /proc/meminfo | grep --ignore-case hugepages_total | \
        cut --delimiter ':' --fields 2 | awk 'END {print $1}' \
      )

      declare -gu SRC_HUGEPAGES_STR_BYTE_SUFFIX=""
      declare -g SRC_HUGEPAGES_STR_GRUB_CMDLINE=""
    }

  #
  # DESC:   Determine whether to use smaller or larger huge memory pages.
  # RETURN: If set a valid page size return 0.
  #         If false, return 1.
  #
    function set_huge_memory_page_size
    {
      if "${SRC_HUGEPAGES_BOOL_DO_USE_FOUR_KIB_HUGEPAGES}"; then
        print_and_log_output "Set huge memory page size: 4 KiB"
        return 0
      fi

      if "${SRC_HUGEPAGES_BOOL_DO_USE_TWO_MIB_HUGEPAGES}"; then
        print_and_log_output "Set huge memory page size: 2 MiB"
        return 0
      fi

      if "${SRC_HUGEPAGES_BOOL_DO_USE_ONE_GIB_HUGEPAGES}"; then
        print_and_log_output "Set huge memory page size: 1 GiB"
        return 0
      fi

      local -i int_quotient=$(( \
        ${SRC_MEMORY_INT_MIN_FREE_MEMORY_BYTES} / \
        ${SRC_MEMORY_INT_TWO_TO_POWER_OF_TEN} \
      ))

      if [[ ${int_quotient} -ge ${SRC_MEMORY_INT_FOUR_KIB_IN_KIB} ]] \
        && [[ ${int_quotient} -lt ${SRC_MEMORY_INT_TWO_MIB_IN_KIB} ]]; then
        SRC_HUGEPAGES_BOOL_DO_USE_FOUR_KIB_HUGEPAGES=true
        print_and_log_output "Set huge memory page size: 4 KiB"
        return 0

      elif [[ ${int_quotient} -ge ${SRC_MEMORY_INT_TWO_MIB_IN_KIB} ]] \
        && [[ ${int_quotient} -lt ${SRC_MEMORY_INT_ONE_GIB_IN_KIB} ]]; then
        SRC_HUGEPAGES_BOOL_DO_USE_TWO_MIB_HUGEPAGES=true
        print_and_log_output "Set huge memory page size: 2 MiB"
        return 0

      elif [[ ${int_quotient} -ge ${SRC_MEMORY_INT_ONE_GIB_IN_KIB} ]]; then
        SRC_HUGEPAGES_BOOL_DO_USE_ONE_GIB_HUGEPAGES=true
        print_and_log_output "Set huge memory page size: 1 GiB"
        return 0

      else
        log_warn "Failed to set huge memory page size."
        return 1
      fi
    }

#
# logic
#
  #
  # DESC:   
  # RETURN: 
  #
    function execute_hugepages_setup
    {
      execute_hugepages_setup_prompt || return 0
      local -r output="Static Hugepages setup"

      if ! execute_hugepages_setup_main; then
        pprint_and_log_fail "${output}"
        return 1
      fi

      print_and_log_pass "${output}"
    }

  #
  # DESC:   
  # RETURN: 
  #
    function execute_hugepages_setup_main
    {
      if ! "${PRE_SETUP_DO_EXECUTE_HUGEPAGES}"; then
        return 0
      fi

      if ! is_int "${MAX_MEMORY}" &> /dev/null; then
        print_and_log_warn "Could not parse system memory."
        return 1
      fi

      if ! "${IS_HUGEPAGES_SIZE_SET}"; then
        get_hugepages_byte_size_prompt || return 1
      fi

      get_hugepages_min_and_max_sizes || return 1

      if ! "${IS_HUGEPAGES_COUNT_SET}"; then
        get_hugepages_count_prompt || return 1
      fi

      get_hugepages_memory_allocated || return 1
      is_any_host_memory_available || return 1
      SRC_HUGEPAGES_STR_GRUB_CMDLINE="default_hugepagesz=${HUGEPAGES_BYTE_SUFFIX} hugepagesz=${HUGEPAGES_BYTE_SUFFIX} hugepages=${HUGEPAGES_COUNT}"
      PRE_SETUP_DO_EXECUTE_HUGEPAGES=true
    }

  #
  # DESC:   
  # RETURN: 
  #
    function execute_hugepages_setup_prompt
    {
      if "${PRE_SETUP_DO_EXECUTE_HUGEPAGES}"; then
        return 0
      fi

      echo

      if ! "${COMMON_ARGS_IS_EXECUTION_QUIET}"; then
        echo -e "${SET_COLOR_YELLOW}Hugepages${RESET_COLOR} is a feature which statically allocates system memory to pagefiles.\nGuest(s) can use Hugepages to a peformance benefit.\nThe greater the Hugepage size, the less fragmentation of memory, and the less latency/overhead of system memory-access.\n${SET_COLOR_YELLOW}NOTE:${RESET_COLOR} It is recommended to use a size which is a multiple of an individual memory channel/stick.\n${SET_COLOR_YELLOW}Example:${RESET_COLOR} Four (4) channels of 8 GB each, use 1x, 2x, or 3x (8 GB, 16 GB, or 24 GB).\n${SET_COLOR_YELLOW}NOTE:${RESET_COLOR} If this is skipped, the equivalent Libvirt hook for dynamic allocation will be installed.\n"
      fi

      execute_or_skip_prompt "Setup ${SET_COLOR_YELLOW}Static Hugepages${RESET_COLOR}?" && PRE_SETUP_DO_EXECUTE_HUGEPAGES=true
    }

  #
  # DESC:   
  # RETURN: 
  #
    function get_hugepages_memory_allocated
    {
      HUGEPAGES_ALLOCATED_MEMORY=$(( ${HUGEPAGES_COUNT} * ${HUGEPAGES_SIZE_IN_KIB} ))
    }

  #
  # DESC:   
  # $1:     
  # RETURN: 
  #
    function get_hugepages_byte_size
    {
      local -u answer="${1}"

      case "${answer}" in
        "1G" | "2M" )
          SRC_HUGEPAGES_STR_BYTE_SUFFIX="${answer}"
          SRC_HUGEPAGES_BOOL_IS_SIZE_SET=true ;;

        * )
          print_and_log_warn "Please a enter valid Hugepages size, '2M' or '1G'."
          return 1 ;;
      esac
    }

  #
  # DESC:   
  # $1:     
  # RETURN: 
  #
    function get_hugepages_byte_size_prompt
    {
      if "${IS_HUGEPAGES_SIZE_SET}"; then
        return 0
      fi

      local -i int_max_tries=2

      for int_count in $( seq 0 "${int_max_tries}" ); do
        read -r -p "Enter size of Hugepages [2M/1G]: " HUGEPAGES_BYTE_SUFFIX
        get_hugepages_byte_size "${HUGEPAGES_BYTE_SUFFIX}" && return 0
      done

      return 1
    }

  #
  # DESC:   
  # $1:     
  # RETURN: 
  #
    function get_hugepages_count
    {
      if [[ -z "${1}" ]]; then
        print_and_log_warn "Hugepages count is empty."
        return 1
      fi

      get_hugepages_min_and_max_sizes || return 1

      if ! is_int "${1}" &> /dev/null \
        || [[ "${1}" -lt "${HUGEPAGES_MIN_COUNT}" ]] \
        || [[ "${1}" -gt "${HUGEPAGES_MAX_COUNT}" ]]; then
        print_and_log_warn "Please enter a valid Hugepages amount, between ${HUGEPAGES_MIN_COUNT} or ${HUGEPAGES_MAX_COUNT}."
        return 1
      fi

      IS_HUGEPAGES_COUNT_SET=true
      HUGEPAGES_COUNT="${1}"
    }

  #
  # DESC:   
  # RETURN: 
  #
    function get_hugepages_count_prompt
    {
      if "${IS_HUGEPAGES_COUNT_SET}"; then
        return 0
      fi

      local -i int_max_tries=2

      for int_count in $( seq 0 "${int_max_tries}" ); do
        read -r -p "Enter count of Hugepages [${HUGEPAGES_MIN_COUNT}-${HUGEPAGES_MAX_COUNT}]: " HUGEPAGES_COUNT
        get_hugepages_count "${HUGEPAGES_COUNT}" && return 0
      done

      return 1
    }

  #
  # DESC:   
  # RETURN: 
  #
    function get_hugepages_min_and_max_sizes
    {
      case "${HUGEPAGES_BYTE_SUFFIX}" in
        "2M" )
          HUGEPAGES_SIZE_IN_KIB="${TWO_MIB_IN_KIB}"
          HUGEPAGES_MIN_COUNT=2 ;;

        "1G" )
          HUGEPAGES_SIZE_IN_KIB="${ONE_GIB_IN_KIB}"
          HUGEPAGES_MIN_COUNT=1 ;;

        * )
          print_and_log_warn "Could not calculate minimum or maximum values for Hugepages."
          return 1 ;;
      esac

      HUGEPAGES_MAX_COUNT=$(( "${HUGEPAGES_MAX_SIZE_IN_KIB}" - "${HUGEPAGES_MIN_SIZE_IN_KIB}" ))
      HUGEPAGES_MAX_COUNT=$(( "${HUGEPAGES_MAX_COUNT}" / "${HUGEPAGES_SIZE_IN_KIB}" ))
    }

  #
  # DESC:   If both Hugepages size and count set, set flag to execute setup.
  # RETURN: If flag is set to true, return 0.
  #         If flag is set to false, return 1.
  #
    function is_hugepages_setup
    {
      SRC_HUGEPAGES_BOOL_DO_SETUP=false

      if ! "${SRC_HUGEPAGES_BOOL_IS_SIZE_SET}"; then
        log_warn "Hugepages size is not set."
        return 1
      fi

      if ! "${SRC_HUGEPAGES_BOOL_IS_COUNT_SET}"; then
        log_warn "Hugepages count is not set."
        return 1
      fi

      log_output "Hugepages size and count are set."
      SRC_HUGEPAGES_BOOL_DO_SETUP=true
      return 0
    }

  #
  # NOTE: unsure to do refactor. Modify this into a validator function?
  #
  # DESC:   Get the kernel command line for Huge pages.
  # $1:     the reference variable.
  # RETURN: If command line is valid, return 0.
  #         If command line is not valid, return 1.
  #         If an exception has occurred, return 2.
  #
    function get_kernel_command_hugepages
    {
      if ! is_string "${1}"; then
        return 2
      fi

      local -n ref="${1}"
      ref="${SRC_HUGEPAGES_STR_GRUB_CMDLINE}"

    }