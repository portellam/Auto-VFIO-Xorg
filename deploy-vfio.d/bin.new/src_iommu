#!/bin/false

#
# Filename:       src_iommu
# Description:    Logic to parse and select IOMMU groups.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

# TODO: desseminate code into separate source files.

#
# sources
#
  declare -g SRC_STR_SCRIPT_DIR="/usr/local/bin/"
  declare -g SRC_STR_SCRIPT_BIN_DIR="${SRC_STR_SCRIPT_DIR}deploy-vfio.d/"

  source "${SRC_STR_SCRIPT_BIN_DIR}src_print"

#
# setter logic
#
  #
  # DESC: globals
  #
    function set_globals
    {
      if [[ "${SRC_IOMMU_BOOL_SET_GLOBALS}" == true ]]; then
        return 0
      fi

      declare -g SRC_IOMMU_BOOL_SET_GLOBALS=true

      declare -g SRC_IOMMU_BOOL_HAS_ARG_PARSE_IOMMU=false
      declare -g SRC_IOMMU_BOOL_HAS_ARG_PARSE_IOMMU_SELECT_ALL=false
      declare -g SRC_IOMMU_BOOL_HAS_ARG_PARSE_IOMMU_SELECT_SOME=false

      # TODO: determine if this is used?
      declare -gr SRC_IOMMU_STR_GET_PARSE_FROM_XML='' + \
        'xmllint "${STR_SRC_IOMMU_XML_FILE}" | grep --invert-match "xml"'

      declare -ga SRC_IOMMU_ARR_IOMMU_GROUP_ID=( \
        $( ls /sys/kernel/iommu_groups/ | sort --numeric-sort )
      )

      declare -ga SRC_IOMMU_ARR_IOMMU_GROUPS_FOR_HOST \
        SRC_IOMMU_ARR_IOMMU_GROUPS_FOR_VFIO \
        SRC_IOMMU_ARR_IOMMU_GROUPS_WITH_VGA_FOR_HOST \
        SRC_IOMMU_ARR_IOMMU_GROUPS_WITH_VGA_FOR_VFIO
    }

  #
  # DESC:   Do parse the IOMMU database.
  # $1:     boolean; if true, skip parse.
  # RETURN: If parse is successful or skipped, return 0. If failed, return 1.
  #
    function parse_iommu_database
    {
      if is_bool "${1}" &> /dev/null \
        && "${1}"; then
        print_output_to_log "Skipped parse of IOMMU groups."
        return 0
      fi

      parse_iommu_database_prompt || return 0

      if ! create_temp_files_for_database \
        || ! try_to_parse_iommu_database; then
        cleanup_iommu_database
        print_error_to_log "Database parse incomplete."
        return 1
      fi

      cleanup_iommu_database
      print_pass_to_log "Database parse complete."
    }

  #
  # DESC:   Clean up the IOMMU database.
  # RETURN: If clean up is successful, return 1. If failed, return 1.
  #
    function cleanup_iommu_database
    {
      if ! restore_temp_files_for_database \
        || ! delete_temp_files_for_database; then
        print_error_to_log "Clean-up of database failed."
        return 1
      fi

      print_error_to_log "Clean-up of database successful."
      return 0
    }

  #
  # DESC:   Try to parse the IOMMU database.
  # RETURN: If parse is successful, return 0. If false, return 1.
  #
    function try_to_parse_iommu_database
    {
      is_unparsed_enum_valid || return 1
      parse_iommu_database_from_xml_file
      specify_xml_file || return 1
      is_xml_file_created || return 1

      if ! is_xml_file_valid &> /dev/null; then
        does_host_not_have_existing_vfio_setup || return 1
        export_iommu_database_to_xml_file || return 1
        specify_iommu_group_enum
      fi

      if ! does_host_not_have_existing_vfio_setup; then
        return 1
      fi

      if "${SRC_IOMMU_BOOL_DO_PARSE_DATABASE_FROM_XML}"; then
        import_iommu_groups_from_xml_file || return 1
      fi

      specify_iommu_group_enum
    }

  #
  # DESC:   Prompt to parse IOMMU database.
  # RETURN: If flag is specified, skip and return 0.
  #         If prompt is answered yes, return 0. If false, return 1.
  #
    function parse_iommu_database_prompt
    {
      if "${SRC_IOMMU_BOOL_DO_PARSE_DATABASE}"; then
        return 0
      fi

      if ! execute_or_skip_prompt "Parse database for IOMMU groups?"; then
        SRC_IOMMU_BOOL_DO_PARSE_DATABASE=false
        return 1
      fi

      SRC_IOMMU_BOOL_DO_PARSE_DATABASE=true
      return 0
    }

  # <summary>Files</summary>
    function create_temp_files_for_database
    {
      create_temp_file_of_file "${XML_FILE}" || return 1
    }

    function restore_temp_files_for_database
    {
      copy_temp_file_to_file "${XML_FILE}" || return 1
    }

    function delete_temp_files_for_database
    {
      delete_temp_file_of_file "${XML_FILE}" || return 1
    }

    function is_xml_file_created
    {
      if ! is_file "${XML_FILE}" &> /dev/null \
        && ! sudo touch "${XML_FILE}"; then
        print_error_to_log "Could not create '${XML_FILE}'".
        return 1
      fi
    }

  # <summary>Getters</summary>
    function get_device_class
    {
      local -r device="${1}"
      local -n reference="${2}"
      reference="$( lspci -ms ${device} | cut --delimiter '"' --fields 2 )"
    }

    function get_device_driver
    {
      local -r device="${1}"
      local -n reference="${2}"

      if "${SRC_IOMMU_BOOL_DO_PARSE_DATABASE_FROM_XML}"; then
        reference="${DEVICE_DRIVER_XML_ENUM["${device}"]}"
      else
        reference="$( lspci -ks "${device}" | grep --ignore-case "driver" | awk 'END {print $5}' )"
      fi
    }

    function get_device_hardware_id
    {
      local -r device="${1}"
      local -n reference="${2}"

      reference="$( lspci -ns ${device} | cut --delimiter ' ' --fields 3 )"
    }

    function get_device_name
    {
      local -r device="${1}"
      local -n reference="${2}"

      reference="$( lspci -ms ${device}  | cut --delimiter '"' --fields 6 )"
    }

    function get_device_vendor
    {
      local -r device="${1}"
      local -n reference="${2}"

      reference="$( lspci -ms ${device} | cut --delimiter '"' --fields 4 )"
    }

    function get_enums_for_selection
    {
      local -n reference="${1}"
      local -n driver_reference="${2}"
      local -n stud_hwid_reference="${3}"
      local -n vfio_hwid_reference="${4}"

      for iommu_group_id in ${reference[@]}; do
        local -a device_list="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

        for device in ${device_list[@]}; do
          local driver=""
          local hwid=""

          get_device_driver "${device}" "driver"
          get_device_hardware_id "${device}" "hwid"

          if [[ ! -z "${driver}" ]] \
            && is_device_not_excluded "${device}"; then
            driver_reference+=( "${driver}" )
          fi

          if [[ ! -z "${hwid}" ]]; then
            if is_device_for_pci_stub "${device}"; then
              stud_hwid_reference+=( "${hwid}" )
            else
              vfio_hwid_reference+=( "${hwid}" )
            fi
          fi
        done
      done

      driver_reference=( $( sort --unique <<<"${driver_reference[*]}" ) )
      stud_hwid_reference=( $( sort --unique <<<"${stud_hwid_reference[*]}" ) )
      vfio_hwid_reference=( $( sort --unique <<<"${vfio_hwid_reference[*]}" ) )

      if is_enum_not_empty "driver_reference"; then
        return 0
      fi

      if ! is_enum_not_empty "stud_hwid_reference" \
        && ! is_enum_not_empty "vfio_hwid_reference"; then
        return 0
      fi

      print_error_to_log "No drivers or hardware IDs found for selection."
      return 1
    }

    function get_name_for_first_vga_device_in_iommu_group
    {
      if [[ -z "${2}" ]] \
        || ! is_int "${1}" &> /dev/null; then
        return 1
      fi

      local -ir iommu_group_id="${1}"
      local -n device_name="${2}"
      local -ar device_list="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"
      local name=""

      for device in ${device_list[@]}; do
        if ! is_device_vga "${device}"; then
          continue
        fi

        get_device_name "${device}" "device_name" && break
      done

      if [[ -z "${NAME}" ]]; then
        print_error_to_log "Could not find device name of any VGA device in IOMMU group ${IOMMU_GROUP_ID}."
        return 1
      fi

      device_name="${NAME}"
    }

  # <summary>Host validation</summary>
    function does_host_not_have_existing_vfio_setup
    {
      for iommu_group_id in ${IOMMU_GROUP_ID_ENUM[@]}; do
        if ! is_iommu_group_not_binded_to_vfio "${iommu_group_id}"; then
          print_error_to_log "Detected existing VFIO setup."
          return 1
        fi
      done
    }

  # <summary>IOMMU Groups validation</summary>
    function add_iommu_group_to_enum
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_external_devices "${iommu_group_id}"; then
        add_iommu_group_to_vfio_enum "${iommu_group_id}"
      else
        add_iommu_group_to_host_enum "${iommu_group_id}"
      fi
    }

    function add_iommu_group_to_host_enum
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null; then
        IOMMU_GROUPS_WITH_VGA_FOR_HOST_ENUM+=( "${iommu_group_id}" )
      fi

      IOMMU_GROUPS_FOR_HOST_ENUM+=( "${iommu_group_id}" )
    }

    function add_iommu_group_to_vfio_enum
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null; then
        IOMMU_GROUPS_WITH_VGA_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
      fi

      IOMMU_GROUPS_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
    }

    function add_iommu_group_to_enum_if_not_specified
    {
      local -ir iommu_group_id="${1}"

      for this_iommu_group_id in ${IOMMU_GROUP_ID_ENUM[@]}; do
        if [[ "${this_iommu_group_id}" -eq "${iommu_group_id}" ]]; then
          add_iommu_group_to_vfio_enum "${iommu_group_id}"
        else
          add_iommu_group_to_host_enum "${iommu_group_id}"
        fi
      done
    }

    function add_some_iommu_groups_to_parsed_enum
    {
      local regex_for_range_of_nums='^[0-9]+[-][0-9]+$'
      local -ar iommu_groups_temp_enum
      local -ir iommu_group_id="${1}"
      is_iommu_group_id_parsable "${iommu_group_id}" "iommu_groups_temp_enum" || return 1
      iommu_groups_temp_enum=( $( sort --human-numeric-sort --unique <<<"${iommu_groups_temp_enum[*]}" ) )

      for iommu_group_id in ${iommu_groups_temp_enum[@]}; do
        add_iommu_group_to_enum_if_not_specified "${iommu_group_id}"
      done
    }

    function add_all_valid_iommu_groups_to_parsed_enum
    {
      for iommu_group_id in ${IOMMU_GROUP_ID_ENUM[@]}; do
        add_iommu_group_to_enum "${iommu_group_id}"
      done
    }

    function add_all_valid_iommu_groups_without_vga_to_parsed_enum
    {
      for iommu_group_id in ${IOMMU_GROUP_ID_ENUM[@]}; do
        if does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null; then
          add_iommu_group_to_host_enum "${iommu_group_id}"
        else
          add_iommu_group_to_vfio_enum "${iommu_group_id}"
        fi
      done
    }

    function does_iommu_group_have_external_devices
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_external "${device}" && return 0
      done

      return 1
    }

    function does_iommu_group_have_vga_device
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_vga "${device}" && return 0
      done

      print_error_to_log "Please enter a valid IOMMU group ID which contains one or more VGA devices."
      return 1
    }

    function is_iommu_group_id_parsable
    {
      local -ir iommu_group_id="${1}"
      local -n reference="${2}"

      if echo "${1}" | grep --extended-regexp --quiet "${regex_for_range_of_nums}"; then
        local -i range_start=$( echo "${1}" | cut --delimiter '-' --fields 1 )
        local -i range_stop=$( echo "${1}" | cut --delimiter '-' --fields 2 )
        is_iommu_group_id_valid "${range_start}" || return 1
        is_iommu_group_id_valid "${range_stop}" || return 1
        reference+=( $( seq "${range_start}" "${range_stop}" ) )

      elif is_int "${1}" &> /dev/null; then
        is_iommu_group_id_valid "${1}" || return 1
        reference+=( "${1}" )

      else
        print_error_to_log "Invalid IOMMU group ID(s)."
        return 1
      fi
    }

    function is_iommu_group_id_valid
    {
      local -ir minimum_iommu_group_id=0
      local -ir maximum_iommu_group_id="${IOMMU_GROUP_ID_ENUM[-1]}"

      if ! is_int "${1}" &> /dev/null \
        || [[ "${1}" -le "${minimum_iommu_group_id}" ]] \
        || [[ "${1}" -ge "${maximum_iommu_group_id}" ]] ; then
        print_error_to_log "Please enter valid IOMMU group ID(s), between ${minimum_iommu_group_id} and ${maximum_iommu_group_id}."
        return 1
      fi
    }

    function is_iommu_group_not_binded_to_vfio
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_not_binded_to_vfio "${device}" || return 1
      done
    }

    function is_unparsed_enum_valid
    {
      local -r output="Invalid IOMMU groups."

      if ! is_enum "IOMMU_GROUP_ID_ENUM"; then
        print_error_to_log "${output}"
        return 1
      fi

      for value in ${IOMMU_GROUP_ID_ENUM[@]}; do
        if ! is_int "${value}" &> /dev/null; then
          print_error_to_log "${output}"
          return 1
        fi
      done
    }

    function is_valid_enum_of_iommu_groups
    {
      is_enum "${1}" &> /dev/null || return 1
      local -n reference="${1}"

      for value in ${reference[@]}; do
        is_int "${value}" &> /dev/null || return 1
      done
    }

  # <summary>Device validation</summary>
    function is_device_driver_not_excluded
    {
      local -r driver="${1}"
      local -r excluded_driver="snd_hda_intel"

      case "${driver}" in
        *"${excluded_driver}"* )
          return 1 ;;
      esac
    }

    function is_device_driver_not_vfio
    {
      local -r driver="${1}"
      local -r matched_driver="vfio-pci"

      case "${driver}" in
        *"${matched_driver}"* )
          return 1 ;;
      esac
    }

    function is_device_external
    {
      local -r device="${1}"
      local -r regex_get_domain_id='^[0-9A-F][1-9A-F]$'
      local -ru domain_id=$( echo "${device}" | cut --delimiter ':' --fields 2 )
      echo "${domain_id}" | grep --extended-regexp --quiet "${regex_get_domain_id}"
    }

    function is_device_for_pci_stub
    {
      local -r device="${1}"
      local -lr class="$( lspci -ms ${device} | cut --delimiter '"' --fields 2 )"

      case "${class}" in
        *"usb"* )
          return 0 ;;
      esac

      return 1
    }

    function is_device_id_valid
    {
      local -r device="${1}"
      local -r output="$( lspci -s "${device}" )"

      if ! is_string "${output}" &> /dev/null; then
        print_error_to_log "Device id is not valid."
        return 1
      fi
    }

    function is_device_not_binded_to_vfio
    {
      if [[ -z "${1}" ]]; then
        return 0
      fi

      local -r device="${1}"
      local driver=""
      get_device_driver "${device}" "driver"
      is_device_driver_not_vfio "${driver}"
    }

    function is_device_not_excluded
    {
      local -r device="${1}"
      local driver=""
      get_device_driver "${device}" "driver"
      is_device_driver_not_excluded "${driver}"
    }

    function is_device_not_external
    {
      local -r device="${1}"
      local driver=""
      get_device_driver "${device}" "driver"
      is_device_external "${device}"
    }

    function is_device_vga
    {
      local -r device="${1}"
      local -lr class="$( lspci -ms ${device} | cut --delimiter '"' --fields 2 )"

      case "${class}" in
        *"vga"* | *"graphic"* | *"display"* )
          return 0 ;;
      esac

      return 1
    }

  # <summary>IOMMU Groups presentation</summary>
    function do_select_iommu_group
    {
      local -ir iommu_group_id="${1}"
      IOMMU_GROUPS_FOR_VFIO_ENUM+=( "${iommu_group_id}" )

      if does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null; then
        IOMMU_GROUPS_WITH_VGA_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
      fi
    }

    function do_not_select_iommu_group
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null; then
        IOMMU_GROUPS_WITH_VGA_FOR_HOST_ENUM+=( "${iommu_group_id}" )
      else
        IOMMU_GROUPS_FOR_HOST_ENUM+=( "${iommu_group_id}" )
      fi
    }

    function print_iommu_group
    {
      local -r device="${1}"
      local class driver hwid name vendor

      get_device_class "${device}" "class"
      get_device_driver "${device}" "driver"
      get_device_hardware_id "${device}" "hwid"
      get_device_name "${device}" "name"
      get_device_vendor "${device}" "vendor"

      echo -e "\tSlot ID:\t${device}"
      echo -e "\tVendor name:\t${vendor}"
      echo -e "\tDevice name:\t${name}"
      echo -e "\tClass/Type:\t${class}"
      echo -e "\tHardware ID:\t${hwid}"
      local driver_output="\tDriver:\t\t"

      if is_string "${driver}" &> /dev/null; then
        driver_output+="${driver}"
      else
        driver_output+="N/A"
      fi

      echo -e "${driver_output}"
      echo
    }

    function print_iommu_group_enum
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_external "${device}" && print_iommu_group "${device}"
      done
    }

    function has_prespecified_iommu_group_enum
    {
      if ! is_enum "IOMMU_GROUPS_FOR_HOST_ENUM" \
        && ! is_enum "IOMMU_GROUPS_WITH_VGA_FOR_HOST_ENUM"; then
        return 1
      fi

      if ! is_enum "IOMMU_GROUPS_FOR_VFIO_ENUM" \
        && ! is_enum "IOMMU_GROUPS_WITH_VGA_FOR_VFIO_ENUM"; then
        return 1
      fi
    }

    function specify_iommu_group
    {
      local -ir iommu_group_id="${1}"

      if ! does_iommu_group_have_external_devices "${iommu_group_id}"; then
        IOMMU_GROUPS_FOR_HOST_ENUM+=( "${iommu_group_id}" )
        return 1
      fi

      if ! print_iommu_group_enum "${iommu_group_id}" \
        || ! specify_iommu_group_prompt "${iommu_group_id}"; then
        return 1
      fi
    }

    function specify_iommu_group_enum
    {
      has_prespecified_iommu_group_enum && return 0

      local -n reference="IOMMU_GROUP_ID_ENUM"
      echo

      for iommu_group_id in ${reference[@]}; do
        specify_iommu_group "${iommu_group_id}"
      done
    }

    function specify_iommu_group_prompt
    {
      local -ir iommu_group_id="${1}"

      if execute_or_skip_prompt "Select IOMMU group ${SET_COLOR_YELLOW}${iommu_group_id}${RESET_COLOR}?"; then
        do_select_iommu_group "${iommu_group_id}"
      else
        do_not_select_iommu_group "${iommu_group_id}"
      fi

      echo
    }


# main logic
#
  set_globals
  unset set_globals