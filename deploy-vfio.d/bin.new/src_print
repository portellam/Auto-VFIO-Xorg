#!/bin/false

#
# Filename:       src_print
# Description:    Print and logger logic.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# TODO:
# - [ ] test.
# - [x] develop.
#

#
# traps
#
  trap 'catch_error' SIGINT SIGTERM ERR
  trap 'catch_exit' EXIT
  trap 'uncatch_exit' EXIT 3

#
# setter logic
#
  #
  # DESC: globals
  #
    function set_globals
    {
      if  [[ "${SRC_PRINT_BOOL_SET_GLOBALS}" == true ]]; then
        return 0
      fi

      declare -g SRC_PRINT_BOOL_SET_GLOBALS=true

      declare -g SRC_PRINT_SAVEIFS="${IFS}"

      #
      # DESC:   vanity
      #
        declare -gr SRC_PRINT_STR_SCRIPT_NAME="deploy-vfio"

      #
      # DESC:   logger
      #
        declare -gr SRC_PRINT_STR_LOG_FILE="/var/log/${SRC_PRINT_STR_SCRIPT_NAME}.log"

      #
      # DESC:   color coding
      #
        declare -gr SRC_PRINT_STR_SET_COLOR_GREEN='\033[0;32m'
        declare -gr SRC_PRINT_STR_SET_COLOR_RED='\033[0;31m'
        declare -gr SRC_PRINT_STR_SET_COLOR_YELLOW='\033[0;33m'
        declare -gr SRC_PRINT_STR_RESET_COLOR='\033[0m'

      #
      # DESC:   font handling
      #
        declare -gr SRC_PRINT_STR_SET_BOLD='\e[1m'
        declare -gr SRC_PRINT_STR_SET_ITALIC='\e[3m'
        declare -gr SRC_PRINT_STR_SET_UNDERLINE='\e[4m'
        declare -gr SRC_PRINT_STR_RESET_TEXT='\e[0m'

      #
      # DESC:   prompt prefixes
      #
        declare -gr SRC_PRINT_STR_PREFIX_PROMPT="${SRC_PRINT_STR_SCRIPT_NAME}: "

        declare -gr SRC_PRINT_STR_PREFIX_ERROR="${SRC_PRINT_STR_PREFIX_PROMPT}" + \
          "${SRC_PRINT_STR_SET_COLOR_YELLOW}An error occurred:" + \
          "${SRC_PRINT_STR_RESET_COLOR} "

        declare -gr SRC_PRINT_STR_PREFIX_FAIL="${SRC_PRINT_STR_PREFIX_PROMPT}" + \
          "${SRC_PRINT_STR_SET_COLOR_RED}Failure:${SRC_PRINT_STR_RESET_COLOR} "

        declare -gr SRC_PRINT_STR_PREFIX_PASS="${SRC_PRINT_STR_PREFIX_PROMPT}" + \
          "${SRC_PRINT_STR_SET_COLOR_GREEN}Success:${SRC_PRINT_STR_RESET_COLOR} "
    }

#
# logic
#
  #
  # DESC:   Trap error code and run logic before exit.
  # RETURN: Always exit 1.
  #
    function catch_error
    {
      echo
      error_disclaimer
      exit 1
    }

  #
  # DESC:   Trap exit code and run logic before exit.
  # RETURN: Always return code from previous scope.
  #
    function catch_exit
    {
      local -ir int_return_code="${?}"
      print_pass_or_fail_to_log
      reset_ifs
      return "${int_return_code}"
    }

  #
  # DESC:   Warn user of any errors at exit.
  # RETURN: Always return code from previous scope.
  #
    function error_disclaimer
    {
      local -ir int_return_code="${?}"

      echo -e "${SRC_PRINT_STR_PREFIX_PROMPT}One or more errors have occurred."\
        "Please view the logfile to troubleshoot ('${SRC_PRINT_STR_LOG_FILE}')." >&2

      return "${int_return_code}"
    }

  #
  # DESC:   Log output of parameter name.
  # $1:     the parameter name as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_invalid_parameter
    {
      local -ir int_return_code="${?}"
      log_stderr "Parameter "'${'"${1}"'}'" is invalid or undefined."
      return "${int_return_code}"
    }

  #
  # DESC:   Log output to STDERR.
  # RETURN: Always return code from previous scope.
  #
    function log_stderr
    {
      local -ir int_return_code="${?}"
      logger --stderr "${1}" 2>> "${SRC_PRINT_STR_LOG_FILE}"
      echo -e "" >&2
      return "${int_return_code}"
    }

  #
  # DESC:   Log output to STDOUT.
  # RETURN: Always return code from previous scope.
  #
    function log_stdout
    {
      local -ir int_return_code="${?}"
      logger "${1}" 2>> "${SRC_PRINT_STR_LOG_FILE}"
      return "${int_return_code}"
    }

  #
  # DESC:   Print conflicting argument output.
  # $1:     the argument as a string.
  # RETURN: Always exit 1.
  #
    function print_conflicting_arguments
    {
      print_error_to_log "Conflicting argument(s)."
      print_help
      exit 1
    }

  #
  # DESC:   Print conflicting options output.
  # $1:     the options as a string.
  # RETURN: Always exit 1.
  #
    function print_conflicting_options
    {
      print_error_to_log "Conflicting option(s)."
      print_help
      exit 1
    }

  #
  # DESC:   Print duplicate argument output.
  # $1:     the argument as a string.
  # RETURN: Always return 1.
  #
    function print_duplicate_argument
    {
      local -r str_output="Duplicate argument"

      if  ! is_string "${1}"; then
        print_error_to_log "${str_output}."
      else
        print_error_to_log "${str_output}'${1}'."
      fi

      return 1
    }

  #
  # DESC:   Print duplicate option output.
  # $1:     the option as a string.
  # RETURN: Always return 1.
  #
    function print_duplicate_option
    {
      local -ir int_return_code="${?}"
      local -r str_output="Duplicate option"

      if  ! is_string "${1}"; then
        print_error_to_log "${str_output}."
      else
        print_error_to_log "${str_output}'${1}'."
      fi

      return 1
    }

  #
  # DESC:   Print help.
  # $1:     the argument as a string.
  # RETURN: Always return 0.
  #
    function print_help
    {
      echo -e "Try 'sudo bash ${SRC_PRINT_STR_SCRIPT_NAME} --help' for usage."
      return 0
    }

  #
  # DESC:   Print invalid argument output.
  # $1:     the argument as a string.
  # RETURN: Always exit 1.
  #
    function print_invalid_argument
    {
      local -r str_output="Invalid argument"

      if  ! is_string "${1}"; then
        print_error_to_log "${str_output}."
      else
        print_error_to_log "${str_output} '${1}'."
      fi

      print_help
      exit 1
    }

  #
  # DESC:   Print invalid option output.
  # $1:     the option as a string.
  # RETURN: Always exit 1.
  #
    function print_invalid_option
    {
      local -r str_output="Invalid option"

      if  ! is_string "${1}"; then
        print_error_to_log "${str_output}."
      else
        print_error_to_log "${str_output} '${1}'."
      fi

      print_help
      exit 1
    }

  #
  # DESC:   Print and log error statement.
  # $1:     line of text as a string
  # RETURN: Always return code from previous scope.
  #
    function print_error_to_log
    {
      local -ir int_return_code="${?}"
      log_stderr "${SRC_PRINT_STR_PREFIX_ERROR}${1}"
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log failure statement.
  # $1:     line of text as a string
  # RETURN: Always return code from previous scope.
  #
    function print_fail_to_log
    {
      local -ir int_return_code="${?}"
      log_stdout "${SRC_PRINT_STR_PREFIX_FAIL}${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_FAIL}${1}" >&2
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log statement.
  # $1:     line of text as a string
  # RETURN: Always return code from previous scope.
  #
    function print_output_to_log
    {
      local -ir int_return_code="${?}"
      log_stdout "${SRC_PRINT_STR_PREFIX_PROMPT}${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_PROMPT}${1}" >&1
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log error statement.
  # $1:     line of text as a string.
  # RETURN: Always return code from previous scope.
  #
    function print_pass_or_fail_to_log
    {
      local -ir int_return_code="${?}"

      if  [[ "${int_return_code}" -eq 255 ]]; then
        print_output_to_log "Skipped."
        return 255
      fi

      if  [[ "${int_return_code}" -ne 0 ]]; then
        print_fail_to_log "Failure."
        return "${int_return_code}"
      fi

      print_pass_to_log "Success."
      return 0
    }

  #
  # DESC:   Print and log success statement.
  # $1:     line of text as a string.
  # RETURN: Always return code from previous scope.
  #
    function print_pass_to_log
    {
      local -ir int_return_code="${?}"
      log_stdout "${SRC_PRINT_STR_PREFIX_PASS}${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_PASS}${1}" >&1
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log working statement.
  # $1:     line of text as a string.
  # RETURN: Always return code from previous scope.
  #
    function print_work_to_log
    {
      local -ir int_return_code="${?}"
      log_stdout "${SRC_PRINT_STR_PREFIX_PASS}${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_WORK}${1}" >&1
      return "${int_return_code}"
    }

  #
  # DESC:   Preserve current internal field seperator.
  # RETURN: Always return 0.
  #
    function reset_ifs
    {
      local -ir int_return_code="${?}"
      log_stdout "${0}: ${FUNCNAME}"
      IFS="${SRC_PRINT_SAVEIFS}"
      return "${int_return_code}"
    }

  #
  # DESC:   Set internal field seperator to newline.
  # RETURN: Always return 0.
  #
    function set_ifs_to_newline
    {
      log_stdout "${0}: ${FUNCNAME}"
      IFS=$'\n'
   }

  #
  # DESC:   Trap exit code and run logic before exit.
  # RETURN: Always return 0.
  #
    function uncatch_exit {
      reset_ifs
    }

#
# main logic
#
  set_globals
  unset set_globals