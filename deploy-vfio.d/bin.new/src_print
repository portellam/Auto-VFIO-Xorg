#!/bin/false

#
# Filename:       src_print
# Description:    Print and logger logic.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# TODO:
# - [ ] test.
# - [x] develop.
#

#
# traps
#
  trap 'catch_error' SIGINT SIGTERM ERR
  trap 'catch_exit' EXIT
  trap 'uncatch_exit' EXIT 3

#
# setter logic
#
  #
  # DESC:   globals
  # $1:     the executable name as a string.
  # RETURN: Always return 0.
  #
    function set_globals
    {
      if [[ "${SRC_PRINT_BOOL_SET_GLOBALS}" == true ]]; then
        return 0
      fi

      declare -g SRC_PRINT_BOOL_SET_GLOBALS=true

      declare -gr SRC_PRINT_SAVEIFS="${IFS}"

      #
      # DESC:   vanity
      #
        declare -g SRC_PRINT_STR_SCRIPT_NAME

        if ! is_string "${1}"; then
          declare -r SRC_PRINT_STR_SCRIPT_NAME="script"

        else
          declare -r SRC_PRINT_STR_SCRIPT_NAME="${1}"
        fi

      #
      # DESC:   logger
      #
        declare -gr SRC_PRINT_STR_LOG_FILE="/var/log/${SRC_PRINT_STR_SCRIPT_NAME}.log"

      #
      # DESC:   color coding
      #
        declare -gr SRC_PRINT_STR_SET_COLOR_GREEN='\033[0;32m'
        declare -gr SRC_PRINT_STR_SET_COLOR_RED='\033[0;31m'
        declare -gr SRC_PRINT_STR_SET_COLOR_YELLOW='\033[0;33m'

      #
      # DESC:   font handling
      #
        declare -gr SRC_PRINT_STR_SET_BLINKING='\e[5m'
        declare -gr SRC_PRINT_STR_SET_BOLD='\e[1m'
        declare -gr SRC_PRINT_STR_SET_ITALIC='\e[3m'
        declare -gr SRC_PRINT_STR_SET_UNDERLINE='\e[4m'
        declare -gr SRC_PRINT_STR_SET_ESCAPE='\033[0m'

      #
      # DESC:   prompt prefixes
      #
        declare -gr SRC_PRINT_STR_PREFIX_PROMPT="${SRC_PRINT_STR_SCRIPT_NAME}: "

        declare -g SRC_PRINT_STR_PREFIX_FAIL="${SRC_PRINT_STR_PREFIX_PROMPT}"\
        SRC_PRINT_STR_PREFIX_FAIL+="${SRC_PRINT_STR_SET_COLOR_RED}Failure: "
        SRC_PRINT_STR_PREFIX_FAIL+="${SRC_PRINT_STR_SET_ESCAPE}"
        declare -r SRC_PRINT_STR_PREFIX_FAIL

        declare -g SRC_PRINT_STR_PREFIX_PASS="${SRC_PRINT_STR_PREFIX_PROMPT}"\
        SRC_PRINT_STR_PREFIX_PASS+="${SRC_PRINT_STR_SET_COLOR_GREEN}Success: "
        SRC_PRINT_STR_PREFIX_PASS+="${SRC_PRINT_STR_SET_ESCAPE}"
        declare -r SRC_PRINT_STR_PREFIX_PASS

        declare -g SRC_PRINT_STR_PREFIX_WARN="${SRC_PRINT_STR_PREFIX_PROMPT}"
        SRC_PRINT_STR_PREFIX_WARN+="${SRC_PRINT_STR_SET_COLOR_YELLOW}Warning: "
        SRC_PRINT_STR_PREFIX_WARN+="${SRC_PRINT_STR_SET_ESCAPE}"
        declare -r SRC_PRINT_STR_PREFIX_WARN

        declare -g SRC_PRINT_STR_PREFIX_WORK="${SRC_PRINT_STR_PREFIX_PROMPT}"\
        SRC_PRINT_STR_PREFIX_WORK+="${SRC_PRINT_STR_SET_BLINKING}Working: "
        SRC_PRINT_STR_PREFIX_WORK+="${SRC_PRINT_STR_SET_ESCAPE}"
        declare -r SRC_PRINT_STR_PREFIX_WORK
    }

#
# logic
#
  #
  # DESC:   Trap error code and run logic before exit.
  # RETURN: Always exit 1.
  #
    function catch_error
    {
      echo
      print_and_log_fail "Script failed."
      print_and_log_warn_disclaimer
      exit 1
    }

  #
  # DESC:   Trap exit code and run logic before exit.
  # RETURN: Always return code from previous scope.
  #
    function catch_exit
    {
      local -ir int_return_code="${?}"
      print_help
      reset_ifs
      return "${int_return_code}"
    }

  #
  # DESC:   Warn user of any errors at exit.
  # RETURN: Always return code from previous scope.
  #
    function print_and_log_warn_disclaimer
    {
      local -ir int_return_code="${?}"

      print_and_log_warn "One or more errors have occurred."\
        "Please view the logfile to troubleshoot ('${SRC_PRINT_STR_LOG_FILE}')."

      return "${int_return_code}"
    }

  #
  # DESC:   Log output of parameter name.
  # $1:     the parameter name as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_invalid_parameter
    {
      local -ir int_return_code="${?}"
      log_error "Parameter "'${'"${1}"'}'" is invalid or undefined."
      return "${int_return_code}"
    }

  #
  # DESC:   Log error output to STDERR.
  # $1:     the input as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_error
    {
      local -ir int_return_code="${?}"
      log_to_stderr "${SRC_PRINT_STR_PREFIX_WARN}${1}"
      return "${int_return_code}"
    }

  #
  # DESC:   Log failure output to STDERR.
  # $1:     the input as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_fail
    {
      local -ir int_return_code="${?}"
      log_to_stderr "${SRC_PRINT_STR_PREFIX_FAIL}${1}"
      return "${int_return_code}"
    }

  #
  # DESC:   Log output to STDOUT.
  # $1:     the input as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_output
    {
      local -ir int_return_code="${?}"
      log_to_stdout "${SRC_PRINT_STR_PREFIX_PROMPT}${1}"
      return "${int_return_code}"
    }

  #
  # DESC:   Log successful output to STDOUT.
  # $1:     the input as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_pass
    {
      local -ir int_return_code="${?}"
      log_to_stdout "${SRC_PRINT_STR_PREFIX_PASS}${1}"
      return "${int_return_code}"
    }

  #
  # DESC:   Log output to STDERR.
  # $1:     the input as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_to_stderr
    {
      local -ir int_return_code="${?}"

      if [[ ! -w "${SRC_PRINT_STR_LOG_FILE}" ]]; then
        return "${int_return_code}"
      fi

      logger --stderr "${1}" 2>> "${SRC_PRINT_STR_LOG_FILE}"
      return "${int_return_code}"
    }

  #
  # DESC:   Log output to STDOUT.
  # $1:     the input as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_to_stdout
    {
      local -ir int_return_code="${?}"

      if [[ ! -w "${SRC_PRINT_STR_LOG_FILE}" ]]; then
        return "${int_return_code}"
      fi

      logger "${1}" 2>> "${SRC_PRINT_STR_LOG_FILE}"
      return "${int_return_code}"
    }

  #
  # DESC:   Log working output to STDOUT.
  # $1:     the input as a string.
  # RETURN: Always return code from previous scope.
  #
    function log_work
    {
      local -ir int_return_code="${?}"
      log_to_stdout "${SRC_PRINT_STR_PREFIX_WORK}${1}"
      return "${int_return_code}"
    }

  #
  # DESC:   Print conflicting argument output.
  # $1:     the argument as a string.
  # RETURN: Always exit 1.
  #
    function print_conflicting_arguments
    {
      print_and_log_warn "Conflicting argument(s)."
      print_help
      exit 1
    }

  #
  # DESC:   Print conflicting options output.
  # $1:     the options as a string.
  # RETURN: Always exit 1.
  #
    function print_conflicting_options
    {
      print_and_log_warn "Conflicting option(s)."
      print_help
      exit 1
    }

  #
  # DESC:   Print duplicate argument output.
  # $1:     the argument as a string.
  # RETURN: Always return 1.
  #
    function print_and_log_duplicate_argument
    {
      local -r str_output="Duplicate argument"

      if ! is_string "${1}"; then
        print_and_log_warn "${str_output}."
      else
        print_and_log_warn "${str_output}'${1}'."
      fi

      return 1
    }

  #
  # DESC:   Print duplicate option output.
  # $1:     the option as a string.
  # RETURN: Always return 1.
  #
    function print_and_log_duplicate_option
    {
      local -ir int_return_code="${?}"
      local -r str_output="Duplicate option"

      if ! is_string "${1}"; then
        print_and_log_warn "${str_output}."
      else
        print_and_log_warn "${str_output}'${1}'."
      fi

      return 1
    }

  #
  # DESC:   Print invalid argument output.
  # $1:     the argument as a string.
  # RETURN: Always exit 1.
  #
    function print_and_log_invalid_argument
    {
      local -r str_output="Invalid argument"

      if ! is_string "${1}"; then
        print_and_log_warn "${str_output}."
      else
        print_and_log_warn "${str_output} '${1}'."
      fi

      exit 1
    }

  #
  # DESC:   Print invalid option output.
  # $1:     the option as a string.
  # RETURN: Always exit 1.
  #
    function print_and_log_invalid_option
    {
      local -r str_output="Invalid option"

      if ! is_string "${1}"; then
        print_and_log_warn "${str_output}."
      else
        print_and_log_warn "${str_output} '${1}'."
      fi

      exit 1
    }

  #
  # DESC:   Print and log failure statement.
  # $1:     line of text as a string
  # RETURN: Always return code from previous scope.
  #
    function print_and_log_fail
    {
      local -ir int_return_code="${?}"
      log_fail "${SRC_PRINT_STR_PREFIX_FAIL}${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_FAIL}${1}" >&2
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log statement.
  # $1:     line of text as a string
  # RETURN: Always return code from previous scope.
  #
    function print_and_log_output
    {
      local -ir int_return_code="${?}"
      log_output "${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_PROMPT}${1}" >&1
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log success statement.
  # $1:     line of text as a string.
  # RETURN: Always return code from previous scope.
  #
    function print_and_log_pass
    {
      local -ir int_return_code="${?}"
      log_pass "${SRC_PRINT_STR_PREFIX_PASS}${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_PASS}${1}" >&1
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log warning statement.
  # $1:     line of text as a string
  # RETURN: Always return code from previous scope.
  #
    function print_and_log_warn
    {
      local -ir int_return_code="${?}"
      log_error "${SRC_PRINT_STR_PREFIX_WARN}${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_WARN}${1}" >&2
      return "${int_return_code}"
    }

  #
  # DESC:   Print and log working statement.
  # $1:     line of text as a string.
  # RETURN: Always return code from previous scope.
  #
    function print_and_log_work
    {
      local -ir int_return_code="${?}"
      log_work "${1}"
      echo -e "${SRC_PRINT_STR_PREFIX_WORK}${1}" >&1
      return "${int_return_code}"
    }

  #
  # DESC:   Print help.
  # $1:     the argument as a string.
  # RETURN: Always return 0.
  #
    function print_help
    {
      print_and_log_output "Try 'sudo bash ${SRC_PRINT_STR_SCRIPT_NAME} --help' for "\
        "usage."

      return 0
    }

  #
  # DESC:   Preserve current internal field seperator.
  # RETURN: Always return 0.
  #
    function reset_ifs
    {
      local -ir int_return_code="${?}"
      IFS="${SRC_PRINT_SAVEIFS}"
      return "${int_return_code}"
    }

  #
  # DESC:   Set internal field seperator to newline.
  # RETURN: Always return 0.
  #
    function set_ifs_to_newline
    {
      IFS=$'\n'
   }

  #
  # DESC:   Trap exit code and run logic before exit.
  # RETURN: Always return 0.
  #
    function uncatch_exit {
      reset_ifs
    }

#
# main logic
#
  set_globals "$*"
  unset set_globals