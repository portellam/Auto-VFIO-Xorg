#!/bin/bash sh

#
# Filename:         vfiolib-utils
# Description:      Recommended pre-installation setup.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# TODO:
# * refactor Modify_QEMU
# * rename vars to new standard
#
#
#

# <remarks> Using </remarks>
# <code>
    source vfiolib-calc
    source vfiolib-iommu
# </code>

# <params>
    # <remarks> File templates. </remarks>
    declare -g _DISCLAIMER_FILE_CONTENTS=(
        "#### Generated by 'portellam/deploy-vfio'"
        "# WARNING: Any modifications to this file will be modified by 'deploy-vfio'"
        "#"
    )

    declare -g _VFIO_DISCLAIMER_FILE_CONTENTS=(
        "${_DISCLAIMER_FILE_CONTENTS[@]}"
        "# Run lspci to view hardware information."
        "# You must run update-initramfs(8) to effect this change."
        "#"
    )

    # <remarks> Evaluations </remarks>
    declare -g _GET_FIRST_VALID_USER='getent passwd {1000..60000} | cut -d ":" -f 1' &> /dev/null
    declare -g _FIRST_USER=$( eval "${_GET_FIRST_VALID_USER}" ) &> /dev/null

    # <remarks> Flag progress of setups </remarks>
    declare -g _IS_EVDEV_SETUP=false
    declare -g _IS_HUGEPAGES_SETUP=false
# </params>

# <code>
    # <summary>
    # Add user to necessary user groups.
    # </summary>
    function AddUserToGroups
    {
        if ! [ adduser "$SUDO_USER" "input" &> /dev/null ] \
            || ! [ adduser "$SUDO_USER" "libvirt" &> /dev/null ]; then
            echo -e "$_PREFIX_ERROR Failed to add user '$SUDO_USER' to groups."
            return 1
        fi

        return 0
    }

    # <summary>
    # isolcpus: Allocate host CPU cores (and/or threads), to reduce host overhead, and improve both host and guest performance.
    # </summary
    function Allocate_CPU
    {
        function AskToContinue
        {
            for _TRIES_COUNT in $( seq 0 2 ); do
                read -r -p "Allocate CPU threads to Guest(s)? [Y/n]: " _ANSWER

                case "$_ANSWER" in
                    [Yy]* )
                        return 0 ;;

                    [Nn]* )
                        return 1 ;;

                    * )
                        echo "Please answer \"Y\" or \"N\"." ;;
                esac
            done

            echo -e "$_PREFIX_ERROR Failed to answer."
            return 1
        }

        function GetThreadByCoreAnd_SMT
        {
            _THREAD=$(( _CORE + ( _SMT_FACTOR * _SUM_CORES ) ))             # NOTE: VS Code reports a syntax error here. There is none.
        }

        function GetThreadSetsForHostAndGuest
        {
            for _SMT_FACTOR in ${_SMT_FACTOR_LIST[@]}; do
                declare -a _HOST_THREADS_DELIM_LIST=( )
                declare -a _GUEST_THREADS_DELIM_LIST=( )
                local -i _THREAD

                # <remarks> Find thread sets for host. </remarks>
                for _CORE in ${_HOST_CORES_LIST[@]}; do
                    GetThreadByCoreAnd_SMT
                    _HOST_THREADS_LIST+=( "$_THREAD" )
                    _HOST_THREADS_DELIM_LIST+=( "$_THREAD" )
                done

                # <remarks> Find thread sets for guest(s). </remarks>
                for _CORE in ${_GUEST_CORES_LIST[@]}; do
                    GetThreadByCoreAnd_SMT
                    _GUEST_THREADS_LIST+=( "$_THREAD" )
                    _GUEST_THREADS_DELIM_LIST+=( "$_THREAD" )
                done

                # <remarks> Save thread sets to delimited list. </remarks>
                local -i _FIRST_THREAD_SET="${_HOST_THREADS_DELIM_LIST[0]}"
                local -i _LAST_THREAD_SET="${_HOST_THREADS_DELIM_LIST[-1]}"
                local _THREAD_SET="${_FIRST_THREAD_SET}"

                if [[ "$_FIRST_THREAD_SET" -ne "$_LAST_THREAD_SET" ]]; then
                    local _THREAD_SET="$_FIRST_THREAD_SET-$_LAST_THREAD_SET"
                fi

                _HOST_THREADS_DELIM+="$_THREAD_SET,"

                local -i _FIRST_THREAD_SET="${_GUEST_THREADS_DELIM_LIST[0]}"
                local -i _LAST_THREAD_SET="${_GUEST_THREADS_DELIM_LIST[-1]}"
                local _THREAD_SET="$_FIRST_THREAD_SET"

                if [[ "$_FIRST_THREAD_SET" -ne "$_LAST_THREAD_SET" ]]; then
                    local _THREAD_SET="$_FIRST_THREAD_SET-$_LAST_THREAD_SET"
                fi

                _GUEST_THREADS_DELIM+="$_THREAD_SET,"
            done

            return 0
        }

        function Main
        {
            local -i _TOTAL_CORES_COUNT=$( cat /proc/cpuinfo | grep "cpu cores" | uniq | grep -o "[0-9]\+" )
            local -i _TOTAL_THREADS_COUNT=$( cat /proc/cpuinfo | grep "siblings" | uniq | grep -o "[0-9]\+" )
            local -i _CORES_ALLOCATED_TO_HOST=1

            # <remarks> Set maximum number of cores allocated to host. </remarks>
            if [[ "$_SUM_CORES" -ge 4 ]]; then
                _CORES_ALLOCATED_TO_HOST=2

            elif [[ "$_SUM_CORES" -le 3 ]] \
                && [[ "$_SUM_CORES" -ge 2 ]]; then
                _CORES_ALLOCATED_TO_HOST=1

            else
                return 1
            fi

            # <remarks> Get thread sets, for host and guest(s). </remarks>
            local -ar _HOST_CORES_LIST=( $( seq 0 $(( "$_CORES_ALLOCATED_TO_HOST" - 1 )) ) )
            local -a _HOST_THREADS_LIST=( )
            local -ar _GUEST_CORES_LIST=( $( seq "$_CORES_ALLOCATED_TO_HOST" $(( "$_SUM_CORES" - 1 )) ) )
            local -ar _GUEST_THREADS_LIST=( )
            local -i _SMT_FACTOR=$(( "$_TOTAL_THREADS_COUNT" / "$_SUM_CORES" ))
            local -ar _SMT_FACTOR_LIST=( $( seq 0 $(( "$_SMT_FACTOR" - 1 )) ) )
            local _HOST_THREADS_DELIM _GUEST_THREADS_DELIM
            GetThreadSetsForHostAndGuest

            # <remarks> Truncate last delimiter. </remarks>
            if [[ ${_HOST_THREADS_DELIM: -1} == "," ]]; then
                _HOST_THREADS_DELIM="${_HOST_THREADS_DELIM::-1}"
            fi

            if [[ ${_GUEST_THREADS_DELIM: -1} == "," ]]; then
                _GUEST_THREADS_DELIM="${_GUEST_THREADS_DELIM::-1}"
            fi

            # <remarks>
            # save output to string for cpuset and cpumask
            # example:
            #   host 0-1,8-9
            #   virt 2-7,10-15
            #
            # information
            # cores     bit masks       mask
            # 0-7       0b11111111      FF      # total cores
            # 0,4       0b00010001      11      # host cores
            #
            # 0-11      0b111111111111  FFF     # total cores
            # 0-1,6-7   0b000011000011  C3      # host cores
            #
            # </remarks>

            # <remarks> Find CPU mask. </remarks>
            local _GET_HEX_MASK='echo "obase=16; $_THREAD_decimal" | bc'
            local -i _HOST_THREADS_HEX_MASK=0
            local -i _TOTAL_THREADS_HEX_MASK=0

            # <remarks> Add each decimal mask to sum. </remarks>
            for _THREAD in ${_HOST_THREADS_LIST[@]}; do
                local -i _THREAD_decimal=$(( 2 ** $_THREAD ))
                local -i _THREAD_HEX_MASK=$( eval "$_GET_HEX_MASK" )
                _HOST_THREADS_HEX_MASK+="$_THREAD_HEX_MASK"
            done

            # <remarks> Convert hexadecimal mask into hexadecimal. </remarks>
            declare -g _HOST_THREADS_HEX=$( printf '%x\n' "$_HOST_THREADS_HEX_MASK" )
            local -i _TOTAL_THREADS_HEX_MASK=$(( ( 2 ** ${_TOTAL_THREADS_COUNT} ) - 1 ))
            # declare -g _GUEST_THREADS_HEX=$( printf '%x\n' "$_TOTAL_THREADS_HEX_MASK" )

            echo -e "Allocated to Host:\t$_HOST_THREADS_DELIM"
            echo -e "Allocated to Guest:\t$_GUEST_THREADS_DELIM"

            # <remarks> Save changes. </remarks>
            declare -g _LINE_GRUB_CMDLINE_ISOLCPU="isolcpus=$_GUEST_THREADS_DELIM nohz_full=$_GUEST_THREADS_DELIM rcu_nocbs=$_GUEST_THREADS_DELIM"
            return 0
        }

        if ! "$_EXECUTE_ISOLCPU_SETUP"; then
            AskToContinue || return "$?"
        fi

        Main "$@"
        PrintPassOrFail "Allocating CPU threads..."
        return "$_LAST_EXIT_CODE"
    }

    # <summary>
    # Hugepages: Allocate host memory (RAM) to 'hugepages'.
    # Eliminate the need to defragement memory, reduce host overhead, and improve both host and guest performance.
    # </summary
    function Allocate_RAM
    {
        function AskForHugepageByteSize
        {
            if "$_IS_HUGEPAGES_SIZE_SET"; then
                return 0
            fi

            declare -gu _HUGEPAGES_BYTE_SUFFIX=""

            for _TRIES_COUNT in $( seq 0 2 ); do
                read -r -p "Enter size of Hugepages [2M/1g]:" _HUGEPAGES_BYTE_SUFFIX
                GetHugepageByteSize "$_HUGEPAGES_BYTE_SUFFIX" && return 0
            done

            echo -e "$_OUTPUT_INVALID_ANSWER"
            return 1
        }

        function AskForHugepageCount
        {
            if "$_IS_HUGEPAGES_COUNT_SET"; then
                return 0
            fi

            declare -gi _HUGEPAGES_COUNT=""

            for _TRIES_COUNT in $( seq 0 2 ); do
                read -r -p "Enter count of Hugepages [$_HUGEPAGES_MIN_SIZE-$_HUGEPAGES_MAX_SIZE]:" _HUGEPAGES_COUNT
                GetHugepageCount "$_HUGEPAGES_COUNT" && return 0
            done

            echo -e "$_OUTPUT_INVALID_ANSWER"
            return 1
        }

        function AskToContinue
        {
            for _TRIES_COUNT in $( seq 0 2 ); do
                read -r -p "Setup Hugepages? [Y/n]: " _ANSWER

                case "$_ANSWER" in
                    [Yy]* )
                        return 0 ;;

                    [Nn]* )
                        return 1 ;;

                    * )
                        echo "Please answer \"Y\" or \"N\"." ;;
                esac
            done

            echo -e "$_PREFIX_ERROR Failed to answer."
            return 1
        }

        function Main
        {
            _IS_HUGEPAGES_SETUP=false

            if ! [[ "$_INT_MAX_MEMORY" =~ '^[0-9]+$' ]]; then
                echo -e "$_PREFIX_ERROR Could not parse system memory."
                return 1
            fi

            if ! "$_IS_HUGEPAGES_COUNT_SET" \
                && ! "$_IS_HUGEPAGES_SIZE_SET" ; then
                echo -e "Hugepages is a feature which statically allocates system memory to pagefiles.\nguest(s) can use Hugepages to a peformance benefit.\nThe greater the Hugepage size, the less fragmentation of memory, and the less latency/overhead of system memory-access.\n${var_yellow}NOTE:${var_reset_color} It is recommended to use a size which is a multiple of an individual memory channel/stick.\n${var_yellow}Example:${var_reset_color} Four (4) channels of 8 GB each, use 1x, 2x, or 3x (8 GB, 16 GB, or 24 GB).\n"
                AskToContinue || return 1
            fi

            AskForHugepageByteSize || return 1
            AskForHugepageCount || return 1
            declare -gir _HUGEPAGES_ALLOCATED_MEMORY=$(( $_HUGEPAGES_COUNT * $_HUGEPAGES_SIZE_IN_KBIT ))
            declare -gr _OUTPUT_GRUB_CMDLINE_HUGEPAGES="default_hugepagesz=$_HUGEPAGES_BYTE_SUFFIX hugepagesz=$_HUGEPAGES_BYTE_SUFFIX hugepages=$_HUGEPAGES_COUNT"
            _IS_HUGEPAGES_SETUP=true
            return 0
        }

        echo
        Main
        PrintPassOrFail "Allocating RAM to pages..."
        return "$_LAST_EXIT_CODE"
    }

    function ExecuteUtilsSetups
    {
        AddUserToGroups || return "$?"

        if "$_EXECUTE_ALL_UTILS_SETUPS"; then
            Allocate_CPU || return "$?"
            Allocate_RAM || return "$?"
            Virtual_KVM || return "$?"
            return 0
        fi

        if "$_EXECUTE_ISOLCPU_SETUP"; then
            Allocate_CPU || return "$?"
        fi

        if "$_EXECUTE_HUGEPAGES_SETUP"; then
            Allocate_RAM || return "$?"
        fi

        if "$_EXECUTE_EVDEV_SETUP"; then
            Virtual_KVM || return "$?"
        fi

        Modify_QEMU || return "$?"
        return 0
    }

    # <summary>
    # libvirt-qemu: Append necessary changes to QEMU system file, including user groups, Evdev, Hugepages, and NVRAM (for UEFI guest(s)).
    # </summary>
    function Modify_QEMU
    {
        function Main
        {
            declare -a arr_file1_evdev_cgroups=( )
            declare -a arr_file1_default_cgroups=(
                "        \"/dev/null\", \"/dev/full\", \"/dev/zero\","
                "        \"/dev/random\", \"/dev/urandom\","
                "        \"/dev/ptmx\", \"/dev/KVM\","
                "        \"/dev/rtc\", \"/dev/hpet\""
            )

            declare -a arr_file1_contents arr_file1_current arr_file2_contents arr_file2_current
            local str_backup1="https://github.com/libvirt/libvirt/blob/master/src/qemu/qemu.conf.in"
            # local str_backup2=""
            local str_daemon1="libvirtd"
            local str_daemon1_packages="qemu"
            local str_file1="/etc/libvirt/qemu.conf"
            local str_file2="/etc/apparmor.d/local/abstractions/libvirt-qemu"

            # <remarks> Check if Libvirt is installed. </remarks>
            IsInstalledPackage "${str_daemon1_packages}" &> /dev/null || InstallPackage "${str_daemon1_packages}" || return "$?"

            # <remarks> Save file before work. </remarks>
            BackupFile "${str_file1}" || return "$?"
            BackupFile "${str_file2}" || return "$?"

             # <remarks> Grab original system files. </remarks>
            if SetInternetStatus && $_IS_CONNECTED_TO_INTERNET; then
                curl "${str_backup_file1}" -o "${str_orig_file1}"
                # curl "${str_backup_file2}" -o "${str_orig_file2}"
            fi

            # <remarks> Check if system files are unmodified. </remarks>
            local bool_is_file1_original=true
            local bool_is_file2_original=true

            # TODO: delete lines the exist within range of the disclaimer and and end cap.

            for var_line in ${_DISCLAIMER_FILE_CONTENTS[@]}; do
                FindLineInFile "${str_file1}" "${var_line}" || bool_is_file1_original=false
            done

            for var_line in ${_DISCLAIMER_FILE_CONTENTS[@]}; do
                FindLineInFile "${str_file2}" "${var_line}" || bool_is_file2_original=false
            done

            # <remarks> Overwrite system file with a backup or original copy. </remarks>
            if ! $bool_is_file1_original; then
                if IsFile "${str_backup_file1}" &> /dev/null && ! AreEqualFiles "${str_backup_file1}" "${str_file2}"; then
                    cp "${str_orig_file1}" "${str_file1}" || (
                        RestoreFile "${str_file1}"
                        return "$?"
                    )
                elif ! IsFile "${str_backup_file1}" &> /dev/null; then  # TODO: to be revised
                    RestoreFile "${str_file1}" || return "$?"
                else
                    return 1
                fi
            fi

            if ! $bool_is_file2_original; then
                if IsFile "${str_backup_file2}" &> /dev/null && ! AreEqualFiles "${str_backup_file2}" "${str_file2}"; then
                    cp "${str_orig_file2}" "${str_file2}" || (
                        RestoreFile "${str_file2}"
                        return "$?"
                    )
                elif ! IsFile "${str_backup_file2}" &> /dev/null; then  # TODO: to be revised
                    RestoreFile "${str_file2}" || return "$?"
                else
                    return 1
                fi
            fi

            # <remarks> Format input for Evdev. </remarks>
            if $_IS_EVDEV_SETUP; then
                for var_device in ${_EVENT_DEVICES_LIST[@]}; do
                    arr_file1_evdev_cgroups+=( "        \"/dev/input/by-id/${var_device}\"," )
                done

                for var_device in ${_INPUT_DEVICES_LIST[@]}; do
                    arr_file1_evdev_cgroups+=( "        \"/dev/input/by-id/${var_device}\"," )
                done
            fi

            # <remarks> Preface file contents. </remarks>
            arr_file1_contents=( "${_DISCLAIMER_FILE_CONTENTS[@]}" )
            arr_file2_contents=( "${_DISCLAIMER_FILE_CONTENTS[@]}" )
            arr_file1_contents+=(
                ""
                "### User permissions ###"
            )

            # <remarks> Add user and group for Evdev. </remarks>
            if IsString "${_FIRST_USER}" && ($_IS_EVDEV_SETUP || $_IS_SCREAM_SETUP); then
                arr_file1_contents+=(
                    "user = \"${_FIRST_USER}\""
                    "group = \"user\""
                )
            else
                arr_file1_contents+=(
                    "#user = \"user\""
                    "#group = \"user\""
                )

                ( return "${int_code_skipped_operation}" )
            fi

            # <remarks> Hugepages </remarks>
            arr_file1_contents+=(
                ""
                "### Hugepages ###"
            )

            if $_IS_HUGEPAGES_SETUP; then
                arr_file1_contents+=(
                    "hugetlbfs_mount = \"/dev/hugepages\""
                )
            else
                arr_file1_contents+=(
                    "#hugetlbfs_mount = \"/dev/hugepages\""
                )

                ( return "${int_code_skipped_operation}" )
            fi

            # <remarks> Add cgroups for Evdev. </remarks>
            arr_file1_contents+=(
                ""
                "### Devices ###"
                "cgroup_device_acl = ["
            )

            if $_IS_EVDEV_SETUP; then
                arr_file1_contents+=(
                    "${arr_file1_evdev_cgroups[@]}"
                    "${arr_file1_default_cgroups[@]}"
                    "]"
                )

                arr_file2_contents+=(
                    ""
                    "# EVDEV"
                    "/dev/input/* rw,"
                    "/dev/input/by-id/* rw,"
                )
            else
                arr_file1_contents+=(
                    "${arr_file1_default_cgroups[@]}"
                    "]"
                )

                ( return "${int_code_skipped_operation}" )
            fi

            # <remarks> Adds NVRAM for EFI kernels in UEFI guest(s). </remarks>
            arr_file1_contents+=(
                ""
                "nvram = ["
                "        \"/usr/share/OguestF/OguestF_CODE.fd:/usr/share/OguestF/OguestF_VARS.fd\","
                "        \"/usr/share/OguestF/OguestF_CODE.secboot.fd:/usr/share/OguestF/OguestF_VARS.fd\","
                "        \"/usr/share/AAguestF/AAguestF_CODE.fd:/usr/share/AAguestF/AAguestF_VARS.fd\","
                "        \"/usr/share/AAguestF/AAguestF32_CODE.fd:/usr/share/AAguestF/AAguestF32_VARS.fd\""
                "]"
            )

            # <remarks> Append changes to file(s). </remarks>
            if ! IsFile "${str_file1}" &> /dev/null || ( ReadFile "arr_file1_current" "${str_file1}" &> /dev/null && IsArray "arr_file1_current" && ! AreEqualArrays "arr_file1_current" "arr_file1_contents" ); then
                OverwriteFile "arr_file1_contents" "${str_file1}" || return "$?"
            fi

            if ! IsFile "${str_file2}" &> /dev/null || ( ReadFile "arr_file2_current" "${str_file1}" &> /dev/null && IsArray "arr_file2_current" && ! AreEqualArrays "arr_file2_current" "arr_file2_contents" ); then
                OverwriteFile "arr_file2_contents" "${str_file2}" || return "$?"
            fi

            # <remarks> Libvirtd service </remarks>
            IsActiveDaemon "${str_daemon1}" || (
                systemctl enable "${str_daemon1}" || return 1
            )
            systemctl restart "${str_daemon1}"
            return "$?"
        }

        echo
        Main
        PrintPassOrFail "Appending libvirt-qemu..."
        return "$_LAST_EXIT_CODE"
    }

    # <summary>
    # Evdev: Setup a virtual Keyboard-Video-Mouse switch (excluding the Video).
    # Will allow a user to swap between active guest(s) and host, with the use of a pre-defined macro (example: 'L-CTRL' + 'R-CTRL').
    # </summary>
    function Virtual_KVM
    {
        function AskToContinue
        {
            for _TRIES_COUNT in $( seq 0 2 ); do
                read -r -p "Setup Evdev? [Y/n]: " _ANSWER

                case "$_ANSWER" in
                    [Yy]* )
                        return 0 ;;

                    [Nn]* )
                        return 1 ;;

                    * )
                        echo "Please answer \"Y\" or \"N\"." ;;
                esac
            done

            echo -e "$_PREFIX_ERROR Failed to answer."
            return 1
        }

        function Main
        {
            declare -ag _EVENT_DEVICES_LIST=( $( ls -l /dev/input/by-id | cut -d "/" -f2 | grep -v "total 0" ) )
            declare -ag _INPUT_DEVICES_LIST=( $( ls /dev/input/by-id ) )

            if [[ "${#_EVENT_DEVICES_LIST[@]}" -eq 0 ]] \
                ||[[ "${#_INPUT_DEVICES_LIST[@]}" -eq 0 ]]; then
                _IS_EVDEV_SETUP=false
                echo -e "$_PREFIX_ERROR Cannot parse input devices (by ID)."
                return 1
            fi

            _IS_EVDEV_SETUP=true
            return 0
        }

        echo

        if ! "$_EXECUTE_EVDEV_SETUP"; then
            echo -e "Evdev (Event Devices) is a method of creating a virtual KVM (Keyboard-Video-Mouse) switch between host and guest(s).\n${var_yellow}HOW-TO:${var_reset_color} Press 'L-CTRL' and 'R-CTRL' simultaneously.\n"
            AskToContinue || return "$?"
        fi

        Main
        PrintPassOrFail "Executing Evdev setup..."
        return "$_LAST_EXIT_CODE"
    }
# </code>