#!/bin/bash sh

#
# Filename:         vfiolib-extras
# Description:      Recommended post-installation setups.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <remarks> Using </remarks>
# <code>
    source vfiolib-calcss
    source vfiolib-iommu
# </code>

# <params>
    declare -g _THIS_HOME_PATH=$( getent passwd "$( whoami )" | cut -d: -f6 )
    declare -g _GIT_PATH="${_THIS_HOME_PATH}/source/"
    declare -g _FILES_PATH="${_THIS_HOME_PATH}/Downloads/"

    # <remarks> Flag progress of setups </remarks>
    declare -g _IS_AUDIO_CAPTURE_SETUP=false
    declare -g _IS_SCREAM_SETUP=false
# </params>

# <code>
    # <summary>
    # zramswap: Setup a swap partition in host memory.
    # Reduce swapiness to existing host swap partition(s)/file(s), and reduce chances of memory exhaustion as host over-allocates memory.
    # </summary>
    function AllocateRAMToSwap
    {
        function Install
        {
            # <params>
            local _USER_NAME="foundObjects"
            local _REPO_NAME="zram-swap"
            local _FULL_REPO="$_USER_NAME/$_REPO_NAME"
            local _SCRIPT_NAME="install.sh"
            # </params>

            GetScriptDir || return 1
            echo
            UpdateOrCloneGitRepo "$_GIT_PATH" "$_FULL_REPO" "$_USER_NAME" || return 1
            cd "$_GIT_PATH$_FULL_REPO" || return 1
            [ -e "$_SCRIPT_NAME" ] || return 1
            sudo bash "$_SCRIPT_NAME" || return 1
            GetScriptDir || return 1
            return 0
        }

        function Modify
        {
            # <params>
            local _FILE_1="/etc/default/zram-swap"
            local str_match_line1="_zram_fraction="
            local var_find_zram_swap='swapon -v | grep zram'
            local var_disable_zram_swap='swapoff /dev/zram*'
            local var_enable_all_swap='swapon -a'
            local var_restart_daemon='systemctl restart zram-swap'
            declare -a arr_file_contents=( $( cat "${_FILE_1}" ) )
            # </params>

            # <remarks> Replace matching line with comment of line </remarks>
            for _KEY in ${!arr_file_contents[@]}; do
                if [[ "${arr_file_contents[$_KEY]}" == *"${str_match_line1}"* ]]; then
                    arr_file_contents[$_KEY]="#${arr_file_contents[$_KEY]}"
                fi
            done

            if ! IsNum "${_INT_MAX_MEMORY}"; then
                local _OUTPUT_could_not_parse_memory="$_PREFIX_ERROR Could not parse system memory."
                echo -e "${_OUTPUT_could_not_parse_memory}"
                return 1
            fi

            if IsNum "${int_alloc_mem_hugepages}"; then
                local -i int_usable_mem=$(( ( _INT_MAX_MEMORY - int_alloc_mem_hugepages ) / 2 ))
            else
                local -i int_usable_mem=$(( _INT_MAX_MEMORY / 2 ))
            fi

            local -i int_denominator=$( printf "%.0f" $( echo "scale=2;${_INT_MAX_MEMORY}/${int_usable_mem}" | bc ) )

            # <remarks> Round down to nearest even number. </remarks>
            if [[ $( expr $int_denominator % 2 ) -eq 1 ]]; then
                (( int_denominator-- ))
            fi

            # <remarks> Is fraction positive non-zero and not equal to one. </remarks>
            if [[ "${int_denominator}" -gt 1 ]]; then
                local str_fraction="1/${int_denominator}"

                arr_file_contents+=(
                    ""
                    "#"
                    "# Generated by '${str_full_repo_name}'"
                    "#"
                    "# WARNING: Any modifications to this file will be modified by '${str_repo_name}'"
                    "${str_match_line1}\"${str_fraction}\""
                )
            fi

            OverwriteFile "arr_file_contents" "${_FILE_1}" || return 1
            eval "${var_find_zram_swap}" &> /dev/null && eval "${var_disable_zram_swap}" &> /dev/null
            eval "${var_restart_daemon}" || return 1
            eval "${var_enable_all_swap}" || return 1
            return 0
        }

        if ! IsHostMemorySufficientForZramSwap \
            || ! Install \
            || ! Modify &> /dev/null; then
            false
        fi

        PrintPassOrFail "Allocating RAM to swap..."
        return "$_LAST_EXIT_CODE"
    }

    function ExecuteExtras
    {
        GuestAudioCapture

        if "$_EXECUTE_ALL_EXTRAS_SETUPS"; then
            AllocateRAMToSwap
            SetVideoOutput
            LibvirtHooks
            GuestAudioLoopback
            GuestAudioStream
            GuestVideoCapture
            return 0
        fi

        if "$_EXECUTE_ZRAM_SWAP"; then
            AllocateRAMToSwap || return 1
        fi

        if "$_EXECUTE_AUTO_XORG_SETUP"; then
            SetVideoOutput || return 1
        fi

        if "$_EXECUTE_LIBVIRT_HOOKS"; then
            LibvirtHooks || return 1
        fi

        if "$_EXECUTE_AUDIO_LOOPBACK_SETUP"; then
            GuestAudioLoopback || return 1
        fi

        if "$_EXECUTE_SCREAM"; then
            GuestAudioStream || return 1
        fi

        if "$_EXECUTE_LOOKING_GLASS"; then
            GuestVideoCapture || return 1
        fi

        ModifyQEMU || return 1
        return 0
    }


    # <summary>
    # Install necessary depenencies to setup an audio capture from guest emulated audio device to host audio backend.
    # Installs PulseAudio or ALSA.
    # </summary>
    # <remarks>
    # References:
    #   https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Passing_through_other_devices
    # </remarks>
    function GuestAudioCapture
    {
        function Main
        {
            # <params>
            local str_dependencies=""
            # </params>

            # <remarks> Install JACK and PipeWire. </remarks>
            case "${_PACKAGE_MANAGER}" in
                "apt" )
                    str_dependencies+="pipewire pipewire-jack "
                    ;;

                "pacman" )
                    str_dependencies+="pipewire pipewire-jack "
                    ;;

                * )
                    return 1
            esac

            # <remarks> Include PulseAudio (and QEMU driver if available). </remarks>
            if IsInstalledCommand "pulseaudio" &> /dev/null; then
                case "${_PACKAGE_MANAGER}" in
                    "apt" )
                        str_dependencies+="pipewire-pulse "
                        ;;

                    "pacman" )
                        str_dependencies+="pipewire-pulse qemu-audio-pa "
                        ;;

                    * )
                        return 1
                esac

            # <remarks> Fallback to factory driver. </remarks>
            else
                case "${_PACKAGE_MANAGER}" in
                    "apt" )
                        str_dependencies+="pipewire-alsa "

                        ;;

                    "pacman" )
                        str_dependencies+="pipewire-alsa "
                        ;;

                    * )
                        return 1
                esac
            fi

            IsInstalledPackage "${str_dependencies}" || InstallPackage "${str_dependencies}"
            return "$?"
        }

        local _OUTPUT="Installing audio drivers..."
        Main &> /dev/null
        PrintPassOrFail "${_OUTPUT}" && _IS_AUDIO_CAPTURE_SETUP=true || _IS_AUDIO_CAPTURE_SETUP=false
        return "$_LAST_EXIT_CODE"
    }

    # <summary>
    # Setup an audio loopback service from physical guest audio device (Line-Out) to physical host audio device (Line-In).
    # Requires physical connection between Line-Out and Line-In, and audio backend with JACK support (requires PulseAudio or ALSA).
    # </summary>
    function GuestAudioLoopback
    {
        function Main
        {
            # <remarks> Get audio backend. </remarks>
            if ! IsInstalledCommand "pulseaudio"; then
                return "$?"
            fi

            # <params>
            declare -a arr_file1_current _FILE_1_CONTENTS=(
                "[Unit]"
                "Description=Load audio loopback module"
                "After=pulseaudio.service"
                ""
                "[Service]"
                "Type=simple"
                "ExecStart=pactl load-module module-loopback"
                "ExecStop=pactl unload-module module-loopback"
                "RemainAfterExit=yes"
                ""
                "[Install]"
                "WantedBy=default.target"
            )

            local _PATH_1="/etc/systemd/system/"
            local _FILE_1="audio-loopback-user.service"
            # </params>

            if ! IsFile "${_FILE_1}" &> /dev/null || ( ReadFile "arr_file1_current" "${_FILE_1}" && IsArray "arr_file1_current" && ! AreEqualArrays "arr_file1_current" "_FILE_1_CONTENTS" ); then
                OverwriteFile "_FILE_1_CONTENTS" "${_PATH_1}${_FILE_1}" || return 1
            fi

            systemctl daemon-reload || return 1
            systemctl enable "${_FILE_1}" || return 1
            systemctl restart "${_FILE_1}" || return 1
            return 0
        }

        local _OUTPUT="Creating audio loopback..."
        Main &> /dev/null
        PrintPassOrFail "${_OUTPUT}"
        return "$_LAST_EXIT_CODE"
    }

    # <summary>
    # Scream: Setup an audio stream from guest to host.
    # Requires virtual network bridge between guest and host, and operating systems Windows 7/8/10/11.
    # </summary>
    # <remarks>
    # References:
    #   https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Passing_audio_from_virtual_machine_to_host_via_Scream
    # </remarks>
    function GuestAudioStream
    {
        function Build
        {
            echo

            # <remarks> Build client </remarks>
            IsFile "build" || ( mkdir build || return 1 )
            cd build || return 1
            cmake .. || return 1
            make || return 1
            return 0
        }

        function Get
        {
            # <params>
            local _USER_NAME="duncanthrax"
            local _REPO_NAME="scream"
            local _FULL_REPO="${_USER_NAME}/${_REPO_NAME}"
            local str_dependencies=""
            # </params>

            # <remarks> Set dependencies for successful build. </remarks>
            case "${_PACKAGE_MANAGER}" in
                "apt" )
                    str_dependencies="cmake "
                    ;;

                "yum" )
                    str_dependencies="cmake "
                    ;;

                * )
                    return "$?"
                    ;;
            esac

            # <remarks> Set dependencies for available audio backend. </remarks>
            if IsInstalledCommand "pulseaudio"; then
                case "${_PACKAGE_MANAGER}" in
                    "apt" )
                        str_dependencies+="libpulse-dev "
                        ;;

                    "yum" )
                        str_dependencies+="pulseaudio-libs-devel "
                        ;;

                   * )
                        return "$?"
                        ;;
                esac
            elif IsInstalledCommand "pipewire-alsa"; then
                case "${_PACKAGE_MANAGER}" in
                    "apt" )
                        str_dependencies+="ibasound2-dev "
                        ;;

                    "yum" )
                        str_dependencies+="alsa-lib-devel "
                        ;;

                    * )
                        return "$?"
                        ;;
                esac
            else
                return 1
            fi

            # <remarks> Get dependencies. </remarks>
            if ! IsInstalledPackage "${str_dependencies}" &> /dev/null; then
                echo
                InstallPackage "${str_dependencies}" || return 1
                echo
            fi

            GetScriptDir
            echo
            UpdateOrCloneGitRepo "${_GIT_PATH}" "${_FULL_REPO}" "${_USER_NAME}" || return 1
            GetScriptDir
            cd "${_GIT_PATH}${_FULL_REPO}" || return 1
            return 0
        }

        function Install
        {
            # <params>
            declare -a arr_file1_current _FILE_1_CONTENTS arr_file2_contents
            local str_audio_backend_command str_audio_backend_name
            local _PATH_1="/etc/systemd/system/"
            local _FILE_1="audio-loopback-user.service"
            local str_dir2="${str_user_home_dir}/config/systemd/user/"
            local str_file2="scream-ivshmem-pulse.service"
            # </params>

            # <remarks> Get audio backend. </remarks>
            if ! IsInstalledCommand "pulseaudio" && ! IsInstalledCommand "pipewire"; then
                return "$?"
            elif IsInstalledCommand "pulseaudio" &> /dev/null; then
                str_audio_backend_name="PulseAudio"
            else
                str_audio_backend_name="PipeWire"
            fi

            str_audio_backend_command=$( echo $str_audio_backend_name | tr '[:upper:]' '[:lower:]' )

            arr_file_contents=(
                "[Unit]"
                "Description=${str_audio_backend_name} - QEMU"
                "ConditionUser=!root"
                ""
                "[Socket]"
                "Service=${str_audio_backend_command}-pulse.service"
                "Priority=6"
                "ListenStream=%T/${str_audio_backend_command}-qemu"
                "SocketGroup=libvirt-qemu"
                "SocketMode=0660"
                ""
                "[Install]"
                "RequiredBy=${str_audio_backend_command}-pulse.service"
                "WantedBy=sockets.target"
            )

            declare -a arr_file2_contents=(
                "[Unit]"
                "Description=Scream IVSHMEM pulse receiver"
                "After=${str_audio_backend_command}.service"
                "Wants=${str_audio_backend_command}.service"
                ""
                "[Service]"
                "Type=simple"
                "ExecStartPre=/usr/bin/truncate -s 0 /dev/shm/scream-ivshmem"
                "ExecStartPre=/usr/bin/dd if=/dev/zero of=/dev/shm/scream-ivshmem bs=1M count=2"
                "ExecStart=/usr/bin/scream -m /dev/shm/scream-ivshmem"
                ""
                "[Install]"
                "WantedBy=default.target"
            )

            if ! IsFile "${_FILE_1}" &> /dev/null || ( ReadFile "arr_file1_current" "${_FILE_1}" && IsArray "arr_file1_current" && ! AreEqualArrays "arr_file1_current" "_FILE_1_CONTENTS" ); then
                OverwriteFile "_FILE_1_CONTENTS" "${_PATH_1}${_FILE_1}" || return 1
            fi

            if ! IsFile "${str_file2}" &> /dev/null || ( ReadFile "arr_file2_current" "${str_file2}" && IsArray "arr_file2_current" && ! AreEqualArrays "arr_file2_current" "arr_file2_contents" ); then
                OverwriteFile "arr_file2_contents" "${str_dir2}${str_file2}" || return 1
            fi

            systemctl daemon-reload || return 1
            systemctl enable "${_FILE_1}" || return 1
            systemctl restart "${_FILE_1}" || return 1
            return 0
        }

        if ! GuestAudioCapture; then
            local _OUTPUT="Installing Scream...\t"
            (return "${int_code_skipped_operation}")
        else
            local _OUTPUT="Updating Scream..."
            # PrintWait "${_OUTPUT}"
            Get &> /dev/null
            PrintPassOrFail "${_OUTPUT}"

            local _OUTPUT="Building Scream..."
            # PrintWait "${_OUTPUT}"

            if Build; then
                PrintPassOrFail "${_OUTPUT}"

                local _OUTPUT="Installing Scream...\t"
                # PrintWait "${_OUTPUT}"
                Install
            fi
        fi

        PrintPassOrFail "${_OUTPUT}" && _IS_SCREAM_SETUP=true
        return "$_LAST_EXIT_CODE"
    }

    # <summary>
    # LookingGlass: Setup direct-memory-access of video framebuffer (and audio?) from guest to host.
    # Requires operating systems Windows 7/8/10/11.
    # </summary>
    # <remarks>
    # References:
    #   https://looking-glass.io/docs/B6/install/#client-install
    # </remarks>
    function GuestVideoCapture
    {
        function Get
        {
            # <params>
            local _USER_NAME="gnif"
            local _REPO_NAME="LookingGlass"
            local _FULL_REPO="${_USER_NAME}/${_REPO_NAME}"
            local str_dependencies=""
            # </params>

            case "${_PACKAGE_MANAGER}" in
                "apt" )
                    str_dependencies="cmake gcc g++ clang libegl-dev libgl-dev libgles-dev libfontconfig-dev libgmp-dev libspice-protocol-dev make nettle-dev pkg-config"
                    ;;

                # "yum" )
                #     local str_package=""
                #     ;;
            esac

            if ! IsInstalledPackage "${str_dependencies}" &> /dev/null; then
                echo
                InstallPackage "${str_dependencies}" || return 1
                echo
            fi

            GetScriptDir
            echo
            UpdateOrCloneGitRepo "${_GIT_PATH}" "${_FULL_REPO}" "${_USER_NAME}" || return 1
            GetScriptDir
            cd "${_GIT_PATH}${_FULL_REPO}" || return 1
            return 0
        }

        function Install
        {
            echo

            # <remarks> Build client </remarks>
            if [[ -z "client/build" ]]; then
                mkdir client/build || return 1
            fi

            cd client/build || return 1
            cmake ../ || ( git submodule update --init --recursive && cmake ../ ) || return 1
            make || return 1                                                            # TODO: fix here!

            # <remarks> Conclude build as root or user. </remarks>
            if [[ $( whoami ) != "root" ]]; then
                make install || return 1
            else
                cmake -DCMAKE_INSTALL_PREFIX=~/.local .. && make install
            fi

            return 0
        }

        Get
        PrintPassOrFail "Updating LookingGlass..."
        Install
        PrintPassOrFail "Installing LookingGlass..."
        return "$_LAST_EXIT_CODE"
    }

    # <summary>
    # libvirt-hooks: Setup useful Quality-of-life improvements in the form of services and scripts (hooks) for QEMU guest(s).
    # </summary>
    function LibvirtHooks
    {
        function Main
        {
            if ! sudo cp "$_LIBVIRT_HOOK_NOSLEEP_FILE_BACKUP" "$_LIBVIRT_HOOK_NOSLEEP_FILE_PATH"; then
                echo -e "$_PREFIX_ERROR Failed to copy file."
                return 1
            fi

            if ! sudo systemctl daemon-reload &> /dev/null then
                echo -e "$_PREFIX_ERROR Failed to update systemd with new daemon/service."
                return 1
            fi

            return 0
        }

        Main
        PrintPassOrFail "Installing libvirt-hooks..."
        return "$_LAST_EXIT_CODE"
    }

    # <summary>
    # auto-Xorg: System service to find and set a valid Host boot VGA device for Xorg.
    # </summary>
    # <remarks>
    # References:
    #   https://github.com/portellam/auto-Xorg
    # </remarks>
    function SetVideoOutput
    {
        # TODO
        return 1
    }
# </code>