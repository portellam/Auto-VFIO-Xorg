#!/bin/bash sh

#
# Filename:         vfiolib-iommu
# Description:      Parse and select IOMMU groups.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <params>
    declare -ag _DRIVER_LIST_VFIOPCI _PCISTUB_IOMMU_LIST _VFIOPCI_IOMMU_LIST _VGA_VFIOPCI_IOMMU_LIST _HWID_LIST_PCISTUB _HWID_LIST_VFIOPCI _HWID_LIST_VFIOPCI_WITH_VGA
    declare -g bool_VFIO_has_IOMMU=false

    # <remarks> Known kernel drivers to ignore; drivers that cause issues when binded to vfio-pci/pci-stub. </remarks>
    declare -ag _DRIVER_LIST_TO_IGNORE=(
        "snd_hda_intel"
    )
# </params>

# <code>
    # <summary> Parse VFIO list for drivers and hardware IDs. </summary>
    function Get_IOMMU_Lists
    {
        for _KEY in ${!_IOMMU_LIST[@]}; do
            local _ANY_LIST_HAS_IOMMU=false
            local _SLOT_ID="${_SLOT_ID_LIST[$_KEY]}"
            local _THIS_DOMAIN_ID=$( echo "$_SLOT_ID" | cut -d ':' -f 1 )
            local -i _DOMAIN_ID=_DOMAIN_ID="${_THIS_DOMAIN_ID##*0}"
            local _DRIVER=""
            local _HWID=""
            local _THIS_IOMMU=""

            if [[ "$_DOMAIN_ID" -gt 0 ]]; then
                _DRIVER="${_DRIVER_LIST[$_KEY]}"
                _HWID="${_HWID_LIST[$_KEY]}"
                _THIS_IOMMU="${_IOMMU_LIST[$_KEY]}"
            fi

            for _DRIVER_TO_IGNORE in ${_DRIVER_LIST_TO_IGNORE[@]}; do
                if [[ "$_DRIVER_TO_IGNORE" == "$_DRIVER" ]]; then
                    _DRIVER=""
                    break
                fi
            done

            # <remarks> Check if any IOMMU group exists in a given list. </remarks>
            for _IOMMU in ${_PCISTUB_IOMMU_LIST[@]}; do
                if [[ "$_IOMMU" -eq "$_THIS_IOMMU" ]]; then
                    _HWID_LIST_PCISTUB+=( "$_HWID" )
                    _ANY_LIST_HAS_IOMMU=true
                    break
                fi
            done

            for _IOMMU in ${_VFIOPCI_IOMMU_LIST[@]}; do
                if [[ "$_IOMMU" -eq "$_THIS_IOMMU" ]]; then
                    _HWID_LIST_VFIOPCI+=( "$_HWID" )
                    _ANY_LIST_HAS_IOMMU=true
                    break
                fi
            done

            for _IOMMU in ${_VGA_VFIOPCI_IOMMU_LIST[@]}; do
                if [[ "$_IOMMU" -eq "$_THIS_IOMMU" ]]; then
                    _DRIVER_LIST_VFIOPCI_WITH_VGA+=( "$_DRIVER" )
                    _HWID_LIST_VFIOPCI_WITH_VGA+=( "$_HWID" )
                    _ANY_LIST_HAS_IOMMU=true
                    break
                fi
            done

            if "$_ANY_LIST_HAS_IOMMU"; then
                _DRIVER_LIST_VFIOPCI+=( "$_DRIVER" )
            fi
        done

        # TODO: verify this change !
        if [[ "${#_DRIVER_LIST_VFIOPCI[@]}" -eq 0 ]] \
            || [[ "${#_DRIVER_LIST_VFIOPCI_WITH_VGA[@]}" -eq 0 ]] \
            || [[ "${#_HWID_LIST_PCISTUB[@]}" -eq 0 ]] \
            || [[ "${#_HWID_LIST_VFIOPCI[@]}" -eq 0 ]] \
            || [[ "${#_HWID_LIST_VFIOPCI_WITH_VGA[@]}" -eq 0 ]]; then
            echo -e "$_PREFIX_ERROR Some or all Setup driver/HWID lists are empty."
            return 1
        fi

        return 0
    }

    # <summary> Is Virtualization enabled on the current system. If true, pass. </summary>
    function IsEnabled_IOMMU
    {
        if ! compgen -G "/sys/kernel/iommu_groups/*/devices/*"; then
            echo -e "$_PREFIX_ERROR System does not support Virtualization."
            return 1
        fi
    }

    # <summary>
    # Parse IOMMU groups for all relevant information.
    # If a parse fails, attempt again another way. If all parses fail, fail.
    # </summary>
    function Parse_IOMMU
    {
        function Main
        {
            # <remarks> Save input params </remarks>
            _OPTION="$1"

            # <remarks> Output statements </remarks>
            local _OUTPUT_PARSE_FILE="Parsing PCI from file..."
            local _OUTPUT_PARSE_ONLINE="Parsing PCI from Internet..."
            local _OUTPUT_PARSE_LOCAL="Parsing PCI from system..."
            local _OUTPUT_IS_VFIO_SETUP="$_PREFIX_ERROR Found existing VFIO setup."

            # <remarks> Declare lists </remarks>
            declare -ag _DRIVER_LIST _HWID_LIST _IOMMU_LIST
            local -a _CLASS_LIST _DEVICE_ID_LIST _DEVICE_NAME_LIST _SLOT_ID_LIST _VENDOR_ID_LIST _VENDOR_NAME_LIST

            # <remarks> Set commands </remarks>
            local _PARSE='lspci -k -mm'
            local _PARSE_ARGS_FILE='-F "$_PARSE_IOMMU_FILENAME"'
            local _PARSE_ARGS_ONLINE='-q'
            local _PARSE_ARGS_NUMS='-n'
            local _PARSE_ARGS_SLOT_ID='-s $_DEVICE'
            local _PARSE_ARGS_VERBOSE='-v'
            local _PARSE_TO_FILE='lspci -x >> "$_PARSE_IOMMU_FILENAME"'
            local _PARSE_ALL_ID="$_PARSE $_PARSE_ARGS_NUMS $_PARSE_ARGS_VERBOSE $_PARSE_ARGS_SLOT_ID"
            local _PARSE_HWID="$_PARSE $_PARSE_ARGS_NUMS $_PARSE_ARGS_SLOT_ID"
            local _PARSE_NAME_ID="$_PARSE $_PARSE_ARGS_VERBOSE $_PARSE_ARGS_SLOT_ID"
            local _PARSE_SLOT_ID="$_PARSE"
            local _PARSE_QUOTES="$_PARSE $_PARSE_ARGS_NUMS"

            # <remarks> Set commands for each parse type. </remarks>
            Parse_IOMMU_Set_Operation || return "$?"

            # <remarks> Get all devices from system. </remarks>
            local -a _DEVICES_LIST=( $( eval "$_PARSE_SLOT_ID" | awk '{print $1}' ) )
            Parse_IOMMU_Save_Lists || return "$?"
            Parse_IOMMU_Are_Not_Empty_Lists || return "$?"
            Parse_IOMMU_Are_Inequal_Lists_Sizes || return "$?"

            # <remarks> Save output to file. </remarks>
            if [[ $? -eq 0 ]] \
                && [[ "$_OPTION" != "$_OPTION_PARSE_IOMMU_FILE" ]] \
                && [[ -z "$_PARSE_IOMMU_FILENAME" ]]; then
                eval "$_PARSE_TO_FILE"
            fi

            return 0
        }

        local _OUTPUT=""

        # <remarks> Set parse options </remarks>
        local _OPTION_PARSE_IOMMU_FILE="FILE"
        local _OPTION_PARSE_IOMMU_ONLINE="DNS"
        local _OPTION_PARSE_IOMMU_LOCAL="LOCAL"

        # <remarks> Save input params </remarks>
        local _OPTION="$1"
        local _PARSE_IOMMU_FILENAME="$2"

        # <remarks> If an operation fails, try another. </remarks>
        case "$_OPTION" in
            "$_OPTION_PARSE_IOMMU_ONLINE" )
                Main "$_OPTION_PARSE_IOMMU_ONLINE" "$_PARSE_IOMMU_FILENAME"
                ;;

            "$_OPTION_PARSE_IOMMU_FILE" )
                Main "$_OPTION_PARSE_IOMMU_FILE" "$_PARSE_IOMMU_FILENAME" || Main "$_OPTION_PARSE_IOMMU_ONLINE" "$_PARSE_IOMMU_FILENAME"
                ;;

            "$_OPTION_PARSE_IOMMU_LOCAL" | * )
                Main "$_OPTION_PARSE_IOMMU_LOCAL" "$_PARSE_IOMMU_FILENAME" || Main "$_OPTION_PARSE_IOMMU_FILE" "$_PARSE_IOMMU_FILENAME" || Main "$_OPTION_PARSE_IOMMU_ONLINE" "$_PARSE_IOMMU_FILENAME"
                ;;
        esac

        PrintPassOrFail "$_OUTPUT"
        return "$_LAST_EXIT_CODE"
    }

    function Parse_IOMMU_Are_Inequal_Lists_Sizes
    {
        # <remarks> If any list is inequal, fail. </remarks>
        if [[ "${_IOMMU_LIST[@]}" -ne "${_CLASS_LIST[@]}" ]] \
            || [[ "${_IOMMU_LIST[@]}" -ne "${_DEVICE_ID_LIST[@]}" ]] \
            || [[ "${_IOMMU_LIST[@]}" -ne "${_DEVICE_NAME_LIST[@]}" ]] \
            || [[ "${_IOMMU_LIST[@]}" -ne "${_DRIVER_LIST[@]}" ]] \
            || [[ "${_IOMMU_LIST[@]}" -ne "${_HWID_LIST[@]}" ]] \
            || [[ "${_IOMMU_LIST[@]}" -ne "${_VENDOR_ID_LIST[@]}" ]] \
            || [[ "${_IOMMU_LIST[@]}" -ne "${_VENDOR_NAME_LIST[@]}" ]]; then
            echo -e "$_PREFIX_ERROR System PCI lists' sizes are inequal."
            return 1
        fi

        return 0
    }

    function Parse_IOMMU_Are_Not_Empty_Lists
    {
        # <remarks> If any list is empty, fail. </remarks>
        if [[ "${_CLASS_LIST[@]}" == "" ]] \
            || [[ "${_DEVICE_ID_LIST[@]}" == "" ]] \
            || [[ "${_DEVICE_NAME_LIST[@]}" == "" ]] \
            || [[ "${_DRIVER_LIST[@]}" == "" ]] \
            || [[ "${_HWID_LIST[@]}" == "" ]] \
            || [[ "${_IOMMU_LIST[@]}" == "" ]] \
            || [[ "${_VENDOR_ID_LIST[@]}" == "" ]] \
            || [[ "${_VENDOR_NAME_LIST[@]}" == "" ]]; then
            echo -e "$_PREFIX_ERROR One or more system PCI lists are empty."
            return 1
        fi

        return 0
    }

    function Parse_IOMMU_Save_Lists
    {
        # <remarks> Save to lists each device's information. Lists should be of the same-size. </remarks>
        for _DEVICE in ${_DEVICES_LIST[@]}; do
            local _CLASS=$( eval "$_PARSE_NAME_ID" )
            _CLASS=$( echo -e "$_CLASS" | grep -i "Class:" | cut -d ':' -f 2 | grep -oP "^\t\K.*" )
            local _DEVICE_NAME=$( eval "$_PARSE_NAME_ID" | grep -i "Device:" | grep -Eiv "SDevice:|$_DEVICE" | cut -d ':' -f 2 | uniq | grep -oP "^\t\K.*" )
            local _DRIVER=$( eval "$_PARSE_ALL_ID" | grep -i "Driver:" | awk '{print $2}' | uniq )
            local _IOMMU=$( eval "$_PARSE_ALL_ID"| grep -i "IOMMUGroup:" | awk '{print $2}' | uniq )
            local _VENDOR_NAME=$( eval "$_PARSE_NAME_ID" | grep -i "Vendor:" | grep -Eiv "SVendor:" | cut -d ':' -f 2 | uniq | grep -oP "^\t\K.*" )
            local _HWID=$( lspci -n -s "$_DEVICE" | cut -d ' ' -f 3 )

            case "$_DRIVER" in
                    # <remarks> Match invalid input, and save as known null value. </remarks>
                "" )
                    _DRIVER="N/A"
                    ;;

                # <remarks> If system is setup for VFIO, exit. </remarks>
                "vfio-pci" )
                    echo -e "$_OUTPUT_IS_VFIO_SETUP"
                    return 1
                    ;;
            esac

            _CLASS_LIST+=( "$_CLASS" )
            _DEVICE_NAME_LIST+=( "$_DEVICE_NAME" )
            _DRIVER_LIST+=( "$_DRIVER" )
            _HWID_LIST+=( "$_HWID" )
            _IOMMU_LIST+=( "$_IOMMU" )
            _SLOT_ID_LIST+=( "$_DEVICE" )
            _VENDOR_NAME_LIST+=( "$_VENDOR_NAME" )
        done

        return 0
    }

    function Parse_IOMMU_Set_Operation
    {
        # <remarks> Set commands for each parse type. </remarks>
        case "$_OPTION" in

            # <remarks> If parsing file and file does not exist, recursive call to parse internet. </remarks>
            "$_OPTION_PARSE_IOMMU_FILE" )
                _OUTPUT="$_OUTPUT_PARSE_FILE"
                _PARSE_ALL_ID+=" $_PARSE_ARGS_FILE"
                _PARSE_NAME_ID+=" $_PARSE_ARGS_FILE"
                _PARSE_SLOT_ID+=" $_PARSE_ARGS_FILE"
                _PARSE_QUOTES+=" $_PARSE_ARGS_FILE"

                if [[ -z "$_PARSE_IOMMU_FILENAME" ]]; then
                    echo -e "$_PREFIX_ERROR Failed to find file database to parse."
                    return 1
                fi

                return 0
                ;;

            # <remarks> If internet is not available, exit. </remarks>
            "$_OPTION_PARSE_IOMMU_ONLINE" )
                _OUTPUT="$_OUTPUT_PARSE_ONLINE"
                local _PARSE_ALL_ID+=" $_PARSE_ARGS_ONLINE"
                local _PARSE_NAME_ID+=" $_PARSE_ARGS_ONLINE"
                local _PARSE_SLOT_ID+=" $_PARSE_ARGS_ONLINE"
                local _PARSE_QUOTES+=" $_PARSE_ARGS_ONLINE"

                if ! GetInternetStatus &> /dev/null; then
                    echo -e "$_PREFIX_ERROR Failed to find online database to parse."
                    return 1
                fi

                return 0
                ;;

            "$_OUTPUT_PARSE_LOCAL" | * )
                _OUTPUT="$_OUTPUT_PARSE_LOCAL"
                ;;
        esac

        return 0
    }

    # <summary> Print all relevant information about the IOMMU group. </summary>
    function Select_IOMMU_Match_IOMMU_AndClass
    {
        local _CLASS="${_CLASS_LIST[$_KEY]}"
        local _DEVICE_NAME="${_DEVICE_NAME_LIST[$_KEY]}"
        local _DRIVER="${_DRIVER_LIST[$_KEY]}"
        local _HWID="${_HWID_LIST[$_KEY]}"
        local _SLOT_ID="${_SLOT_ID_LIST[$_KEY]}"
        local _VENDOR_NAME="${_VENDOR_NAME_LIST[$_KEY]}"
        local _THIS_DOMAIN_ID=$( echo "$_SLOT_ID" | cut -d ':' -f 1 )

        # <remarks> Regex: check if value is decimal or hexadecimal and greater than zero </remarks>
        local str_regex='[a-fA-F1-9]'

        # <remarks> Output statement </remarks>
        declare -a _OUTPUT1=(
            "Slot ID:\t'$_SLOT_ID'"
            "Vendor name:\t'$_VENDOR_NAME'"
            "Device name:\t'$_DEVICE_NAME'"
            "Class/Type:\t'$_CLASS'"
            "Hardware ID:\t'$_HWID'"
            "Kernel driver:\t'$_DRIVER'"
        )

        # <remarks> Match IOMMU group </remarks>
        if [[ $_IOMMU -eq $_THIS_IOMMU ]]; then

            # <remarks> External PCI devices have domain IDs of '01' or greater. </remarks>
            if [[ $_THIS_DOMAIN_ID =~ ${str_regex} ]]; then
                _IOMMU_HAS_EXTERNAL_DOMAIN=true
            fi

            local _CLASS=$( echo "${_CLASS_LIST[$_KEY]}" | tr '[:upper:]' '[:lower:]' )
            PrintArray "_OUTPUT1"

            # <remarks> Match Class </remarks>
            case $_CLASS in
                *"graphics"* | *"vga"* | *"video"* )
                    bool_IOMMU_has_VGA=true
                    ;;

                *"usb"* )
                    bool_IOMMU_has_USB=true
                    bool_IOMMU_PCISTUB=true
                    ;;
            esac
        fi

        return 0
    }

    function Select_IOMMU_Group
    {
        if $bool_IOMMU_has_USB; then
            _PCISTUB_IOMMU_LIST+=( "${_THIS_IOMMU}" )
        else
            _PCISTUB_IOMMU_LIST+=( "" )
        fi

        if $bool_IOMMU_has_VGA; then
            _VFIOPCI_IOMMU_LIST+=( "" )
            _VGA_VFIOPCI_IOMMU_LIST+=( "${_THIS_IOMMU}" )
        else
            _VFIOPCI_IOMMU_LIST+=( "${_THIS_IOMMU}" )
            _VGA_VFIOPCI_IOMMU_LIST+=( "" )
        fi

        return 0
    }

    # <summary> Ask user to Select/Skip IOMMU group. </summary>
    function Select_IOMMU_Prompt
    {
        # <remarks> Append to list a valid array or empty value. </remarks>
        if "$_IOMMU_HAS_EXTERNAL_DOMAIN" && "$_SELECT_ALL_IOMMU"; then
            Select_IOMMU_Group
            return 0
        fi

        if "$_IOMMU_HAS_EXTERNAL_DOMAIN" && ! "$_SELECT_ALL_IOMMU" && Select_IOMMU_YesOrNo; then
            Select_IOMMU_Group
        fi

        if ! "$_IOMMU_HAS_EXTERNAL_DOMAIN"; then
            Skip_IOMMU_Group
        fi

        return 0
    }

    function Select_IOMMU_YesOrNo
    {
        if [[ "$_THIS_IOMMU" == "" ]]; then
            return 1
        fi

        for _TRIES_COUNT in $( seq 0 2 ); do
            read -r -p "Select IOMMU group '$_THIS_IOMMU'? [Y/n]: " _ANSWER

            case "$_ANSWER" in
                [Yy]* )
                    return 0 ;;

                [Nn]* )
                    return 1 ;;

                * )
                    echo "Please answer \"Y\" or \"N\"." ;;
            esac
        done

        echo -e "$_PREFIX_ERROR Failed to answer."
        return 1
    }

    # TODO: need to update here.
    function Set_IOMMU_Lists
    {
        # <remarks> Remove duplicate entries. </remarks>
        for _KEY in ${!_DRIVER_LIST_VFIOPCI[@]}; do
            local var_driver="${_DRIVER_LIST_VFIOPCI[$_KEY]}"

            if FindLineInArray "_DRIVER_LIST_VFIOPCI" "${var_driver}" &> /dev/null; then
                _DRIVER_LIST_VFIOPCI[_KEY]=""
            fi
        done

        # <remarks> Remove duplicate entries. </remarks>
        for _KEY in ${!_HWID_LIST_VFIOPCI[@]}; do
            local var_HWID="${_HWID_LIST_VFIOPCI[$_KEY]}"

            if FindLineInArray "_HWID_LIST_PCISTUB" "${var_HWID}" &> /dev/null || FindLineInArray "_HWID_LIST_VFIOPCI_WITH_VGA" "${var_HWID}" &> /dev/null; then
                _HWID_LIST_VFIOPCI[_KEY]=""
            fi
        done

        # <remarks> Remove duplicate entries. </remarks>
        for _KEY in ${!_HWID_LIST_PCISTUB[@]}; do
            local var_HWID="${_HWID_LIST_VFIOPCI[$_KEY]}"

            if FindLineInArray "_HWID_LIST_VFIOPCI_WITH_VGA" "${var_HWID}" &> /dev/null; then
                _HWID_LIST_PCISTUB[_KEY]=""
            fi
        done

        # TODO: need to update here.
        # NOTE: possibly breaking here, because I just revised the array functions (undeclared vars, should declare.)

        TrimArray "_DRIVER_LIST_VFIOPCI" || return "$?"
        TrimArray "_DRIVER_LIST_VFIOPCI_WITH_VGA" || return "$?"
        TrimArray "_HWID_LIST_PCISTUB" || return "$?"
        TrimArray "_HWID_LIST_VFIOPCI" || return "$?"
        TrimArray "_HWID_LIST_VFIOPCI_WITH_VGA" || return "$?"

        SortArray "_DRIVER_LIST_VFIOPCI"
        SortArray "_DRIVER_LIST_VFIOPCI_WITH_VGA"
        SortArray "_HWID_LIST_PCISTUB"
        SortArray "_HWID_LIST_VFIOPCI"
        SortArray "_HWID_LIST_VFIOPCI_WITH_VGA"

        PrintArray "_DRIVER_LIST_VFIOPCI"
        PrintArray "_DRIVER_LIST_VFIOPCI_WITH_VGA"
        PrintArray "_HWID_LIST_PCISTUB"
        PrintArray "_HWID_LIST_VFIOPCI"
        PrintArray "_HWID_LIST_VFIOPCI_WITH_VGA"

        exit 0
        return 0
    }

    function Skip_IOMMU_Group
    {
        _VFIOPCI_IOMMU_LIST+=( "" )
        _PCISTUB_IOMMU_LIST+=( "" )
        _VGA_VFIOPCI_IOMMU_LIST+=( "" )
        echo -e "Skipped IOMMU group '$_THIS_IOMMU'."
        return 0
    }

    # <summary> Select IOMMU groups for VFIO setup. </summary>
    function Select_IOMMU
    {
        local _OUTPUT="Reviewing IOMMU groups..."
        local _LAST_IOMMU_VALUE=$( basename $( ls -1v /sys/kernel/iommu_groups/ | sort -hr | head -n1 ) )
        local _GET_IOMMU='seq 0 "$_LAST_IOMMU_VALUE"'
        declare -a _THIS_IOMMU_LIST=( $( eval "$_GET_IOMMU" ) )

        for _THIS_IOMMU in ${_THIS_IOMMU_LIST[@]}; do
            local _IOMMU_HAS_EXTERNAL_DOMAIN=false
            local bool_IOMMU_PCISTUB=false
            # local bool_IOMMU_VFIOPCI=false
            local bool_IOMMU_has_USB=false
            local bool_IOMMU_has_VGA=false

            for _KEY in ${!_IOMMU_LIST[@]}; do
                local -i _IOMMU="${_IOMMU_LIST[$_KEY]}"
                Select_IOMMU_Match_IOMMU_AndClass
            done

            Select_IOMMU_Prompt
        done

        # <remarks> Check if list is empty </remarks>
        if [[ "${#_VFIOPCI_IOMMU_LIST[@]}" -eq 0 ]] \
            || ! "$bool_VFIO_has_IOMMU" \
            || ! Get_IOMMU_Lists \
            || ! Set_IOMMU_Lists; then
            false
        fi

        PrintPassOrFail "Reviewing IOMMU groups..."
        return "$_LAST_EXIT_CODE"
    }
# </code>