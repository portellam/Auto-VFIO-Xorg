#!/usr/bin/env bash

exit 0

# todo: debug

#
# Original author(s):   Rokas Kupstys <rokups@zoho.com>
#                       Danny Lin <danny@kdrag0n.dev>
# Current author(s):    Alex Portell <github.com/portellam>
#
# This hook uses the `cset` tool to dynamically isolate and unisolate CPUs using
# the kernel's cgroup cpusets feature. While it's not as effective as
# full kernel-level scheduler and timekeeping isolation, it still does wonders
# for VM latency as compared to not isolating CPUs at all. Note that vCPU thread
# affinity is a must for this to work properly.
#
# Original source(s):   https://rokups.github.io/#!pages/gaming-vm-performance.md
#                       https://github.com/PassthroughPOST/VFIO-Tools/blob/master/libvirt_hooks/hooks/cset.sh
#
# Target file locations:
#   - $SYSCONFDIR/hooks/qemu.d/vm_name/prepare/begin/cset.sh
#   - $SYSCONFDIR/hooks/qemu.d/vm_name/release/end/cset.sh
# $SYSCONFDIR is usually /etc/libvirt.
#

# parse CPU #
    # parameters #
    str_object="$1"
    str_operation="$2"
    str_subOperation="$3"
    str_objectAction="$2/$3"
    str_extraArg="$4"
    readonly arr_coresByThread=(`cat /proc/cpuinfo | grep 'core id' | cut -d ':' -f2 | cut -d ' ' -f2`)
    readonly int_totalCores=`cat /proc/cpuinfo | grep 'cpu cores' | uniq | cut -d ':' -f2 | cut -d ' ' -f2`
    readonly int_totalThreads=`cat /proc/cpuinfo | grep 'siblings' | uniq | cut -d ':' -f2 | cut -d ' ' -f2`
    readonly int_multiThread=$(( $int_totalThreads / $int_totalCores ))
    readonly int_lastThread=$((int_totalThreads--))
    readonly str_totalThreads="0-${int_lastThread}"
    declare -a arr_hostCores=()
    declare -a arr_hostThreads=()
    declare -a arr_hostThreadSets=()
    declare -a arr_totalCores=()
    # declare -a arr_virtCores=()
    declare -a arr_virtThreadSets=()
    declare -i int_hostCores=1          # default value
    declare - i int_totalThreads

    # reserve remainder cores to host #
    # >= 4-core CPU, leave max 2
    if [[ $int_totalCores -ge 4 ]]; then
        readonly int_hostCores=2

    # 2 or 3-core CPU, leave max 1
    elif [[ $int_totalCores -le 3 && $int_totalCores -ge 2 ]]; then
        readonly int_hostCores=1

    # 1-core CPU, do not reserve cores to virt
    else
        readonly int_hostCores=$int_totalCores
    fi

    # group threads for host #
    for (( int_count=0 ; int_count<$int_multiThread ; int_count++ )); do
        declare -i int_firstHostCore=$int_hostCores
        declare -i int_firstHostThread=$((int_hostCores+int_totalCores*int_count))
        declare -i int_lastHostCore=$((int_totalCores-1))
        declare -i int_lastHostThread=$((int_lastHostCore+int_totalCores*int_count))
        str_virtThreads+="${int_firstHostThread}-${int_lastHostThread},"
    done

    # update parameters #
    if [[ ${str_virtThreads: -1} == "," ]]; then
        str_virtThreads=${str_virtThreads::-1}
    fi

    # group threads by core id #
    for (( int_i=0 ; int_i<$int_totalCores ; int_i++ )); do

        # parameters #
        str_line1=""
        declare -i int_thisCore=${arr_coresByThread[int_i]}

        for (( int_count=0 ; int_count<$int_multiThread ; int_count++ )); do

            # parameters #
            int_thisThread=$((int_thisCore+int_totalCores*int_count))
            str_line1+="$int_thisThread,"

            if [[ $int_thisCore -lt $int_hostCores ]]; then
                arr_hostThreads+=("$int_thisThread")
            fi
        done

        # update parameters #
        if [[ ${str_line1: -1} == "," ]]; then
            str_line1=${str_line1::-1}
        fi

        arr_totalThreads+=("$str_line1")

        # save output for cpu isolation (host) #
        if [[ $int_thisCore -lt $int_hostCores ]]; then
            arr_hostCores+=("$int_thisCore")
            arr_hostThreadSets+=("$str_line1")

        # save output for cpuset/cpumask (qemu cpu pinning) #
        else
            # arr_virtCores+=("$int_thisCore")
            arr_virtThreadSets+=("$str_line1")
        fi
    done

    # update parameters #
    readonly arr_totalThreads
    readonly arr_hostCores
    readonly arr_hostThreadSets
    readonly arr_virtThreadSets

    # save output to string for cpuset and cpumask #
    #
    # example:
    #
    # host 0-1,8-9
    #
    # virt 2-7,10-15
    #
    #
    # cores     bit masks       mask
    # 0-7       0b11111111      FF      # total cores
    # 0,4       0b00010001      11      # host cores
    #
    # 0-11      0b111111111111  FFF     # total cores
    # 0-1,6-7   0b000011000011  C3      # host cores
    #
    # find cpu mask #
    readonly int_totalThreads_mask=$(( ( 2 ** $int_totalThreads ) - 1 ))
    declare -i int_hostThreads_mask=0

    for int_thisThread in ${arr_hostThreads[@]}; do
        int_hostThreads_mask+=$(( 2 ** $int_thisThread ))
    done

    readonly int_hostThreads_mask

    # int to hex #
    readonly hex_totalThreads_mask=`printf '%x\n' $int_totalThreads_mask`
    readonly hex_hostThreads_mask=`printf '%x\n' $int_hostThreads_mask`

# main #
    # functions #
    function shield_vm() {
        cset -m set -c $str_totalThreads -s machine.slice
        cset -m shield --kthread on --cpu $str_virtThreads
    }

    function unshield_vm() {
        cset -m shield --reset
    }

    # For convenient manual invocation #
    if [[ "$str_object" == "shield" ]]; then
        shield_vm
        exit
    elif [[ "$str_object" == "unshield" ]]; then
        unshield_vm
        exit
    fi

    # allocate/release threads to host after VM start/stop #
    case "$str_operation" in
            # allocate #
            "prepare")
                    systemctl set-property --runtime -- user.slice AllowedCPUs=$str_hostThreads
                    systemctl set-property --runtime -- system.slice AllowedCPUs=$str_hostThreads
                    systemctl set-property --runtime -- init.scope AllowedCPUs=$str_hostThreads
                    ;;
            # release #
            "release")
                    systemctl set-property --runtime -- user.slice AllowedCPUs=0-$int_totalThreads
                    systemctl set-property --runtime -- system.slice AllowedCPUs=0-$int_totalThreads
                    systemctl set-property --runtime -- init.scope AllowedCPUs=0-$int_totalThreads
                    ;;
    esac

    if [[ "$str_objectAction" == "prepare/begin" ]]; then
        echo "libvirt-qemu cset: Reserving CPUs $str_virtThreads for VM $str_object" > /dev/kmsg 2>&1
        shield_vm > /dev/kmsg 2>&1

        # the kernel's dirty page writeback mechanism uses kthread workers. They introduce
        # massive arbitrary latencies when doing disk writes on the host and aren't
        # migrated by cset. Restrict the workqueue to use only cpu 0.
        echo $hex_hostThreads_mask > /sys/bus/workqueue/devices/writeback/cpumask
        echo 0 > /sys/bus/workqueue/devices/writeback/numa

        echo "libvirt-qemu cset: Successfully reserved CPUs $str_virtThreads" > /dev/kmsg 2>&1
    elif [[ "$str_objectAction" == "release/end" ]]; then
        echo "libvirt-qemu cset: Releasing CPUs $str_virtThreads from VM $str_object" > /dev/kmsg 2>&1
        unshield_vm > /dev/kmsg 2>&1

        # Revert changes made to the writeback workqueue
        echo $hex_totalThreads_mask > /sys/bus/workqueue/devices/writeback/cpumask
        echo 1 > /sys/bus/workqueue/devices/writeback/numa

        echo "libvirt-qemu cset: Successfully released CPUs $str_virtThreads" > /dev/kmsg 2>&1
    fi