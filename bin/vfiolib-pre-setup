#!/bin/false

#
# Filename:         vfiolib-pre-setup
# Description:      Recommended pre-installation setups.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <sources>
    source vfiolib-common
    source vfiolib-checks
    source vfiolib-files
    source vfiolib-parse
# </sources>

# <functions>
    # <summary> Public </summary>
        function ExecutePreSetup
        {
            function Main
            {
                while [[ "${?}" -ne 1 ]]; do
                    AddUserToGroups

                    if "${_ASK_TO_EXECUTE_PRE_SETUP_ALL}"; then
                        ExecuteHugepagesSetup
                        ExecuteStaticCPUIsolation
                        ExecuteVirtualKVMSetup
                        ExecuteModifyQEMUConfiguration
                        break
                    fi

                    if "${_EXECUTE_PRE_SETUP_HUGEPAGES}"; then
                        ExecuteHugepagesSetup
                    fi

                    if "${_EXECUTE_PRE_SETUP_STATIC_ISOLCPU}"; then
                        ExecuteStaticCPUIsolation
                    fi

                    if "${_EXECUTE_PRE_SETUP_EVDEV}"; then
                        ExecuteVirtualKVMSetup
                    fi

                    ExecuteModifyQEMUConfiguration
                    break
                done

                return "${?}"
            }

            local OUTPUT="Executing pre-setup...\t"
            PrintSuffixWait "${OUTPUT}"
            Main
            PrintSuffixPassOrFail "${OUTPUT}"
            return "${?}"
        }

        # <summary> Global setters </summary>
        function SetParameters
        {
            if [[ ! -z "${_ARE_PRE_SETUP_PARAMS_SET}" ]] \
                && "${_ARE_PRE_SETUP_PARAMS_SET}"; then
                return 0
            fi

            declare -g _ARE_PRE_SETUP_PARAMS_SET=true

            # <remarks> Hugepages </remarks>
            declare -gi _HUGEPAGES_ALLOCATED_MEMORY=0
            declare -gi _HUGEPAGES_COUNT=0
            declare -gi _HUGEPAGES_MAX_SIZE=0
            declare -gi _HUGEPAGES_MAX_SIZE_IN_KBIT=$( cat /proc/meminfo | grep MemTotal | cut -d ":" -f 2 | cut -d "k" -f 1 )
            declare -gi _HUGEPAGES_MIN_SIZE=0
            declare -gi _HUGEPAGES_MIN_SIZE_IN_KBIT=4194304
            declare -gi _HUGEPAGES_SIZE_IN_KBIT=0
            declare -gu _HUGEPAGES_BYTE_SUFFIX=""

            # <remarks> Execution flags </remarks>
            declare -g _IS_EVDEV_SETUP=false
            declare -g _IS_HUGEPAGES_SETUP=false
        }

    # <summary> Private </summary>
        # <summary>
        # Hugepages: Allocate host memory (RAM) to 'hugepages'.
        # Eliminate the need to defragement memory, reduce host overhead, and improve both host and guest performance.
        # </summary
            function ExecuteHugepagesSetup
            {
                function AskForHugepageByteSize
                {
                    if "${_IS_HUGEPAGES_SIZE_SET}"; then
                        return 0
                    fi

                    for COUNT in $( seq 0 2 ); do
                        read -r -p "Enter size of Hugepages [2M/1G]: " _HUGEPAGES_BYTE_SUFFIX
                        GetHugepageByteSize "${_HUGEPAGES_BYTE_SUFFIX}" && return 0
                    done

                    echo -e "${_OUTPUT_INVALID_ANSWER}"
                    return 1
                }

                function AskForHugepageCount
                {

                    if "${_IS_HUGEPAGES_COUNT_SET}"; then
                        return 0
                    fi

                    for COUNT in $( seq 0 2 ); do
                        read -r -p "Enter count of Hugepages [${_HUGEPAGES_MIN_SIZE}-${_HUGEPAGES_MAX_SIZE}]: " _HUGEPAGES_COUNT
                        GetHugepageCount "${_HUGEPAGES_COUNT}" && return 0
                    done

                    echo -e "${_OUTPUT_INVALID_ANSWER}"
                    return 1
                }

                function Main
                {
                    if ! "${_EXECUTE_PRE_SETUP_HUGEPAGES}"; then
                        echo
                    fi

                    _IS_HUGEPAGES_SETUP=false

                    if ! [[ "${_INT_MAX_MEMORY}" =~ ^[0-9]+$ ]]; then
                        echo -e "${_PREFIX_ERROR} Could not parse system memory."
                        return 1
                    fi

                    if ! "${_EXECUTE_PRE_SETUP_HUGEPAGES}"; then
                        if ! "${_IS_QUIET}"; then
                            echo -e "Hugepages is a feature which statically allocates system memory to pagefiles.\nGuest(s) can use Hugepages to a peformance benefit.\nThe greater the Hugepage size, the less fragmentation of memory, and the less latency/overhead of system memory-access.\n${_SET_COLOR_YELLOW}NOTE:${_RESET_COLOR} It is recommended to use a size which is a multiple of an individual memory channel/stick.\n${_SET_COLOR_YELLOW}Example:${_RESET_COLOR} Four (4) channels of 8 GB each, use 1x, 2x, or 3x (8 GB, 16 GB, or 24 GB).\n"
                        fi

                        AskToExecuteOrSkip "Setup Hugepages?" || return "${?}"
                    fi

                    if ! "${_IS_HUGEPAGES_SIZE_SET}"; then
                        AskForHugepageByteSize || return 1
                    fi

                    GetHugepageMinAndMaxSizes || return 1

                    if ! "${_IS_HUGEPAGES_COUNT_SET}"; then
                        AskForHugepageCount || return 1
                    fi

                    GetMemoryAllocatedToHugepages || return 1
                    IsHostMemorySufficientForHugepages || return 1
                    declare -g _OUTPUT_GRUB_CMDLINE_HUGEPAGES="default_hugepagesz=${_HUGEPAGES_BYTE_SUFFIX} hugepagesz=${_HUGEPAGES_BYTE_SUFFIX} hugepages=${_HUGEPAGES_COUNT}"
                    _IS_HUGEPAGES_SETUP=true
                    return 0
                }

                Main
                PrintSuffixPassOrFail "Allocating RAM to pages..."
                return "${_LAST_EXIT_CODE}"
            }

            function GetMemoryAllocatedToHugepages
            {
                _HUGEPAGES_ALLOCATED_MEMORY=$(( ${_HUGEPAGES_COUNT} * ${_HUGEPAGES_SIZE_IN_KBIT} ))
                return 0
            }

            function GetHugepageByteSize
            {
                local -u ANSWER="${1}"

                case "${ANSWER}" in
                    "1G" | "2M" )
                        _HUGEPAGES_BYTE_SUFFIX="${ANSWER}"
                        _IS_HUGEPAGES_SIZE_SET=true
                        return 0 ;;

                    * )
                        echo -e "Please a enter valid Hugepages size, '2M' or '1G'."
                        return 1 ;;
                esac
            }

            function GetHugepageCount
            {
                if [[ -z "${1}" ]]; then
                    echo -e "${_PREFIX_ERROR} Hugepage count is empty."
                    return 1
                fi

                GetHugepageMinAndMaxSizes || return 1

                if ! IsInt "${1}" \
                    || [[ "${1}" -lt "${_HUGEPAGES_MIN_SIZE}" ]] \
                    || [[ "${1}" -gt "${_HUGEPAGES_MAX_SIZE}" ]]; then
                    echo -e "${_PREFIX_ERROR} Please enter a valid Hugepages amount, between ${_HUGEPAGES_MIN_SIZE} or ${_HUGEPAGES_MAX_SIZE}."
                    return 1
                fi

                _IS_HUGEPAGES_COUNT_SET=true
                _HUGEPAGES_COUNT="${1}"
                return 0
            }

            function GetHugepageMinAndMaxSizes
            {
                case "${_HUGEPAGES_BYTE_SUFFIX}" in
                    "2M" )
                        _HUGEPAGES_SIZE_IN_KBIT=2048
                        _HUGEPAGES_MIN_SIZE=2 ;;

                    "1G" )
                        _HUGEPAGES_SIZE_IN_KBIT=1048576
                        _HUGEPAGES_MIN_SIZE=1 ;;

                    * )
                        echo -e "${_PREFIX_ERROR} Failed to calculate minimum or maximum values for Hugepages."
                        return 1 ;;
                esac

                _HUGEPAGES_MAX_SIZE=$(( "${_HUGEPAGES_MAX_SIZE}_IN_KBIT" - "${_HUGEPAGES_MIN_SIZE_IN_KBIT}" ))
                _HUGEPAGES_MAX_SIZE=$(( "${_HUGEPAGES_MAX_SIZE}" / "${_HUGEPAGES_SIZE_IN_KBIT}" ))
                return 0
            }


            function IsHostMemorySufficientForHugepages
            {
                if ! GetFreeMemory; then
                    echo -e "${_PREFIX_ERROR} Insufficient Host memory for Hugepages."
                    return 1
                fi

                return 0
            }


        # <summary>
        # Add user to necessary user groups.
        # </summary>
        function AddUserToGroups
        {
            if ! sudo adduser "${_USER}" "input" &> /dev/null \
                || ! sudo adduser "${_USER}" "libvirt" &> /dev/null; then
                echo -e "${_PREFIX_ERROR} Failed to add user '${_USER}' to groups."
                return 1
            fi

            return 0
        }

        # <summary>
        # isolcpus: Allocate host CPU cores (and/or threads), to reduce host overhead, and improve both host and guest performance.
        # </summary
        function ExecuteStaticCPUIsolation
        {
            function GetThreadByCoreAndSMT
            {
                _THREAD=$(( CORE + ( SMT_FACTOR * TOTAL_CORES_COUNT ) ))             # NOTE: VS Code reports a syntax error here. There is none.
            }

            function GetThreadSetsForHostAndGuest
            {
                for SMT_FACTOR in ${SMT_FACTOR_LIST[@]}; do
                    declare -a HOST_THREADS_DELIM_LIST=( )
                    declare -a GUEST_THREADS_DELIM_LIST=( )
                    local -i THREAD

                    # <remarks> Find thread sets for host. </remarks>
                    for CORE in ${HOST_CORES_LIST[@]}; do
                        GetThreadByCoreAndSMT
                        HOST_THREADS_LIST+=( "${THREAD}" )
                        HOST_THREADS_DELIM_LIST+=( "${THREAD}" )
                    done

                    # <remarks> Find thread sets for guest(s). </remarks>
                    for CORE in ${GUEST_CORES_LIST[@]}; do
                        GetThreadByCoreAndSMT
                        GUEST_THREADS_LIST+=( "${THREAD}" )
                        GUEST_THREADS_DELIM_LIST+=( "${THREAD}" )
                    done

                    # <remarks> Save thread sets to delimited list. </remarks>
                    local -i _FIRST_THREAD_SET="${HOST_THREADS_DELIM_LIST[0]}"
                    local -i _LAST_THREAD_SET="${HOST_THREADS_DELIM_LIST[-1]}"
                    local THREAD_SET="${_FIRST_THREAD_SET}"

                    if [[ "${_FIRST_THREAD_SET}" -ne "${_LAST_THREAD_SET}" ]]; then
                        local THREAD_SET="${_FIRST_THREAD_SET}-${_LAST_THREAD_SET}"
                    fi

                    HOST_THREADS_DELIM+="${THREAD_SET},"

                    local -i _FIRST_THREAD_SET="${GUEST_THREADS_DELIM_LIST[0]}"
                    local -i _LAST_THREAD_SET="${GUEST_THREADS_DELIM_LIST[-1]}"
                    local THREAD_SET="${_FIRST_THREAD_SET}"

                    if [[ "${_FIRST_THREAD_SET}" -ne "${_LAST_THREAD_SET}" ]]; then
                        local THREAD_SET="${_FIRST_THREAD_SET}-${_LAST_THREAD_SET}"
                    fi

                    GUEST_THREADS_DELIM+="${THREAD_SET},"
                done

                return 0
            }

            function Main
            {
                local -i CORES_ALLOCATED_TO_HOST=1
                local -i TOTAL_CORES_COUNT=$( cat /proc/cpuinfo | grep "cpu cores" | uniq | grep -o "[0-9]\+" )
                local -i TOTAL_THREADS_COUNT=$( cat /proc/cpuinfo | grep "siblings" | uniq | grep -o "[0-9]\+" )

                # <remarks> Set maximum number of cores allocated to host. </remarks>
                if [[ "${TOTAL_CORES_COUNT}" -ge 4 ]]; then
                    CORES_ALLOCATED_TO_HOST=2

                elif [[ "${TOTAL_CORES_COUNT}" -le 3 ]] \
                    && [[ "${TOTAL_CORES_COUNT}" -ge 2 ]]; then
                    CORES_ALLOCATED_TO_HOST=1

                else
                    echo -e "$PREFIX_ERROR Insufficient CPU cores."
                    return 1
                fi

                # <remarks> Get thread sets, for host and guest(s). </remarks>
                local -a HOST_CORES_LIST=( $( seq 0 $(( "${CORES_ALLOCATED_TO_HOST}" - 1 )) ) )
                local -a HOST_THREADS_LIST=( )
                local -a GUEST_CORES_LIST=( $( seq "${CORES_ALLOCATED_TO_HOST}" $(( "${TOTAL_CORES_COUNT}" - 1 )) ) )
                local -a GUEST_THREADS_LIST=( )
                local -i SMT_FACTOR=$(( "${TOTAL_THREADS_COUNT}" / "${TOTAL_CORES_COUNT}" ))
                local -a SMT_FACTOR_LIST=( $( seq 0 $(( "${SMT_FACTOR}" - 1 )) ) )
                local HOST_THREADS_DELIM=""
                local GUEST_THREADS_DELIM=""
                GetThreadSetsForHostAndGuest

                # <remarks> Truncate last delimiter. </remarks>
                if [[ ${HOST_THREADS_DELIM: -1} == "," ]]; then
                    HOST_THREADS_DELIM="${HOST_THREADS_DELIM::-1}"
                fi

                if [[ ${GUEST_THREADS_DELIM: -1} == "," ]]; then
                    GUEST_THREADS_DELIM="${GUEST_THREADS_DELIM::-1}"
                fi

                # <remarks>
                # save output to string for cpuset and cpumask
                # example:
                #   host 0-1,8-9
                #   virt 2-7,10-15
                #
                # information
                # cores     bit masks       mask
                # 0-7       0b11111111      FF      # total cores
                # 0,4       0b00010001      11      # host cores
                #
                # 0-11      0b111111111111  FFF     # total cores
                # 0-1,6-7   0b000011000011  C3      # host cores
                #
                # </remarks>

                # <remarks> Find CPU mask. </remarks>
                local -r GET_HEX_MASK='echo "obase=16; ${THREAD}_DECIMAL" | bc'
                local -i HOST_THREADS_HEX_MASK=0
                local -i TOTAL_THREADS_HEX_MASK=0

                # <remarks> Add each decimal mask to sum. </remarks>
                for THREAD in ${HOST_THREADS_LIST[@]}; do
                    local -i THREAD_DECIMAL=$(( 2 ** ${THREAD} ))
                    local -i THREAD_HEX_MASK=$( eval "${GET_HEX_MASK}" )
                    HOST_THREADS_HEX_MASK+="${THREAD_HEX_MASK}"
                done

                # <remarks> Convert hexadecimal mask into hexadecimal. </remarks>
                declare -g HOST_THREADS_HEX=$( printf '%x\n' "${HOST_THREADS_HEX_MASK}" )
                local -i TOTAL_THREADS_HEX_MASK=$(( ( 2 ** ${TOTAL_THREADS_COUNT} ) - 1 ))
                declare -g GUEST_THREADS_HEX=$( printf '%x\n' "${TOTAL_THREADS_HEX_MASK}" )

                echo -e "Allocated to Host:\t${HOST_THREADS_DELIM}"
                echo -e "Allocated to Guest:\t${GUEST_THREADS_DELIM}"

                # <remarks> Save changes. </remarks>
                declare -g LINE_GRUB_CMDLINE_ISOLCPU="isolcpus=${GUEST_THREADS_DELIM} nohz_full=${GUEST_THREADS_DELIM} rcu_nocbs=${GUEST_THREADS_DELIM}"
                return 0
            }

            if ! "${_EXECUTE_PRE_SETUP_STATIC_ISOLCPU}"; then
                echo

                if AskToExecuteOrSkip "Statically allocate CPU threads to Guest(s)?"; then
                    Main
                fi
            fi

            PrintSuffixPassOrFail "Allocating CPU threads..." && _HAS_EXECUTED_PRE_SETUP_STATIC_ISOLCPU=true
            return "${_LAST_EXIT_CODE}"
        }

        # <summary>
        # libvirt-qemu: Append necessary changes to QEMU system file, including user groups, Evdev, Hugepages, and NVRAM (for UEFI guest(s)).
        # </summary>
        function ExecuteModifyQEMUConfiguration
        {
            function Main
            {
                local -a FILE_1_CONTENTS=( )
                local -a FILE_1_CONTENTS_EVDEV_CGROUPS=( )
                local -a FILE_2_CONTENTS=( )
                local -a FILE_1_CONTENTS_DEFAULT_CGROUPS=(
                    "        \"/dev/null\", \"/dev/full\", \"/dev/zero\","
                    "        \"/dev/random\", \"/dev/urandom\","
                    "        \"/dev/ptmx\", \"/dev/kvm\","
                    "        \"/dev/rtc\", \"/dev/hpet\""
                )
                # <remarks> Format input for Evdev. </remarks>
                if "${_IS_EVDEV_SETUP}"; then
                    for DEVICE in ${_EVENT_DEVICES_LIST[@]}; do
                        FILE_1_CONTENTS_EVDEV_CGROUPS+=( "        \"/dev/input/by-id/${DEVICE}\"," )
                    done

                    for DEVICE in ${_INPUT_DEVICES_LIST[@]}; do
                        FILE_1_CONTENTS_EVDEV_CGROUPS+=( "        \"/dev/input/by-id/${DEVICE}\"," )
                    done
                fi

                # <remarks> Preface file contents. </remarks>
                FILE_1_CONTENTS=( "${_DISCLAIMER_FILE_CONTENTS[@]}" )
                FILE_2_CONTENTS=( "${_DISCLAIMER_FILE_CONTENTS[@]}" )
                FILE_1_CONTENTS+=(
                    ""
                    "### User permissions ###"
                )

                # <remarks> Add user and group for Evdev. </remarks>
                if "${_IS_EVDEV_SETUP}"; then
                    FILE_1_CONTENTS+=(
                        "user = \"${_USER}\""
                        "group = \"user\""
                    )
                else
                    FILE_1_CONTENTS+=(
                        "#user = \"user\""
                        "#group = \"user\""
                    )

                    false
                fi

                # <remarks> Hugepages </remarks>
                FILE_1_CONTENTS+=(
                    ""
                    "### Hugepages ###"
                )

                if "${_IS_HUGEPAGES_SETUP}"; then
                    FILE_1_CONTENTS+=(
                        "hugetlbfs_mount = \"/dev/hugepages\""
                    )

                    FILE_2_CONTENTS+=(
                        ""
                        "# Hugepages"
                        "/dev/hugepages rw,"
                    )
                else
                    FILE_1_CONTENTS+=(
                        "#hugetlbfs_mount = \"/dev/hugepages\""
                    )

                    false
                fi

                # <remarks> Add cgroups for Evdev. </remarks>
                FILE_1_CONTENTS+=(
                    ""
                    "### Devices ###"
                    "cgroup_device_acl = ["
                )

                if ${_IS_EVDEV_SETUP}; then
                    FILE_1_CONTENTS+=(
                        "${FILE_1_CONTENTS_EVDEV_CGROUPS[@]}"
                        "${FILE_1_CONTENTS_DEFAULT_CGROUPS[@]}"
                        "]"
                    )

                    FILE_2_CONTENTS+=(
                        ""
                        "# Evdev"
                        "/dev/input/* rw,"
                        "/dev/input/by-id/* rw,"
                    )
                else
                    FILE_1_CONTENTS+=(
                        "${FILE_1_CONTENTS_DEFAULT_CGROUPS[@]}"
                        "]"
                    )

                    false
                fi

                # <remarks> Adds NVRAM for EFI kernels in UEFI guest(s). </remarks>
                FILE_1_CONTENTS+=(
                    ""
                    "nvram = ["
                    "        \"/usr/share/OVMF/OVMF_CODE.fd:/usr/share/OVMF/OVMF_VARS.fd\","
                    "        \"/usr/share/OVMF/OVMF_CODE.secboot.fd:/usr/share/OVMF/OVMF_VARS.fd\","
                    "        \"/usr/share/AAVMF/AAVMF_CODE.fd:/usr/share/AAVMF/AAVMF_VARS.fd\","
                    "        \"/usr/share/AAVMF/AAVMF32_CODE.fd:/usr/share/AAVMF/AAVMF32_VARS.fd\""
                    "]"
                )

                # <remarks> Append changes to file(s). </remarks>
                if ! sudo echo -e "${FILE_1_CONTENTS[*]}" >> "${_QEMU_DEST_PATH}"; then
                    echo -e "${_PREFIX_ERROR} Failed to write to file '${_QEMU_DEST_PATH}'."
                fi

                if ! sudo echo -e "${FILE_2_CONTENTS[*]}" >> "${_APPARMOR_QEMU_DEST_PATH}"; then
                    echo -e "${_PREFIX_ERROR} Failed to write to file '${_APPARMOR_QEMU_DEST_PATH}'."
                fi

                return 0
            }

            IFS=$'\n'
            Main
            unset IFS
            PrintSuffixPassOrFail "Appending Libvirt file..."
            return "${_LAST_EXIT_CODE}"
        }

        # <summary>
        # Evdev: Setup a virtual Keyboard-Video-Mouse switch (excluding the Video).
        # Will allow a user to swap between active guest(s) and host, with the use of a pre-defined macro (example: 'L-CTRL' + 'R-CTRL').
        # </summary>
        function ExecuteVirtualKVMSetup
        {
            function Main
            {
                declare -ga _EVENT_DEVICES_LIST=( $( ls -l /dev/input/by-id | cut -d "/" -f2 | grep -v "total 0" ) )
                declare -ga _INPUT_DEVICES_LIST=( $( ls /dev/input/by-id ) )

                if [[ "${#_EVENT_DEVICES_LIST[@]}" -eq 0 ]] \
                    ||[[ "${#_INPUT_DEVICES_LIST[@]}" -eq 0 ]]; then
                    _IS_EVDEV_SETUP=false
                    echo -e "${_PREFIX_ERROR} Cannot parse input devices."
                    return 1
                fi

                _IS_EVDEV_SETUP=true
                return 0
            }

            if ! "${_EXECUTE_PRE_SETUP_EVDEV}"; then
                echo

                if ! "${_IS_QUIET}"; then
                    echo -e "Evdev (Event Devices) is a method of creating a virtual KVM (Keyboard-Video-Mouse) switch between Host and Guest(s).\n${_SET_COLOR_YELLOW}HOW-TO:${_RESET_COLOR} Press 'L-CTRL' and 'R-CTRL' simultaneously.\n"
                fi

                AskToExecuteOrSkip "Setup Evdev?" || return "${?}"
            fi

            Main
            PrintSuffixPassOrFail "Executing Evdev setup..."
            return "${_LAST_EXIT_CODE}"
        }
# </functions>

# <main>
    SetParameters
# </main>