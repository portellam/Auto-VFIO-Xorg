#!/bin/false

#
# Filename:       deploy-vfio_logic_pre-setup
# Description:    Recommended pre-installation setups.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

# <sets>
  set -o nounset
  set -o pipefail
# </sets>

# <sources>
  source deploy-vfio_logic_common
# </sources>

# <functions>
  function declare_parameters
  {
    if [[ "${PRE_SETUP_ARE_PARAMS_SET}" == true ]]; then
      return 0
    fi

    declare -g PRE_SETUP_ARE_PARAMS_SET=true

    declare -g PRE_SETUP_ASK_TO_EXECUTE_ALL=true
    declare -g PRE_SETUP_DO_EXECUTE_EVDEV=false
    declare -g PRE_SETUP_DO_EXECUTE_HUGEPAGES=false
    declare -g PRE_SETUP_DO_EXECUTE_ISOLCPU=false
    declare -g PRE_SETUP_DO_SKIP_ALL=false

    # <summary>Evdev</summary>
      declare -ga EVENT_DEVICES_ENUM=( )
      declare -ga INPUT_DEVICES_ENUM=( )

    # <summary>Hugepages</summary>
      declare -gi HUGEPAGES_ALLOCATED_MEMORY=0
      declare -gi HUGEPAGES_COUNT=$( cat /proc/meminfo | grep -i hugepagesize | cut -d ':' -f 2 | awk 'END {print $1}' )
      declare -gi HUGEPAGES_MAX_COUNT=0
      declare -gi HUGEPAGES_MAX_SIZE_IN_KIB=$( cat /proc/meminfo | grep MemTotal | cut -d ":" -f 2 | awk 'END {print $1}' )
      declare -gi HUGEPAGES_MIN_COUNT=0
      declare -gi HUGEPAGES_MIN_SIZE_IN_KIB=$(( 4 * ${_1_GIB_IN_KIB} ))
      declare -gi HUGEPAGES_SIZE_IN_KIB=$( cat /proc/meminfo | grep -i hugepages_total | cut -d ':' -f 2 | awk 'END {print $1}' )
      declare -gu HUGEPAGES_BYTE_SUFFIX=""
      declare -g IS_HUGEPAGES_COUNT_SET=false
      declare -g IS_HUGEPAGES_SIZE_SET=false
      declare -g LINE_GRUB_CMDLINE_HUGEPAGES=""

    # <summary>Isolcpus</summary>
      declare -g _LINE_GRUB_CMDLINE_ISOLCPU=""
  }

  function do_pre_setup
  {
    do_skip_pre_setup || return 0
    execute_static_isolcpu_setup || return 1
    execute_virtual_kvm_setup || return 1
    execute_hugepages_setup || return 1
    execute_qemu_configuration || return 1
  }

  function do_skip_pre_setup
  {
    execute_or_skip_prompt "Skip preliminary setup?"
  }

  # <summary>Execution</summary>
    # <summary>
    # Add user to necessary user groups.
    # </summary>
      function add_user_to_groups_for_pre_setup
      {
        if ! sudo adduser "${_USER}" "input" &> /dev/null \
          || ! sudo adduser "${_USER}" "libvirt" &> /dev/null; then
          echo -e "${_PREFIX_ERROR} Failed to add user '${_USER}' to groups."
          return 1
        fi

        return 0
      }

    # <summary>
    # isolcpus: Allocate host CPU cores (and/or threads), to reduce host overhead, and improve both host and guest performance.
    # </summary
      function execute_static_isolcpu_setup
      {
        function set_thread_pair_enums
        {
          for smt_factor in ${smt_factor_enum[@]}; do
            local -a host_threads_delimited_enum=( )
            local -a guest_threads_delimited_enum=( )
            local -i thread

            # <remarks>Find thread sets for host.</remarks>
            for core in ${host_cores_enum[@]}; do
              set_thread_by_core_and_smt_factor "thread" "core" "smt_factor" "total_cores_count"
              host_threads_enum+=( "${THREAD}" )
              host_threads_delimited_enum+=( "${THREAD}" )
            done

            # <remarks>Find thread sets for guest(s).</remarks>
            for CORE in ${GUEST_CORES_ENUM[@]}; do
              set_thread_by_core_and_smt_factor "THREAD"
              GUEST_THREADS_ENUM+=( "${THREAD}" )
              guest_threads_delimited_enum+=( "${THREAD}" )
            done

            # <remarks>Save thread sets to delimited list.</remarks>
            local -i FIRST_THREAD_SET="${host_threads_delimited_enum[0]}"
            local -i LAST_THREAD_SET="${host_threads_delimited_enum[-1]}"
            local THREAD_SET="${FIRST_THREAD_SET}"

            if [[ "${FIRST_THREAD_SET}" -ne "${LAST_THREAD_SET}" ]]; then
              local THREAD_SET="${FIRST_THREAD_SET}-${LAST_THREAD_SET}"
            fi

            HOST_THREADS_DELIM+="${THREAD_SET},"

            local -i FIRST_THREAD_SET="${guest_threads_delimited_enum[0]}"
            local -i LAST_THREAD_SET="${guest_threads_delimited_enum[-1]}"
            local THREAD_SET="${FIRST_THREAD_SET}"

            if [[ "${FIRST_THREAD_SET}" -ne "${LAST_THREAD_SET}" ]]; then
              local THREAD_SET="${FIRST_THREAD_SET}-${LAST_THREAD_SET}"
            fi

            GUEST_THREADS_DELIM+="${THREAD_SET},"
          done

          return 0
        }

        function Main
        {
          Ask

          if ! "${PRE_SETUP_DO_EXECUTE_ISOLCPU}"; then
            return 0
          fi

          local -i cores_allocated_to_host=1
          local -i total_cores_count=$( cat /proc/cpuinfo | grep "cpu cores" | uniq | grep -o "[0-9]\+" )
          local -i total_threads_count=$( cat /proc/cpuinfo | grep "siblings" | uniq | grep -o "[0-9]\+" )

          # <remarks>Set maximum number of cores allocated to host.</remarks>
          if [[ "${total_cores_count}" -ge 4 ]]; then
            cores_allocated_to_host=2

          elif [[ "${total_cores_count}" -le 3 ]] \
            && [[ "${total_cores_count}" -ge 2 ]]; then
            cores_allocated_to_host=1

          else
            print_prefix_error "Insufficient CPU cores."
            return 1
          fi

          # <remarks>Get thread sets, for host and guest(s).</remarks>
          local -a host_cores_enum=( $( seq 0 $(( "${CORES_ALLOCATED_TO_HOST}" - 1 )) ) )
          local -a host_threads_enum=( )
          local -a GUEST_CORES_ENUM=( $( seq "${CORES_ALLOCATED_TO_HOST}" $(( "${TOTAL_CORES_COUNT}" - 1 )) ) )
          local -a GUEST_THREADS_ENUM=( )
          local -i SMT_FACTOR=$(( "${TOTAL_THREADS_COUNT}" / "${TOTAL_CORES_COUNT}" ))
          local -a SMT_FACTOR_ENUM=( $( seq 0 $(( "${SMT_FACTOR}" - 1 )) ) )
          GetThreadSetsForHostAndGuest

          # <remarks>Truncate last delimiter.</remarks>
          if [[ ${HOST_THREADS_DELIM: -1} == "," ]]; then
            HOST_THREADS_DELIM="${HOST_THREADS_DELIM::-1}"
          fi

          if [[ ${GUEST_THREADS_DELIM: -1} == "," ]]; then
            GUEST_THREADS_DELIM="${GUEST_THREADS_DELIM::-1}"
          fi

          # <remarks>
          # save output to string for cpuset and cpumask
          # example:
          #   host 0-1,8-9
          #   virt 2-7,10-15
          #
          # information
          # cores   bit masks     mask
          # 0-7     0b11111111    FF    # total cores
          # 0,4     0b00010001    11    # host cores
          #
          # 0-11    0b111111111111  FFF   # total cores
          # 0-1,6-7   0b000011000011  C3    # host cores
          #
          # </remarks>

          # <remarks>Find CPU mask.</remarks>
          # local GET_HEX_MASK='echo "obase=16; ${THREAD}_DECIMAL" | bc'
          # local -i HOST_THREADS_HEX_MASK=0
          # local -i TOTAL_THREADS_HEX_MASK=0

          # <remarks>Add each decimal mask to sum.</remarks>
          # for THREAD in ${HOST_THREADS_ENUM[@]}; do
          #   local -i THREAD_DECIMAL=$(( 2 ** ${THREAD} ))
          #   local -i THREAD_HEX_MASK=$( eval "${GET_HEX_MASK}" )
          #   HOST_THREADS_HEX_MASK+="${THREAD_HEX_MASK}"
          # done

          # <remarks>Convert hexadecimal mask into hexadecimal.</remarks>
          # local HOST_THREADS_HEX=$( printf '%x\n' "${HOST_THREADS_HEX_MASK}" )
          # local -i TOTAL_THREADS_HEX_MASK=$(( ( 2 ** ${TOTAL_THREADS_COUNT} ) - 1 ))
          # local GUEST_THREADS_HEX=$( printf '%x\n' "${TOTAL_THREADS_HEX_MASK}" )

          # <remarks>Save changes.</remarks>
          _LINE_GRUB_CMDLINE_ISOLCPU="isolcpus=${GUEST_THREADS_DELIM} nohz_full=${GUEST_THREADS_DELIM} rcu_nocbs=${GUEST_THREADS_DELIM}"
          _PRE_SETUP_DONE_ISOLCPU=true
          return 0
        }

        local HOST_THREADS_DELIM=""
        local GUEST_THREADS_DELIM=""

        Main
        SetExitCode

        if GetPassExitCode \
          && "${_PRE_SETUP_DO_EXECUTE_ISOLCPU}"; then
          echo -e "Allocated to Host:\t${HOST_THREADS_DELIM}"
          echo -e "Allocated to Guest:\t${GUEST_THREADS_DELIM}"
        fi

        execute_static_isolcpu_setup_prompt || return 1
        set_input_devices
        local -r output= "Allocating CPU threads..."
        print_suffix_work "${output}"

        if is_input_device_enum_valid; then
          PRE_SETUP_DO_EXECUTE_ISOLCPU=true
          print_suffix_pass "${output}"
        else
          print_suffix_fail "${output}"
        fi
      }

      function execute_static_isolcpu_setup_prompt
      {
        if "${PRE_SETUP_DO_EXECUTE_ISOLCPU}"; then
          return 0
        fi

        echo

        if ! "${COMMON_ARGS_IS_EXECUTION_QUIET}"; then
          echo -e "${_SET_COLOR_YELLOW}Isolcpu${_RESET_COLOR} is a feature which isolates CPU threads from the Host machine.\nGuest(s) can use Isolcpu to a peformance benefit. Guest(s) can use isolated CPU threads, increasing responsiveness and stability, without interferrence from the Host.\n${_SET_COLOR_YELLOW}NOTE:${_RESET_COLOR} If this is skipped, the equivalent Libvirt hook for dynamic isolation will be installed.\n"
        fi

        execute_or_skip_prompt "Setup ${SET_COLOR_YELLOW}Evdev${RESET_COLOR}?" || return 1
      }

    # <summary>
    # libvirt-qemu: Append necessary changes to QEMU system file, including user groups, Evdev, Hugepages, and NVRAM (for UEFI guest(s)).
    # </summary>
      function execute_qemu_configuration
      {
        function Main
        {
          BackupFile "${_APPARMOR_QEMU_DEST_PATH}" || return "${?}"
          BackupFile "${_QEMU_DEST_PATH}" || return "${?}"

          local -a FILE_1_CONTENTS=( )
          local -a FILE_1_CONTENTS_EVDEV_CGROUPS=( )
          local -a FILE_2_CONTENTS=( )
          local -a FILE_1_CONTENTS_DEFAULT_CGROUPS=(
            "    \"/dev/null\", \"/dev/full\", \"/dev/zero\","
            "    \"/dev/random\", \"/dev/urandom\","
            "    \"/dev/ptmx\", \"/dev/kvm\","
            "    \"/dev/rtc\", \"/dev/hpet\""
          )
          # <remarks>Format input for Evdev.</remarks>
          if "${_PRE_SETUP_DO_EXECUTE_EVDEV}"; then
            for DEVICE in ${EVENT_DEVICES_ENUM[@]}; do
              FILE_1_CONTENTS_EVDEV_CGROUPS+=( "    \"/dev/input/by-id/${DEVICE}\"," )
            done

            for DEVICE in ${INPUT_DEVICES_ENUM[@]}; do
              FILE_1_CONTENTS_EVDEV_CGROUPS+=( "    \"/dev/input/by-id/${DEVICE}\"," )
            done
          fi

          # <remarks>Preface file contents.</remarks>
          FILE_1_CONTENTS=( "${_DISCLAIMER_FILE_CONTENTS[@]}" )
          FILE_2_CONTENTS=( "${_DISCLAIMER_FILE_CONTENTS[@]}" )
          FILE_1_CONTENTS+=(
            ""
            "### User permissions ###"
          )

          # <remarks>Add user and group for Evdev.</remarks>
          if "${_PRE_SETUP_DO_EXECUTE_EVDEV}"; then
            FILE_1_CONTENTS+=(
              "user = \"${_USER}\""
              "group = \"user\""
            )
          else
            FILE_1_CONTENTS+=(
              "#user = \"user\""
              "#group = \"user\""
            )

            false
          fi

          # <remarks>Hugepages</remarks>
          FILE_1_CONTENTS+=(
            ""
            "### Hugepages ###"
          )

          if "${_PRE_SETUP_DONE_HUGEPAGES}"; then
            FILE_1_CONTENTS+=(
              "hugetlbfs_mount = \"/dev/hugepages\""
            )

            FILE_2_CONTENTS+=(
              ""
              "# Hugepages"
              "/dev/hugepages rw,"
            )
          else
            FILE_1_CONTENTS+=(
              "#hugetlbfs_mount = \"/dev/hugepages\""
            )

            false
          fi

          # <remarks>Add cgroups for Evdev.</remarks>
          FILE_1_CONTENTS+=(
            ""
            "### Devices ###"
            "cgroup_device_acl = ["
          )

          if ${_PRE_SETUP_DO_EXECUTE_EVDEV}; then
            FILE_1_CONTENTS+=(
              "${FILE_1_CONTENTS_EVDEV_CGROUPS[@]}"
              "${FILE_1_CONTENTS_DEFAULT_CGROUPS[@]}"
              "]"
            )

            FILE_2_CONTENTS+=(
              ""
              "# Evdev"
              "/dev/input/* rw,"
              "/dev/input/by-id/* rw,"
            )
          else
            FILE_1_CONTENTS+=(
              "${FILE_1_CONTENTS_DEFAULT_CGROUPS[@]}"
              "]"
            )

            false
          fi

          # <remarks>Adds NVRAM for EFI kernels in UEFI guest(s).</remarks>
          FILE_1_CONTENTS+=(
            ""
            "nvram = ["
            "    \"/usr/share/OVMF/OVMF_CODE.fd:/usr/share/OVMF/OVMF_VARS.fd\","
            "    \"/usr/share/OVMF/OVMF_CODE.secboot.fd:/usr/share/OVMF/OVMF_VARS.fd\","
            "    \"/usr/share/AAVMF/AAVMF_CODE.fd:/usr/share/AAVMF/AAVMF_VARS.fd\","
            "    \"/usr/share/AAVMF/AAVMF32_CODE.fd:/usr/share/AAVMF/AAVMF32_VARS.fd\""
            "]"
          )

          # <remarks>Append changes to file(s).</remarks>
          if ! sudo echo -e "${FILE_1_CONTENTS[*]}" >> "${_QEMU_DEST_PATH}"; then
            echo -e "${_PREFIX_ERROR} Failed to write to file '${_QEMU_DEST_PATH}'."
          fi

          if ! sudo echo -e "${FILE_2_CONTENTS[*]}" >> "${_APPARMOR_QEMU_DEST_PATH}"; then
            echo -e "${_PREFIX_ERROR} Failed to write to file '${_APPARMOR_QEMU_DEST_PATH}'."
          fi

          return 0
        }

        IFS=$'\n'
        Main
        SetExitCode
        unset IFS

        if ! GetPassExitCode; then
          RestoreFile "${_APPARMOR_QEMU_DEST_PATH}" && RestoreFile "${_QEMU_DEST_PATH}"
          SetExitCode
        fi

        GetExitCode
        PrintSuffixPassOrFail "Appending Libvirt file..."
        return "${_LAST_EXIT_CODE}"
      }

    # <summary>
    # Evdev: Setup a virtual Keyboard-Video-Mouse switch (excluding the Video).
    # Will allow a user to swap between active guest(s) and host, with the use of a pre-defined macro (example: 'L-CTRL' + 'R-CTRL').
    # </summary>
      function execute_virtual_kvm_setup
      {
        execute_virtual_kvm_setup_prompt || return 1
        set_input_devices
        local -r output="Executing Evdev setup..."
        print_suffix_work "${output}"

        if is_input_device_enum_valid; then
          PRE_SETUP_DO_EXECUTE_EVDEV=true
          print_suffix_pass "${output}"
        else
          print_suffix_fail "${output}"
        fi
      }

      function execute_virtual_kvm_setup_prompt
      {
        if "${PRE_SETUP_DO_EXECUTE_EVDEV}"; then
          return 0
        fi

        echo

        if ! "${_COMMON_ARGS_IS_EXECUTION_QUIET}"; then
          echo -e "${_SET_COLOR_YELLOW}Evdev${_RESET_COLOR} (Event Devices) is a method of creating a virtual KVM (Keyboard-Video-Mouse) switch between Host and Guest(s).\nGuest(s) may reference any of each (currently) listed input device.\n${_SET_COLOR_YELLOW}HOW-TO:${_RESET_COLOR} Press 'L-CTRL' and 'R-CTRL' simultaneously.\n"
        fi

        execute_or_skip_prompt "Setup ${SET_COLOR_YELLOW}Evdev${RESET_COLOR}?" || return 1
      }

  # <summary>Setters</summary>
    function is_input_device_enum_valid
    {
      if ! is_enum_empty "EVENT_DEVICES_ENUM" \
       || ! is_enum_empty "INPUT_DEVICES_ENUM"; then
        PRE_SETUP_DO_EXECUTE_EVDEV=false
        print_prefix_error "Cannot parse input devices."
        return 1
      fi
    }

    function set_input_devices
    {
      EVENT_DEVICES_ENUM=( $( ls -l /dev/input/by-id | cut -d "/" -f2 | grep -v "total 0" ) )
      INPUT_DEVICES_ENUM=( $( ls /dev/input/by-id ) )
    }

    function set_kernel_command_hugepages
    {
      if [[ -z "${1}" ]]; then
        return 1
      fi

      local -n reference="${1}"
      reference="${GRUB_CMDLINE_HUGEPAGES}"
    }

    function set_kernel_command_isolcpu
    {
      if [[ -z "${1}" ]]; then
        return 1
      fi

      local -n reference="${1}"
      reference="${GRUB_CMDLINE_ISOLCPU}"
    }

    function set_thread_by_core_and_smt_factor
    {
      local -n reference="${1}"
      local -ir core="${2}"
      local -ir smt_factor="${3}"
      local -ir total_cores_count="${3}"
      reference=$(( core + ( smt_factor * total_cores_count ) ))       # NOTE: VS Code reports a syntax error here. There is none.
    }
# </functions>

# <code>
  declare_parameters
  unset declare_parameters
# </code