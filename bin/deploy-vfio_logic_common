#!/bin/false

#
# Filename:       deploy-vfio_logic_common
# Description:    Common-use functions and variables.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

# <traps>
  trap 'catch_error' SIGINT SIGTERM ERR
  trap 'catch_exit' EXIT
# </traps>

# <functions>
  function declare_parameters
  {
    if [[ "${COMMON_ARE_PARAMS_SET}" == true ]]; then
      return 0
    fi

    declare -g COMMON_ARE_PARAMS_SET=true

    declare -gr REPO_NAME="portellam"
    declare -gr SCRIPT_NAME="deploy-vfio"

    # <summary>
    # Color coding
    # Reference URL: 'https://www.shellhacks.com/bash-colors'
    # </summary>
      declare -gr SET_COLOR_GREEN='\033[0;32m'
      declare -gr SET_COLOR_RED='\033[0;31m'
      declare -gr SET_COLOR_YELLOW='\033[0;33m'
      declare -gr RESET_COLOR='\033[0m'

    # <summary>Append output</summary>
      declare -gr PREFIX_PROMPT="${SCRIPT_NAME}: "
      declare -gr PREFIX_NOTE="${PREFIX_PROMPT}${SET_COLOR_YELLOW}Note:${RESET_COLOR} "
      declare -gr PREFIX_ERROR="${PREFIX_PROMPT}${SET_COLOR_YELLOW}An error occurred:${RESET_COLOR} "
      declare -gr PREFIX_FAIL="${PREFIX_PROMPT}${SET_COLOR_RED}Failure:${RESET_COLOR} "
      declare -gr PREFIX_PASS="${PREFIX_PROMPT}${SET_COLOR_GREEN}Success:${RESET_COLOR} "

    declare -g PREFIX_COMMENT="#" # <note>Added this var, to prevent IDE from showing visual errors when a string contains a comment variable.</note>

    declare -gr BIN_PATH="/usr/local/bin/${SCRIPT_NAME}.d/"
    declare -gr ETC_BACKUPS_PATH="/usr/local/etc/${SCRIPT_NAME}.d/"

    # <summary>File templates.</summary>
      declare -gar DISCLAIMER_FILE_CONTENTS=(
        "${PREFIX_COMMENT} Generated by '${REPO_NAME}/${SCRIPT_NAME}'"
        "${PREFIX_COMMENT} WARNING: Any modifications to this file will be modified by '${SCRIPT_NAME}'"
        "${PREFIX_COMMENT}"
      )

    # <summary>Memory</summary>
      declare -gi AVAILABLE_MEMORY=0
      declare -gir ONE_GIB_IN_KIB=1048576
      declare -gir TWO_MIB_IN_KIB=2048
      declare -gir MAX_MEMORY=$( cat /proc/meminfo | grep MemTotal | cut --delimiter ":" --fields 2 | awk 'END {print $1}' )
      declare -gir MIN_MEMORY=$(( 8 * ${ONE_GIB_IN_KIB} ))
      set_free_memory

    declare -gr LOGIN_USER=$( who am i | awk '{print $1}' )
  }

  # <summary>Clean-up</summary>
    function set_ifs_to_newline
    {
      IFS=$'\n'
    }

    function reset_ifs
    {
      IFS="${SAVEIFS}"
    }

  # <summary>Data-type manipulation</summary>
    function reverse_array
    {
      is_enum "${1}" || return 1
      local -n this_enum="${1}"
      this_enum="$( printf '%s\n' "${this_enum[@]}" | tac | tr '\n' ' '; echo )"
    }

  # <summary>Data-type validation</summary>
    function get_comma_delimited_string_from_enum
    {
      local -n this_enum="${1}"
      local -n this_delimited_string="${2}"

      for value in ${this_enum[@]}; do
        this_delimited_string+="${value},"
      done

      if [[ ${this_delimited_string: -1} == "," ]]; then
        this_delimited_string="${this_delimited_string::-1}"
      fi
    }

    function is_enum
    {
      local -n this_enum="${1}"

      if ! [[ "${#this_enum[@]}" -gt 0 ]]; then
        print_to_error_log "Invalid enum."
        return 1
      fi
    }

    function is_enum_not_empty
    {
      is_enum "${1}" || return 1
      local -n this_enum="${1}"

      for value in "${this_enum[@]}"; do
        if is_string "${value}" &> /dev/null; then
          return 0
        fi
      done

      print_to_error_log "Empty enum."
      return 1
    }

    function is_int
    {
      if ! [[ "${1}" =~ ^[0-9]+$ ]] \
        && ! [[ "${1}" =~ ^[-][0-9]+$ ]]; then
        print_to_error_log "Invalid integer."
        return 1
      fi
    }

    function is_string
    {
      if [[ "${1}" == "" ]]; then
        print_to_error_log "Empty string."
        return 1
      fi
    }

  # <summary>File manipulation</summary>
    function create_temp_file_of_file
    {
      is_file "${1}" &> /dev/null || return 0

      local -r file="${1}"
      local -r temp_file="${file}.tmp"

      if ! cp --force "${file}" "${temp_file}"; then
        print_error_to_log "Failed to create temp file of '${file}'."
        return 1
      fi
    }

    function copy_temp_file_to_file
    {
      is_file "${1}" &> /dev/null || return 0

      local -r file="${1}"
      local -r temp_file="${file}.tmp"

      is_file "${temp_file}" || return 1

      if ! cp --force "${temp_file}" "${file}"; then
        print_error_to_log "Failed to overwrite file '${file}'."
        return 1
      fi
    }

    function copy_this_file_to_other_file
    {
      if [[ "${2}" == "" ]]; then
        return 1
      fi

      is_file "${1}" || return 1
      cp --force "${1}" "${2}" || return 1
    }

    function delete_temp_file_of_file
    {
      is_file "${1}" &> /dev/null || return 0

      local -r file="${1}"
      local -r temp_file="${file}.tmp"

      is_file "${temp_file}" &> /dev/null || return 0

      if ! rm --force --recursive "${temp_file}"; then
        print_error_to_log "Failed to delete temp file '${temp_file}'."
        return 1
      fi
    }

    function append_to_file_correctly
    {
      if ! is_file "${2}" \
        || [[ -z "${1}" ]]; then
        return 1
      fi

      local -nr reference="${1}"
      local -r file="${2}"

      for line in ${reference[*]}; do
        if ! sudo echo -e "${line}" >> "${file}"; then
          print_error_to_log "Could not append to file."
          return 1
        fi
      done
    }

  # <summary>File validation</summary>
    function is_file
    {
      if [[ -z "${1}" ]] \
        || [[ ! -e "${1}" ]]; then
        print_error_to_log "File does not exist."
        return 1
      fi
    }

    function is_file_not_empty
    {
      if [[ -z "${1}" ]] \
        || [[ ! -s "${1}" ]]; then
        print_error_to_log "File is empty."
        return 1
      fi
    }

   # <summary>GitHub</summary>
    function clone_git_repo
    {
      local -r full_repo="${1}"

      if ! git clone "https://github.com/${full_repo}" &> /dev/null; then
        print_error_to_log "Failed to download repository."
        return 1
      fi
    }

    function update_git_repo
    {
      if ! git pull &> /dev/null; then
        print_error_to_log "Failed to update repository."
        return 1
      fi
    }

    function update_or_clone_git_repo
    {
      local -r full_repo="${1}"
      local -r user_name="${2}"
      local -r full_path="${BIN_PATH}${full_repo}"
      local -r user_path="${BIN_PATH}${user_name}"

      if [[ ! -d "${user_path}" ]] \
        && ! sudo mkdir --parents "${user_path}" &> /dev/null; then
        print_error_to_log "Failed to create directory '${user_path}'."
        return 1
      fi

      if [[ ! -d "${full_path}" ]]; then
        cd "${full_path}"
        update_git_repo

      elif [[ -d "${user_path}" ]]; then
        clone_git_repo "${full_repo}"

      else
        return 1
      fi
    }

  # <summary>Handlers</summary>
    function catch_error {
      exit 255
    }

    function catch_exit {
      print_pass_or_fail_to_log
      reset_ifs
    }

    function is_user_superuser
    {
      if [[ $( whoami ) != "root" ]]; then
        print_to_error_log "User is not sudo or root."
        return 1
      fi
    }

  # <summary>Interaction</summary>
    function execute_or_skip_prompt
    {
      local output=""

      if [[ ! -z "${1}" ]]; then
        output="${1} "
      fi

      for counter in $( seq 0 2 ); do
        echo -en "${output}[Y/n]: "
        read -r -p "" answer

        case "${answer}" in
          [Yy]* )
            return 0 ;;

          [Nn]* )
            return 255 ;;

          * )
            echo "Please answer 'Y' or 'N'." ;;
        esac
      done

      return 1
    }

  # <summary>Loggers/summary>
    function print_error_to_log
    {
       echo -e "${PREFIX_ERROR}${1}" >&2
    }

    function print_fail_to_log
    {
      echo -e "${PREFIX_FAIL}${1}" >&2
    }

    function print_output_to_log
    {
      echo -e "${PREFIX_PROMPT}${1}" >&1
    }

    function print_pass_or_fail_to_log
    {
      local -ir exit_code="${?}"

      if [[ "${exit_code}" -eq 255 ]]; then
        print_output_to_log "VFIO setup skipped."
        return "${exit_code}"
      fi

      if [[ "${exit_code}" -ne 0 ]]; then
        print_fail_to_log "Setup incomplete."
        return "${exit_code}"
      fi

      print_pass_to_log "Setup complete."
    }

    function print_pass_to_log
    {
      echo -e "${PREFIX_PASS}${1}" >&1
    }

  # <summary>Presentation/summary>
    function print_note
    {
      echo -e "${PREFIX_NOTE}${1}"
    }

  # <summary>System validation</summary>
    function get_free_memory
    {
      if [[ "${AVAILABLE_MEMORY}" -le 0 ]]; then
        return 1
      fi
    }

    function set_free_memory
    {
      AVAILABLE_MEMORY=$(( MAX_MEMORY - MIN_MEMORY ))
    }

# </functions>

# <code>
  declare_parameters
  unset declare_parameters
# </code