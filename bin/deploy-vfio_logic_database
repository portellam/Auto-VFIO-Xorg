#!/bin/false

#
# Filename:       deploy-vfio_logic_database
# Description:    Parse and select IOMMU groups.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

# <sources>
  source deploy-vfio_logic_common
# </sources>

# <functions>
  function declare_parameters
  {
    if [[ "${DATABASE_ARE_PARAMS_SET}" == true ]]; then
      return 0
    fi

    declare -g DATABASE_ARE_PARAMS_SET=true

    declare -g DATABASE_DO_PARSE_DATABASE=false
    declare -g DATABASE_DO_PARSE_DATABASE_FROM_XML=false
    declare -g DATABASE_XML_FILE_IS_SPECIFIED=false
    declare -g DATABASE_HAS_ARG_PARSE_IOMMU=false
    declare -g DATABASE_HAS_ARG_PARSE_IOMMU_SELECT_ALL=false
    declare -g DATABASE_HAS_ARG_PARSE_IOMMU_SELECT_SOME=false

    declare -gr GET_DEVICES_FOR_IOMMU_GROUP='ls /sys/kernel/iommu_groups/${iommu_group_id}/devices/'

    declare -gA DEVICE_DRIVER_XML_ENUM
    declare -ga IOMMU_GROUP_ID_ENUM=( $( ls /sys/kernel/iommu_groups/ | sort -n ) )
    declare -ga IOMMU_GROUPS_FOR_HOST_ENUM=( )
    declare -ga IOMMU_GROUPS_FOR_VFIO_ENUM=( )
    declare -ga IOMMU_GROUPS_WITH_VGA_FOR_HOST_ENUM=( )
    declare -ga IOMMU_GROUPS_WITH_VGA_FOR_VFIO_ENUM=( )

    declare -gr DEFAULT_XML_FILE="${ETC_BACKUPS_PATH}/parse.xml"
    declare -g XML_FILE="${DEFAULT_XML_FILE}"
  }

  function do_parse_database
  {
    if ! create_temp_files_for_database \
      || ! do_try_parse_database; then
      do_cleanup_database
      return 1
    fi

    do_cleanup_database
  }

  function do_cleanup_database
  {
    if ! restore_temp_files_for_database \
      || ! delete_temp_files_for_database; then
      print_prefix_error "Database: Cleanup failed."
    fi
  }

  function do_try_parse_database
  {
    do_parse_database_prompt || return 0
    is_unparsed_enum_valid || return 1
    parse_from_xml_prompt
    specify_xml_file || return 1

    if "${DATABASE_DO_PARSE_DATABASE_FROM_XML}" \
      && ! is_xml_valid; then
      does_host_not_have_existing_vfio_setup || return 1
      export_iommu_groups_to_xml || return 1
      specify_iommu_group_enum
    fi

    if ! does_host_not_have_existing_vfio_setup; then
      does_xml_not_have_existing_vfio_setup || return 1
      import_iommu_groups_from_xml
    fi

    specify_iommu_group_enum
  }

  function do_parse_database_prompt
  {
    if "${DATABASE_DO_PARSE_DATABASE}"; then
      return 0
    fi

    execute_or_skip_prompt "Parse database for IOMMU groups?" || return 1
    DATABASE_DO_PARSE_DATABASE=true
  }

  # <summary>Files</summary>
    function create_temp_files_for_database
    {
      create_temp_file_of_file "${XML_FILE}" || return 1
    }

    function restore_temp_files_for_database
    {
      copy_temp_file_to_file "${XML_FILE}" || return 1
    }

    function delete_temp_files_for_database
    {
      delete_temp_file_of_file "${XML_FILE}" || return 1
    }

  # <summary>Getters</summary>
    function get_device_class
    {
      if [[ ! -z "${2}" ]] \
        || [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local -n reference="${2}"
      reference="$( lspci -ms ${device} | cut -d '"' -f 2 )"
    }

    function get_device_driver
    {
      if [[ ! -z "${2}" ]] \
        || [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local -n reference="${2}"

      if "${DATABASE_DO_PARSE_DATABASE_FROM_XML}"; then
        reference="${DEVICE_DRIVER_XML_ENUM["${device}"]}"
      else
        reference="$( lspci -ks "${device}" | grep -i "driver" | cut -d " " -f 5 )"
      fi
    }

    function get_device_hardware_id
    {
      if [[ ! -z "${2}" ]] \
        || [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local -n reference="${2}"

      reference="$( lspci -ns ${device} | cut -d " " -f 3 )"
    }

    function get_device_name
    {
      if [[ ! -z "${2}" ]] \
        || [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local -n reference="${2}"

      reference="$( lspci -ms ${device}  | cut -d '"' -f 6 )"
    }

    function get_device_vendor
    {
      if [[ ! -z "${2}" ]] \
        || [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local -n reference="${2}"

      reference="$( lspci -ms ${device} | cut -d '"' -f 4 )"
    }

    function get_enums_for_selection
    {
      local -n reference="${1}"
      local -n driver_reference="${2}"
      local -n stud_hwid_reference="${3}"
      local -n vfio_hwid_reference="${4}"

      for iommu_group_id in ${reference[@]}; do
        local -a device_list="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

        for device in ${device_list[@]}; do
          local driver=""
          local hwid=""
          SetDeviceDriver "${device}" "driver"
          SetDeviceHardwareID "${device}" "hwid"

          if [[ ! -z "${driver}" ]] \
            && is_device_not_excluded "${device}"; then
            driver_reference+=( "${driver}" )
          fi

          if [[ ! -z "${hwid}" ]]; then
            if is_device_for_pci_stub "${device}"; then
              stud_hwid_reference+=( "${hwid}" )
            else
              vfio_hwid_reference+=( "${hwid}" )
            fi
          fi
        done
      done

      set_ifs_to_newline
      driver_reference=( $( sort -u <<<"${driver_reference[*]}" ) )
      stud_hwid_reference=( $( sort -u <<<"${stud_hwid_reference[*]}" ) )
      vfio_hwid_reference=( $( sort -u <<<"${vfio_hwid_reference[*]}" ) )
      unset_ifs

      if ! is_enum_empty "driver_reference"; then
        return 0
      fi

      if is_enum_empty "stud_hwid_reference" \
        && is_enum_empty "vfio_hwid_reference"; then
        return 0
      fi

      print_prefix_error "No drivers or hardware IDs found for selection."
      return 1
    }

    function get_name_for_first_vga_device_in_iommu_group
    {
      if [[ -z "${2}" ]] \
        || ! is_int "${1}"; then
        return 1
      fi

      local -ir iommu_group_id="${1}"
      local -n device_name="${2}"
      local -ar device_list="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"
      local name=""

      for device in ${device_list[@]}; do
        if ! is_device_vga "${device}"; then
          continue
        fi

        get_device_name "${device}" "name" && break
      done

      if [[ -z "${NAME}" ]]; then
        print_prefix_error "Failed to find device name of any VGA device in IOMMU group ${IOMMU_GROUP_ID}."
        return 1
      fi

      device_name="${NAME}"
    }

  # <summary>Host validation</summary>
    function does_host_not_have_existing_vfio_setup
    {
      for iommu_group_id in ${IOMMU_GROUP_ID_ENUM[@]}; do
        if ! is_iommu_group_not_binded_to_vfio "${iommu_group_id}"; then
          print_prefix_error "Detected existing VFIO setup."
          return 1
        fi
      done

      DOES_HOST_HAVE_VFIO=false
    }

    function does_xml_not_have_existing_vfio_setup
    {
      if eval "${GET_PARSE_FROM_XML}" | grep -E "vfio" &> /dev/null; then
        print_prefix_error "Detected VFIO drivers in XML file."
        return 1
      fi

      DOES_XML_HAVE_VFIO=false
    }

  # <summary>IOMMU Groups validation</summary>
    function add_iommu_group_to_enum
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_external_devices "${iommu_group_id}"; then
        add_iommu_group_to_vfio_enum "${iommu_group_id}"
      else
        add_iommu_group_to_host_enum "${iommu_group_id}"
      fi
    }

    function add_iommu_group_to_host_enum
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_vga_device "${iommu_group_id}"; then
          IOMMU_GROUPS_WITH_VGA_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
      fi

      IOMMU_GROUPS_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
    }

    function add_iommu_group_to_vfio_enum
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_vga_device "${iommu_group_id}"; then
        IOMMU_GROUPS_WITH_VGA_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
      fi

      IOMMU_GROUPS_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
    }

    function add_iommu_group_to_enum_if_not_specified
    {
      local -ir iommu_group_id="${1}"

      for this_iommu_group_id in ${IOMMU_GROUP_ID_ENUM[@]}; do
        if [[ "${this_iommu_group_id}" -eq "${iommu_group_id}" ]]; then
          add_iommu_group_to_vfio_enum "${iommu_group_id}"
        else
          add_iommu_group_to_host_enum "${iommu_group_id}"
        fi
      done
    }

    function add_some_iommu_groups_to_parsed_enum
    {
      local regex_for_range_of_nums='^[0-9]+[-][0-9]+$'
      local -ar iommu_groups_temp_enum
      local -ir iommu_group_id="${1}"

      is_iommu_group_id_parsable "${iommu_group_id}" "iommu_groups_temp_enum" || return 1

      set_ifs_to_newline
      iommu_groups_temp_enum=( $( sort -hu <<<"${iommu_groups_temp_enum[*]}" ) )
      unset_ifs

      for iommu_group_id in ${iommu_groups_temp_enum[@]}; do
        add_iommu_group_to_enum_if_not_specified "${iommu_group_id}"
      done
    }

    function add_valid_iommu_groups_to_parsed_enum
    {
      for iommu_group_id in ${IOMMU_GROUP_ID_ENUM[@]}; do
        add_iommu_group_to_enum "${iommu_group_id}"
      done
    }

    function does_enum_have_vga_device
    {
      local -n reference="${1}"

      if [[ "${#reference[@]}" -eq 0 ]]; then
        return 1
      fi

      for iommu_group_id in ${reference[@]}; do
        does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null && return 0
      done

      return 1
    }

    function does_iommu_group_have_external_devices
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_external "${device}" && return 0
      done

      return 1
    }

    function does_iommu_group_have_vga_device
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_vga "${device}" && return 0
      done

      print_prefix_error "Please enter valid IOMMU group ID which contains one or more VGA devices."
      return 1
    }

    function is_iommu_group_id_parsable
    {
      local -ir iommu_group_id="${1}"
      local -n reference="${2}"

      if echo "${1}" | grep -E -q "${regex_for_range_of_nums}"; then
        local -i range_start=$( echo "${1}" | cut -d '-' -f 1 )
        local -i range_stop=$( echo "${1}" | cut -d '-' -f 2 )
        is_iommu_group_id_valid "${range_start}" || return 1
        is_iommu_group_id_valid "${range_stop}" || return 1
        reference+=( $( seq "${range_start}" "${range_stop}" ) )

      elif is_int "${1}"; then
        is_iommu_group_id_valid "${1}" || return 1
        reference+=( "${1}" )

      else
        print_prefix_error "Invalid IOMMU group ID(s)."
        return 1
      fi
    }

    function is_iommu_group_id_valid
    {
      local -ir minimum_iommu_group_id=0
      local -ir maximum_iommu_group_id="${IOMMU_GROUP_ID_ENUM[-1]}"

      if ! is_int "${1}" \
        || [[ "${1}" -le "${minimum_iommu_group_id}" ]] \
        || [[ "${1}" -ge "${maximum_iommu_group_id}" ]] ; then
        print_prefix_error "Please enter valid IOMMU group ID(s), between ${minimum_iommu_group_id} and ${maximum_iommu_group_id}."
        return 1
      fi
    }

    function is_iommu_group_not_binded_to_vfio
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_not_binded_to_vfio "${device}" || return 1
      done
    }

    function is_unparsed_enum_valid
    {
      local -r output="Invalid IOMMU groups."

      if ! is_enum "IOMMU_GROUP_ID_ENUM"; then
        print_prefix_error "${output}"
        return 1
      fi

      for value in ${IOMMU_GROUP_ID_ENUM[@]}; do
        if ! is_int "${value}"; then
          print_prefix_error "${output}"
          return 1
        fi
      done
    }

    function is_valid_enum_of_iommu_groups
    {
      is_enum "${1}" || return 1
      local -n reference="${1}"

      for value in ${reference[@]}; do
        is_int "${value}" || return 1
      done
    }


  # <summary>Device validation</summary>
    function is_device_driver_not_excluded
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local driver="${1}"
      local excluded_driver="snd_hda_intel"

      case "${driver}" in
        *"${excluded_driver}"* )
          return 1 ;;
      esac
    }

    function is_device_driver_not_vfio
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local driver="${1}"
      local matched_driver="vfio-pci"

      case "${driver}" in
        *"${matched_driver}"* )
          return 1 ;;
      esac
    }

    function is_device_external
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local regex_get_domain_id='^[0-9A-F][1-9A-F]$'
      local -u domain_id=$( echo "${device}" | cut -d ':' -f 2 )
      echo "${domain_id}" | grep -E -q "${regex_get_domain_id}"
    }

    function is_device_for_pci_stub
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local -l class="$( lspci -ms ${device} | cut -d '"' -f 2 )"

      case "${class}" in
        *"usb"* )
          return 0 ;;
      esac

      return 1
    }

    function is_device_not_binded_to_vfio
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local driver=""
      get_device_driver "${device}" "driver"
      is_device_driver_not_vfio "${driver}"
    }

    function is_device_not_excluded
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local driver=""
      get_device_driver "${device}" "driver"
      is_device_driver_not_excluded "${driver}"
    }

    function is_device_not_external
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local driver=""
      get_device_driver "${device}" "driver"
      is_device_external "${device}"
    }

    function is_device_vga
    {
      if [[ ! -z "${1}" ]]; then
        return 1
      fi

      local device="${1}"
      local -l class="$( lspci -ms ${device} | cut -d '"' -f 2 )"

      case "${class}" in
        *"vga"* | *"graphic"* | *"display"* )
          return 0 ;;
      esac

      return 1
    }

  # <summary>IOMMU Groups presentation</summary>
    function do_select_iommu_group
    {
      local -ir iommu_group_id="${1}"
      IOMMU_GROUPS_FOR_VFIO_ENUM+=( "${iommu_group_id}" )

      if does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null; then
        IOMMU_GROUPS_WITH_VGA_FOR_VFIO_ENUM+=( "${iommu_group_id}" )
      fi
    }

    function do_not_select_iommu_group
    {
      local -ir iommu_group_id="${1}"

      if does_iommu_group_have_vga_device "${iommu_group_id}" &> /dev/null; then
        IOMMU_GROUPS_WITH_VGA_FOR_HOST_ENUM+=( "${iommu_group_id}" )
      else
        IOMMU_GROUPS_FOR_HOST_ENUM+=( "${iommu_group_id}" )
      fi
    }

    function print_iommu_group
    {
      local class driver hwid name vendor

      get_device_class "${device}" "class"
      get_device_driver "${device}" "driver"
      get_device_hardware_ID "${device}" "hwid"
      get_device_name "${device}" "name"
      get_device_vendor "${device}" "vendor"

      echo -e "\tSlot ID:\t${device}"
      echo -e "\tVendor name:\t${vendor}"
      echo -e "\tDevice name:\t${name}"
      echo -e "\tClass/Type:\t${class}"
      echo -e "\tHardware ID:\t${hwid}"
      local drive_output="\tDriver:\t\t"

      if [[ ! -z "${driver}" ]]; then
        echo -e "${drive_output}${driver}"
      else
        echo -e "${drive_output}N/A"
      fi

      echo
    }

    function print_iommu_group_enum
    {
      local -ir iommu_group_id="${1}"
      local -ar device_enum="$( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" )"

      for device in ${device_enum[@]}; do
        is_device_external "${device}" && print_iommu_group
      done
    }

    function specify_iommu_group
    {
      local -ir iommu_group_id="${1}"

      if ! does_iommu_group_have_external_devices "${iommu_group_id}"; then
        IOMMU_GROUPS_FOR_HOST_ENUM+=( "${iommu_group_id}" )
        return 1
      fi

      if ! specify_iommu_group_prompt "${iommu_group_id}" \
        || ! print_iommu_group_enum "${iommu_group_id}"; then
        return 1
      fi
    }

    function specify_iommu_group_enum
    {
      local -n reference="IOMMU_GROUP_ID_ENUM"
      echo

      for iommu_group_id in ${reference[@]}; do
        specify_iommu_group "${iommu_group_id}"
      done
    }

    function specify_iommu_group_prompt
    {
      local -ir iommu_group_id="${1}"

      if execute_or_skip_prompt "Select IOMMU group ${SET_COLOR_YELLOW}${iommu_group_id}${RESET_COLOR}?"; then
        do_select_iommu_group "${iommu_group_id}"
      else
        do_not_select_iommu_group "${iommu_group_id}"
      fi

      echo
    }

  # <summary>XML</summary>
    function export_iommu_groups_to_xml
    {
      local -a output=( )
      local -a iommu_output=( )

      for iommu_group_id in $( ls -1v /sys/kernel/iommu_groups/ | sort -h ); do
        local -a device_output=( )
        local line_iommu_id="id=\"${iommu_group_id}\""

        for device in $( eval "${GET_DEVICES_FOR_IOMMU_GROUP}" ); do
          local device_driver=$( lspci -ks ${device} | grep -i "driver" | cut -d " " -f 5 )
          local line_device_id="dev_id=\"${device}\""
          local line_device_driver="driver=\"${device_driver}\""
          local line_device="${line_device_id} ${line_device_driver}"

          # <note>Currently unused XML data. The minimum data necessary is the device ID and device driver.</note>
          # local device_class="$( lspci -ms ${device} | cut -d \" -f 2 )"
          # local device_hwid=$( lspci -ns ${device} | cut -d " " -f 3 )
          # local device_name="$( lspci -ms ${device} | cut -d \" -f 6 )"
          # local device_vendor="$( lspci -ms ${device} | cut -d \" -f 4 )"
          # local line_device_class="class=\"${device_class}\""
          # local line_device_hwid="hw_id=\"${device_hwid}\""
          # local line_device_name="name=\"${device_name}\""
          # local line_device_vendor="vendor=\"${device_vendor}\""
          # local line_device="${line_device_id} ${line_device_hwid} ${line_device_driver} ${line_device_class} ${line_device_vendor} ${line_device_name}"

          local line_iommu="<iommu ${line_iommu_id} ${line_device}/>"

          device_output+=(
            "\t${line_iommu}"
          )
        done

        iommu_output+=(
          "${device_output[@]}"
        )
      done

      output=(
        "<xml>"
        "${iommu_output[@]}"
        "</xml>"
      )

      set_ifs_to_newline

      if ! sudo echo -e "${output[*]}" > "${XML_FILE}"; then
        print_prefix_error "Failed to write to file '${FILE}'."
        unset_ifs
        return 1
      fi

      unset_ifs
    }

    function import_iommu_groups_from_xml
    {
      set_ifs_to_newline
      local -ar input=( $( eval "${GET_PARSE_FROM_XML}" ) )
      unset_ifs

      for line in "${input[@]}"; do
        local driver=$( echo "${line}" | cut -d '"' -f 6 )
        local device=$( echo "${line}" | cut -d '"' -f 4 )
        DEVICE_DRIVER_XML_ENUM["${device}"]="${driver}"
      done

      if ! is_enum "DEVICE_DRIVER_XML_ENUM"; then
        print_prefix_error "XML file is empty."
        return 1
      fi
    }

    function is_xml_valid
    {
      if ! xmllint "${XML_FILE}" &> /dev/null; then
        print_prefix_error "XML file '${XML_FILE}' is invalid."
        return 1
      fi
    }

    function parse_from_xml_prompt
    {
      if "${DATABASE_DO_PARSE_DATABASE_FROM_XML}"; then
        return 0
      fi

      execute_or_skip_prompt "Cross-reference database with XML file?" && DATABASE_DO_PARSE_DATABASE_FROM_XML=true
    }

    function specify_xml_file
    {
      echo "DATABASE_DO_PARSE_DATABASE_FROM_XML == $DATABASE_DO_PARSE_DATABASE_FROM_XML"

      if "${DATABASE_XML_FILE_IS_SPECIFIED}" \
        && ! "${DATABASE_DO_PARSE_DATABASE_FROM_XML}"; then
        return 0
      fi

      if ! "${DATABASE_XML_FILE_IS_SPECIFIED}" \
        && ! "${DATABASE_DO_PARSE_DATABASE_FROM_XML}"; then
        set_xml_file "${DEFAULT_XML_FILE}"
        return 0
      fi

      specify_xml_file_prompt || return 1
    }

    function specify_xml_file_prompt
    {
      local -r output="Enter XML filename (leave blank for default): "

      for counter in $( seq 0 2 ); do
          read -r -p "${output}" answer

          if [[ ! -z "${answer}" ]]; then
            is_file "${answer}" || continue
            is_file_not_empty "${answer}" || continue
            set_xml_file "${answer}"
            return 0
          fi

          set_xml_file "${DEFAULT_XML_FILE}"
          return 0
        done

      return 1
    }

    function set_xml_file
    {
      XML_FILE="${1}"
      DATABASE_XML_FILE_IS_SPECIFIED=true
    }

    function set_xml_to_default
    {
      XML_FILE="${DEFAULT_XML_FILE}"
    }
# </functions>

# <code>
  declare_parameters
  unset declare_parameters
# </code