#!/bin/bash sh

#
# Filename:         vfiolib-extras
# Description:      Recommended post-installation setups.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <remarks> Using </remarks>
# <code>
    source bashlib-all
    source vfiolib-iommu
# </code>

# <code>
    # <summary>
    # Install necessary depenencies to setup an audio capture from guest emulated audio device to host audio backend.
    # Installs PulseAudio or ALSA.
    # </summary>
    # <remarks>
    # References:
    #   https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Passing_through_other_devices
    # </remarks>
    # <returns> the exit code </returns>
    function GuestAudioCapture
    {
        function GuestAudioCapture_Main
        {
            # <params>
            local str_dependencies=""
            # </params>

            # <remarks> Install JACK and PipeWire. </remarks>
            case "${str_package_manager}" in
                "apt" )
                    str_dependencies+="pipewire pipewire-jack "
                    ;;

                "pacman" )
                    str_dependencies+="pipewire pipewire-jack "
                    ;;

                * )
                    return 1
            esac

            # <remarks> Include PulseAudio (and QEMU driver if available). </remarks>
            if IsInstalledCommand "pulseaudio" &> /dev/null; then
                case "${str_package_manager}" in
                    "apt" )
                        str_dependencies+="pipewire-pulse "
                        ;;

                    "pacman" )
                        str_dependencies+="pipewire-pulse qemu-audio-pa "
                        ;;

                    * )
                        return 1
                esac

            # <remarks> Fallback to factory driver. </remarks>
            else
                case "${str_package_manager}" in
                    "apt" )
                        str_dependencies+="pipewire-alsa "

                        ;;

                    "pacman" )
                        str_dependencies+="pipewire-alsa "
                        ;;

                    * )
                        return 1
                esac
            fi

            IsInstalledPackage "${str_dependencies}" || InstallPackage "${str_dependencies}"
            return $?
        }

        local str_output="Installing audio drivers..."
        # PrintWait "${str_output}"
        GuestAudioCapture_Main &> /dev/null
        PrintPassOrFail "${str_output}" && bool_is_setup_audio_capture=true || bool_is_setup_audio_capture=false
        return $int_exit_code
    }

    # <summary>
    # Setup an audio loopback service from physical guest audio device (Line-Out) to physical host audio device (Line-In).
    # Requires physical connection between Line-Out and Line-In, and audio backend with JACK support (requires PulseAudio or ALSA).
    # </summary>
    # <returns> the exit code </returns>
    function GuestAudioLoopback
    {
        function GuestAudioLoopback_Main
        {
            # <remarks> Get audio backend. </remarks>
            if ! IsInstalledCommand "pulseaudio"; then
                return $?
            fi

            # <params>
            declare -a arr_file1_current arr_file1_contents=(
                "[Unit]"
                "Description=Load audio loopback module"
                "After=pulseaudio.service"
                ""
                "[Service]"
                "Type=simple"
                "ExecStart=pactl load-module module-loopback"
                "ExecStop=pactl unload-module module-loopback"
                "RemainAfterExit=yes"
                ""
                "[Install]"
                "WantedBy=default.target"
            )

            local str_dir1="/etc/systemd/system/"
            local str_file1="audio-loopback-user.service"
            # </params>

            if ! IsFile "${str_file1}" &> /dev/null || ( ReadFile "arr_file1_current" "${str_file1}" && IsArray "arr_file1_current" && ! AreEqualArrays "arr_file1_current" "arr_file1_contents" ); then
                OverwriteFile "arr_file1_contents" "${str_dir1}${str_file1}" || return $?
            fi

            systemctl daemon-reload || return 1
            systemctl enable "${str_file1}" || return 1
            systemctl restart "${str_file1}" || return 1
            return 0
        }

        local str_output="Creating audio loopback..."
        # PrintWait "${str_output}"
        GuestAudioLoopback_Main &> /dev/null
        PrintPassOrFail "${str_output}"
        return $int_exit_code
    }

    # <summary>
    # Scream: Setup an audio stream from guest to host.
    # Requires virtual network bridge between guest and host, and operating systems Windows 7/8/10/11.
    # </summary>
    # <remarks>
    # References:
    #   https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Passing_audio_from_virtual_machine_to_host_via_Scream
    # </remarks>
    # <returns> the exit code </returns>
    function GuestAudioStream
    {
        function GuestAudioStream_Build
        {
            echo

            # <remarks> Build client </remarks>
            IsFile "build" || ( mkdir build || return 1 )
            cd build || return 1
            cmake .. || return 1
            make || return 1
            return 0
        }

        function GuestAudioStream_Get
        {
            # <params>
            local str_user_name1="duncanthrax"
            local str_repo_name1="scream"
            local str_full_repo1="${str_user_name1}/${str_repo_name1}"
            local str_dependencies=""
            # </params>

            # <remarks> Set dependencies for successful build. </remarks>
            case "${str_package_manager}" in
                "apt" )
                    str_dependencies="cmake "
                    ;;

                "yum" )
                    str_dependencies="cmake "
                    ;;

                * )
                    return $?
                    ;;
            esac

            # <remarks> Set dependencies for available audio backend. </remarks>
            if IsInstalledCommand "pulseaudio"; then
                case "${str_package_manager}" in
                    "apt" )
                        str_dependencies+="libpulse-dev "
                        ;;

                    "yum" )
                        str_dependencies+="pulseaudio-libs-devel "
                        ;;

                   * )
                        return $?
                        ;;
                esac
            elif IsInstalledCommand "pipewire-alsa"; then
                case "${str_package_manager}" in
                    "apt" )
                        str_dependencies+="ibasound2-dev "
                        ;;

                    "yum" )
                        str_dependencies+="alsa-lib-devel "
                        ;;

                    * )
                        return $?
                        ;;
                esac
            else
                return 1
            fi

            # <remarks> Get dependencies. </remarks>
            if ! IsInstalledPackage "${str_dependencies}" &> /dev/null; then
                echo
                InstallPackage "${str_dependencies}" || return $?
                echo
            fi

            GetScriptDir
            echo
            UpdateOrCloneGitRepo "${str_git_dir}" "${str_full_repo1}" "${str_user_name1}" || return $?
            GetScriptDir
            cd "${str_git_dir}${str_full_repo1}" || return $?
            return 0
        }

        function GuestAudioStream_Install
        {
            # <params>
            declare -a arr_file1_current arr_file1_contents arr_file2_contents
            local str_audio_backend_command str_audio_backend_name
            local str_dir1="/etc/systemd/system/"
            local str_file1="audio-loopback-user.service"
            local str_dir2="${str_user_home_dir}/config/systemd/user/"
            local str_file2="scream-ivshmem-pulse.service"
            # </params>

            # <remarks> Get audio backend. </remarks>
            if ! IsInstalledCommand "pulseaudio" && ! IsInstalledCommand "pipewire"; then
                return $?
            elif IsInstalledCommand "pulseaudio" &> /dev/null; then
                str_audio_backend_name="PulseAudio"
            else
                str_audio_backend_name="PipeWire"
            fi

            str_audio_backend_command=$( echo $str_audio_backend_name | tr '[:upper:]' '[:lower:]' )

            arr_file_contents=(
                "[Unit]"
                "Description=${str_audio_backend_name} - QEMU"
                "ConditionUser=!root"
                ""
                "[Socket]"
                "Service=${str_audio_backend_command}-pulse.service"
                "Priority=6"
                "ListenStream=%T/${str_audio_backend_command}-qemu"
                "SocketGroup=libvirt-qemu"
                "SocketMode=0660"
                ""
                "[Install]"
                "RequiredBy=${str_audio_backend_command}-pulse.service"
                "WantedBy=sockets.target"
            )

            declare -a arr_file2_contents=(
                "[Unit]"
                "Description=Scream IVSHMEM pulse receiver"
                "After=${str_audio_backend_command}.service"
                "Wants=${str_audio_backend_command}.service"
                ""
                "[Service]"
                "Type=simple"
                "ExecStartPre=/usr/bin/truncate -s 0 /dev/shm/scream-ivshmem"
                "ExecStartPre=/usr/bin/dd if=/dev/zero of=/dev/shm/scream-ivshmem bs=1M count=2"
                "ExecStart=/usr/bin/scream -m /dev/shm/scream-ivshmem"
                ""
                "[Install]"
                "WantedBy=default.target"
            )

            if ! IsFile "${str_file1}" &> /dev/null || ( ReadFile "arr_file1_current" "${str_file1}" && IsArray "arr_file1_current" && ! AreEqualArrays "arr_file1_current" "arr_file1_contents" ); then
                OverwriteFile "arr_file1_contents" "${str_dir1}${str_file1}" || return $?
            fi

            if ! IsFile "${str_file2}" &> /dev/null || ( ReadFile "arr_file2_current" "${str_file2}" && IsArray "arr_file2_current" && ! AreEqualArrays "arr_file2_current" "arr_file2_contents" ); then
                OverwriteFile "arr_file2_contents" "${str_dir2}${str_file2}" || return $?
            fi

            systemctl daemon-reload || return 1
            systemctl enable "${str_file1}" || return 1
            systemctl restart "${str_file1}" || return 1
            return 0
        }

        if ! GuestAudioCapture; then
            local str_output="Installing Scream...\t"
            (return "${int_code_skipped_operation}")
        else
            local str_output="Updating Scream..."
            # PrintWait "${str_output}"
            GuestAudioStream_Get &> /dev/null
            PrintPassOrFail "${str_output}"

            local str_output="Building Scream..."
            # PrintWait "${str_output}"

            if GuestAudioStream_Build; then
                PrintPassOrFail "${str_output}"

                local str_output="Installing Scream...\t"
                # PrintWait "${str_output}"
                GuestAudioStream_Install
            fi
        fi

        PrintPassOrFail "${str_output}" && bool_is_setup_scream=true
        return $int_exit_code
    }

    # <summary>
    # LookingGlass: Setup direct-memory-access of video framebuffer (and audio?) from guest to host.
    # Requires operating systems Windows 7/8/10/11.
    # </summary>
    # <remarks>
    # References:
    #   https://looking-glass.io/docs/B6/install/#client-install
    # </remarks>
    # <returns> the exit code </returns>
    function GuestVideoCapture
    {
        function GuestVideoCapture_Get
        {
            # <params>
            local str_user_name1="gnif"
            local str_repo_name1="LookingGlass"
            local str_full_repo1="${str_user_name1}/${str_repo_name1}"
            local str_dependencies=""
            # </params>

            case "${str_package_manager}" in
                "apt" )
                    str_dependencies="cmake gcc g++ clang libegl-dev libgl-dev libgles-dev libfontconfig-dev libgmp-dev libspice-protocol-dev make nettle-dev pkg-config"
                    ;;

                # "yum" )
                #     local str_package=""
                #     ;;
            esac

            if ! IsInstalledPackage "${str_dependencies}" &> /dev/null; then
                echo
                InstallPackage "${str_dependencies}" || return $?
                echo
            fi

            GetScriptDir
            echo
            UpdateOrCloneGitRepo "${str_git_dir}" "${str_full_repo1}" "${str_user_name1}" || return $?
            GetScriptDir
            cd "${str_git_dir}${str_full_repo1}" || return $?
            return 0
        }

        function GuestVideoCapture_Install
        {
            echo

            # <remarks> Build client </remarks>
            IsFile "client/build" || ( mkdir client/build || return 1 )
            cd client/build || return 1
            cmake ../ || ( git submodule update --init --recursive && cmake ../ ) || return 1
            make || return 1                                                            # TODO: fix here!

            # <remarks> Conclude build as root or user. </remarks>
            if $bool_is_user_root; then
                make install || return 1
            else
                cmake -DCMAKE_INSTALL_PREFIX=~/.local .. && make install
            fi

            return 0
        }

        GuestVideoCapture_Get
        PrintPassOrFail "Updating LookingGlass..."
        GuestVideoCapture_Install
        PrintPassOrFail "Installing LookingGlass..."
        return $int_exit_code
    }

    # <summary>
    # libvirt-hooks: Setup useful Quality-of-life improvements in the form of services and scripts (hooks) for QEMU guest(s).
    # </summary>
    # <returns> the exit code </returns>
    function LibvirtHooks
    {
        function LibvirtHooks_Main
        {
            # <params>
            declare -a arr_file1_current arr_file1_contents=(
                "[Unit]"
                "Description=Preventing sleep while libvirt domain "%i" is running"
                ""
                "[Service]"
                "Type=simple"
                "ExecStart=/usr/bin/systemd-inhibit --what=sleep --why="Libvirt domain \"%i\" is running" --who=%U --mode=block sleep infinity"
            )

            local str_dir1="/etc/systemd/system/"
            local str_file1="libvirt-nosleep@.service"
            # </params>

            if ! IsFile "${str_file1}" &> /dev/null || ( ReadFile "arr_file1_current" "${str_file1}" && IsArray "arr_file1_current" && ! AreEqualArrays "arr_file1_current" "arr_file1_contents" ); then
                OverwriteFile "arr_file1_contents" "${str_dir1}${str_file1}" || return $?
            fi

            systemctl daemon-reload || return 1
            return 0
        }

        local str_output="Installing libvirt-hooks..."
        # PrintWait "${str_output}"
        LibvirtHooks_Main &> /dev/null
        PrintPassOrFail "${str_output}"
        return $int_exit_code
    }

    # TODO: check for existing zram swap file, if occupied or exists, pause setup. ask user to continue or skip.
    # <summary>
    # zramswap: Setup a swap partition in host memory.
    # Reduce swapiness to existing host swap partition(s)/file(s), and reduce chances of memory exhaustion as host over-allocates memory.
    # </summary>
    # <returns> the exit code </returns>
    function RAM_Swapfile
    {
        function RAM_Swapfile_Install
        {
            # <params>
            local str_user_name1="foundObjects"
            local str_repo_name1="zram-swap"
            local str_full_repo1="${str_user_name1}/${str_repo_name1}"
            local str_script_name1="install.sh"
            # </params>

            GetScriptDir || return $?
            echo
            UpdateOrCloneGitRepo "${str_git_dir}" "${str_full_repo1}" "${str_user_name1}" || return $?
            cd "${str_git_dir}${str_full_repo1}" || return $?
            IsFile "${str_script_name1}" || return $?
            bash "${str_script_name1}" || return 1
            GetScriptDir || return $?
            return 0
        }

        function RAM_Swapfile_Modify
        {
            # <params>
            local str_file1="/etc/default/zram-swap"
            local str_match_line1="_zram_fraction="
            local var_find_zram_swap='swapon -v | grep zram'
            local var_disable_zram_swap='swapoff /dev/zram*'
            local var_enable_all_swap='swapon -a'
            local var_restart_daemon='systemctl restart zram-swap'
            declare -a arr_file_contents=( $( cat "${str_file1}" ) )
            # </params>

            # <remarks> Replace matching line with comment of line </remarks>
            for int_key in ${!arr_file_contents[@]}; do
                if [[ "${arr_file_contents[$int_key]}" == *"${str_match_line1}"* ]]; then
                    arr_file_contents[$int_key]="#${arr_file_contents[$int_key]}"
                fi
            done

            if ! IsNum "${int_max_mem}"; then
                local str_output_could_not_parse_memory="${var_prefix_error} Could not parse system memory."
                echo -e "${str_output_could_not_parse_memory}"
                return 1
            fi

            if IsNum "${int_alloc_mem_hugepages}"; then
                declare -i int_usable_mem=$(( ( int_max_mem - int_alloc_mem_hugepages ) / 2 ))
            else
                declare -i int_usable_mem=$(( int_max_mem / 2 ))
            fi

            declare -i int_denominator=$( printf "%.0f" $( echo "scale=2;${int_max_mem}/${int_usable_mem}" | bc ) )

            # <remarks> Round down to nearest even number. </remarks>
            if [[ $( expr $int_denominator % 2 ) -eq 1 ]]; then
                (( int_denominator-- ))
            fi

            # <remarks> Is fraction positive non-zero and not equal to one. </remarks>
            if [[ "${int_denominator}" -gt 1 ]]; then
                local str_fraction="1/${int_denominator}"

                arr_file_contents+=(
                    ""
                    "#"
                    "# Generated by '${str_full_repo_name}'"
                    "#"
                    "# WARNING: Any modifications to this file will be modified by '${str_repo_name}'"
                    "${str_match_line1}\"${str_fraction}\""
                )
            fi

            OverwriteFile "arr_file_contents" "${str_file1}" || return $?
            eval "${var_find_zram_swap}" &> /dev/null && eval "${var_disable_zram_swap}" &> /dev/null
            eval "${var_restart_daemon}" || return $?
            eval "${var_enable_all_swap}" || return $?
            return 0
        }

        RAM_Swapfile_Install
        RAM_Swapfile_Modify &> /dev/null
        PrintPassOrFail "Allocating RAM to swap..."
        return $int_exit_code
    }
# </code>

# <params>
    declare -g str_this_homedir=$( getent passwd "$( whoami )" | cut -d: -f6 )
    declare -g str_git_dir="${str_this_homedir}/source/"
    declare -g str_files_dir="${str_this_homedir}/Downloads/"

    # <remarks> Flag progress of setups </remarks>
    declare -g bool_is_setup_audio_capture=false
    declare -g bool_is_setup_scream=false
# </params>
