#!/bin/bash/env bash

#
# Filename:         vfiolib-calcs
# Description:      Calculate answers and values for setups and usage.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <sources>
    source vfiolib-globals
# </sources>

# <functions>
    # <summary> Public </summary>
        # <summary> Global setters </summary>
            function SetParameters
            {
                # IFS=$'\n'
                declare -g _REGEX_FOR_NUM='^[0-9]+$'

                # <remarks> Pre-setup: Hugepages </remarks>
                declare -g _IS_HUGEPAGES_COUNT_SET=false
                declare -g _IS_HUGEPAGES_SIZE_SET=false
                declare -gi _AVAILABLE_MEMORY=0
                declare -gi _MIN_MEMORY=8

                # <remarks> Parse PCI for VFIO setup </remarks>
                declare -g _GET_IOMMU_GROUP_DEVICE_LIST='ls /sys/kernel/iommu_groups/$_IOMMU_GROUP_ID/devices'
                declare -g _REGEX_DOMAIN_ID='^[0-9A-F][1-9A-F]$'
                declare -ga _IOMMU_GROUP_ID_LIST=( $( ls -1v /sys/kernel/iommu_groups/ | sort -h ) )
                declare -gi _LAST_IOMMU_GROUP_ID="${_IOMMU_GROUP_ID_LIST[-1]}"
                declare -ga _IOMMU_GROUP_ID_LIST_SOME=( )
                # unset IFS
            }

        # <summary> Unnamed </summary>
            function AddSome_IOMMU_GroupsParseList
            {
                local -a _IOMMU_GROUP_ID_LIST_SOME=( )
                local -r _REGEX_FOR_RANGE_OF_NUMS='^[0-9]+[-][0-9]+$'

                if echo "$1" | grep -E -q "$_REGEX_FOR_RANGE_OF_NUMS"; then
                    local -ir _RANGE_START=$( echo "$1" | cut -d '-' -f 1 )
                    local -ir _RANGE_STOP=$( echo "$1" | cut -d '-' -f 2 )
                    Is_IOMMU_Group_ID_Valid "$_RANGE_START" || return 1
                    Is_IOMMU_Group_ID_Valid "$_RANGE_STOP" || return 1
                    _IOMMU_GROUP_ID_LIST_SOME+=( $( seq "$_RANGE_START" "$_RANGE_STOP" ) )

                elif echo "$1" | grep -E -q "$_REGEX_FOR_NUM"; then
                    Is_IOMMU_Group_ID_Valid "$1" || return 1
                    _IOMMU_GROUP_ID_LIST_SOME+=( "$1" )

                else
                    echo -e "$_PREFIX_ERROR Invalid IOMMU group ID(s)."
                    return 1
                fi

                for _IOMMU_GROUP_ID in ${_IOMMU_GROUP_ID_LIST_SOME[@]}; do
                    Is_IOMMU_Group_ID_Valid "$_IOMMU_GROUP_ID" || return 1
                    local -a _DEVICE_LIST=( $( eval "$_GET_IOMMU_GROUP_DEVICE_LIST" ) )
                    local _HAS_EXTERNAL_PCI=false

                    for _DEVICE in ${_DEVICE_LIST[@]}; do
                        local -u _DEVICE_DOMAIN_ID=$( echo "$_DEVICE" | cut -d ':' -f 2 )
                        local -l _DEVICE_CLASS="$( lspci -m -s $_DEVICE $_PARSE_OPTIONS | cut -d '"' -f 2 )"

                        if IsDeviceExternal "$_DEVICE_DOMAIN_ID"; then
                            _HAS_EXTERNAL_PCI=true
                            break
                        fi
                    done

                    if ! "$_HAS_EXTERNAL_PCI"; then
                        echo -e "$_PREFIX_ERROR IOMMU group(s) contains no external PCI devices."
                        return 1
                    fi
                done

                _IOMMU_GROUP_ID_LIST_TO_USE+=( "${_IOMMU_GROUP_ID_LIST_SOME[@]}" )
                SortListOf_IOMMU_Groups
                return 0
            }

            function AddValid_IOMMU_GroupsParseList
            {
                local -a _IOMMU_GROUP_ID_LIST_TEMP=( )

                for _IOMMU_GROUP_ID in ${_IOMMU_GROUP_ID_LIST[@]}; do
                    local -a _DEVICE_LIST=( $( eval "$_GET_IOMMU_GROUP_DEVICE_LIST" ) )
                    local _THIS_IOMMU_GROUP_HAS_EXTERNAL_PCI=false
                    local _THIS_IOMMU_GROUP_HAS_VGA=false

                    for _DEVICE in ${_DEVICE_LIST[@]}; do
                        local -u _DEVICE_DOMAIN_ID=$( echo "$_DEVICE" | cut -d ':' -f 2 )
                        local -l _DEVICE_CLASS="$( lspci -m -s $_DEVICE $_PARSE_OPTIONS | cut -d '"' -f 2 )"

                        if IsDeviceExternal "$_DEVICE_DOMAIN_ID"; then
                            _THIS_IOMMU_GROUP_HAS_EXTERNAL_PCI=true

                            if "$_HAS_ARG_PARSE_IOMMU_SELECT_ALL"; then
                                _IOMMU_GROUP_ID_LIST_TEMP+=( "$_IOMMU_GROUP_ID" )
                            fi

                            if "$_HAS_ARG_PARSE_IOMMU_SELECT_ALL_NON_VGA" \
                                && IsDevice_VGA "$_DEVICE_CLASS"; then
                                _IOMMU_GROUP_ID_LIST_TEMP+=( "$_IOMMU_GROUP_ID" )
                            fi

                            break
                        fi
                    done
                done

                if [[ "${#_IOMMU_GROUP_ID_LIST_TEMP[@]}" -eq 0 ]]; then
                    echo -e "$_PREFIX_ERROR List is empty."
                    return 1
                fi

                _IOMMU_GROUP_ID_LIST_TO_USE+=( "${_IOMMU_GROUP_ID_LIST_TEMP[@]}" )
                SortListOf_IOMMU_Groups
                return 0
            }

            function Does_IOMMU_GroupContain_ExternalVGA
            {
                if ! Is_IOMMU_Group_ID_Valid "$1"; then
                    return 1
                fi

                local -i _IOMMU_GROUP_ID="$1"
                local -a _DEVICE_LIST=( $( eval "$_GET_IOMMU_GROUP_DEVICE_LIST" ) )

                for _DEVICE in ${_DEVICE_LIST[@]}; do
                    local -u _DEVICE_DOMAIN_ID=$( echo "$_DEVICE" | cut -d ':' -f 2 )
                    local -l _DEVICE_CLASS="$( lspci -m -s $_DEVICE $_PARSE_OPTIONS | cut -d '"' -f 2 )"

                    if IsDeviceExternal "$_DEVICE_DOMAIN_ID" \
                        && IsDevice_VGA "$_DEVICE_CLASS"; then
                        return 0
                    fi
                done

                echo -e "$_PREFIX_ERROR Please enter valid external VGA IOMMU group ID."
                return 1
            }

            function GetFreeMemory
            {
                _AVAILABLE_MEMORY=$(( _INT_MAX_MEMORY - _MIN_MEMORY ))
                return 0
            }

            function GetMemoryAllocatedToHugepages
            {
                _HUGEPAGES_ALLOCATED_MEMORY=$(( $_HUGEPAGES_COUNT * $_HUGEPAGES_SIZE_IN_KBIT ))
                return 0
            }

            function GetHugepageByteSize
            {
                local -u _ANSWER="$1"

                case "$_ANSWER" in
                    "1G" | "2M" )
                        _HUGEPAGES_BYTE_SUFFIX="$_ANSWER"
                        _IS_HUGEPAGES_SIZE_SET=true
                        return 0 ;;

                    "" )
                        return 1 ;;

                    * )
                        echo -e "Please a enter valid Hugepages size, '2M' or '1G'."
                        return 1 ;;
                esac
            }

            function GetHugepageCount
            {
                if [[ -z "$1" ]]; then
                    echo -e "$_PREFIX_ERROR Hugepage count is empty."
                    return 1
                fi

                GetHugepageMinAndMaxSizes || return 1

                if ! echo "$1" | grep -E -q "$_REGEX_FOR_NUM" \
                    || [[ "$1" -lt "$_HUGEPAGES_MIN_SIZE" ]] \
                    || [[ "$1" -gt "$_HUGEPAGES_MAX_SIZE" ]]; then
                    echo -e "$_PREFIX_ERROR Please enter a valid Hugepages amount, between $_HUGEPAGES_MIN_SIZE or $_HUGEPAGES_MAX_SIZE."
                    return 1
                fi

                _IS_HUGEPAGES_COUNT_SET=true
                declare -gi _HUGEPAGES_COUNT="$1"
                return 0
            }

            function GetHugepageMinAndMaxSizes
            {
                declare -gi _HUGEPAGES_MAX_SIZE=0
                declare -gi _HUGEPAGES_MAX_SIZE_IN_KBIT=$( cat /proc/meminfo | grep MemTotal | cut -d ":" -f 2 | cut -d "k" -f 1 )
                declare -gi _HUGEPAGES_MIN_SIZE=0
                declare -gi _HUGEPAGES_MIN_SIZE_IN_KBIT=4194304
                declare -gi _HUGEPAGES_SIZE_IN_KBIT=0

                case "$_HUGEPAGES_BYTE_SUFFIX" in
                    "2M" )
                        _HUGEPAGES_SIZE_IN_KBIT=2048
                        _HUGEPAGES_MIN_SIZE=2 ;;

                    "1G" )
                        _HUGEPAGES_SIZE_IN_KBIT=1048576
                        _HUGEPAGES_MIN_SIZE=1 ;;

                    * )
                        echo -e "$_PREFIX_ERROR Failed to calculate minimum or maximum values for Hugepages."
                        return 1 ;;
                esac

                _HUGEPAGES_MAX_SIZE=$(( "$_HUGEPAGES_MAX_SIZE_IN_KBIT" - "$_HUGEPAGES_MIN_SIZE_IN_KBIT" ))
                _HUGEPAGES_MAX_SIZE=$(( "$_HUGEPAGES_MAX_SIZE" / "$_HUGEPAGES_SIZE_IN_KBIT" ))
                return 0
            }

            function Get_IOMMU_GroupList
            {
                declare -ga _IOMMU_GROUP_ID_LIST_TO_USE=( )
            }

            function Get_Preferred_IOMMU_Group_For_Multiboot
            {
                declare -gi _MULTIBOOT_PREFERRED_IOMMU_GROUP_ID="$1"
                _EXECUTE_VFIO_SETUP_MULTIBOOT_PREFER_VALUE=true
                return 0
            }

            function Get_ZRAM_SwapSize
            {
                IsHostMemorySufficientForZramSwap || return 1

                case "$1" in
                    *"/"* )
                        local -i _NUMERATOR=$( echo $1 | cut -d '/' -f1 )
                        local -i _DENOMINATOR=$( echo $1 | cut -d '/' -f2 ) ;;

                    "default" )
                        _HAS_ARG_ZRAM_SWAP_DEFAULTS=true
                        return 0 ;;

                    * )
                        echo -e "$_PREFIX_ERROR Not a fraction."
                        return 1 ;;
                esac

                if ! [[ "$_NUMERATOR" =~ ^[0-9]+$ ]] \
                    || ! [[ "$_DENOMINATOR" =~ ^[0-9]+$ ]]; then
                    echo -e "$_PREFIX_ERROR Values are not numbers."
                    return 1
                fi

                if [[ "$_NUMERATOR" -lt "$_DENOMINATOR" ]] || [[ "$_DENOMINATOR" -gt 1 ]]; then
                    declare -g _ARGS_FOR_ZRAM_SWAP_FRACTION="$1"
                    _HAS_ARG_ZRAM_SWAP_SET_FRACTION=true
                    return 0

                elif [[ "$_DENOMINATOR" -eq 0 ]]; then
                    return 1

                else
                    echo -e "$_PREFIX_ERROR Invalid fraction."
                fi

                return 1
            }

            function IsHostMemorySufficientForHugepages
            {
                GetFreeMemory

                if [[ "$_AVAILABLE_MEMORY" -le 0 ]]; then
                    echo -e "$_PREFIX_ERROR Insufficient Host memory for Hugepages."
                    return 1
                fi

                return 0
            }

            function IsHostMemorySufficientForZramSwap
            {
                GetFreeMemory

                if "$_IS_HUGEPAGES_SETUP"; then
                    GetMemoryAllocatedToHugepages || return 1
                    _AVAILABLE_MEMORY=$(( _AVAILABLE_MEMORY - _HUGEPAGES_ALLOCATED_MEMORY ))
                fi

                if [[ "$_AVAILABLE_MEMORY" -le 0 ]]; then
                    echo -e "$_PREFIX_ERROR Insufficient Host memory for zram-swap."
                    return 1
                fi

                return 0
            }

            function IsDeviceExternal
            {
                if ! echo "$1" | grep -E -q "$_REGEX_DOMAIN_ID"; then
                    return 1
                fi

                return 0
            }

            function IsDevice_VGA
            {
                local -l _CLASS="$1"

                case "$_CLASS" in
                    *"vga"* | *"graphic"* )
                        return 0 ;;
                esac

                return 1
            }

            function Is_IOMMU_Group_ID_Valid
            {
                if [[ -z "$1" ]] \
                    || [[ "$1" -lt 0 ]] \
                    || [[ "$1" -gt "$_LAST_IOMMU_GROUP_ID" ]]; then
                    echo -e "$_PREFIX_ERROR Please enter valid IOMMU group ID(s), between 0 and $_LAST_IOMMU_GROUP_ID."
                    return 1
                fi

                return 0
            }

            function SortListOf_IOMMU_Groups
            {
                IFS=$'\n'
                _IOMMU_GROUP_ID_LIST_TO_USE=( $( sort -hu <<<"${_IOMMU_GROUP_ID_LIST_TO_USE[*]}" ) )
                unset IFS
                return 0
            }
# </functions>