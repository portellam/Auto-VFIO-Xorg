#!/bin/bash sh

#
# Filename:         vfiolib-iommu
# Description:      Parse and select IOMMU groups.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <code>
    # <summary> Is Virtualization enabled on the current system. If true, pass. </summary>
    function IsEnabled_IOMMU
    {
        if ! compgen -G "/sys/kernel/iommu_groups/*/devices/*"; then
            echo -e "$_PREFIX_ERROR System does not support Virtualization."
            return 1
        fi
    }

    # <summary>
    # Parse IOMMU groups for all relevant information.
    # If a parse fails, attempt again another way. If all parses fail, fail.
    # </summary>
    function Parse_IOMMU
    {
        function Parse_IOMMU_Main
        {
            function Parse_IOMMU_Are_Inequal_Lists_Sizes
            {
                local bool_are_inequal_lists=false
                [ ${#_IOMMU_LIST[@]} -eq ${#arr_class[@]} ] || bool_are_inequal_lists=true
                # [ ${#_IOMMU_LIST[@]} -eq ${#arr_device_ID[@]" ] || bool_are_inequal_lists=true
                [ ${#_IOMMU_LIST[@]} -eq ${#arr_device_name[@]} ] || bool_are_inequal_lists=true
                [ ${#_IOMMU_LIST[@]} -eq ${#_DRIVER_LIST[@]} ] || bool_are_inequal_lists=true
                [ ${#_IOMMU_LIST[@]} -eq ${#_HWID_LIST[@]} ] || bool_are_inequal_lists=true
                # [ ${#_IOMMU_LIST[@]} -eq ${#arr_vendor_ID[@]} ] || bool_are_inequal_lists=true
                [ ${#_IOMMU_LIST[@]} -eq ${#arr_vendor_name[@]} ] || bool_are_inequal_lists=true

                if $bool_are_inequal_lists; then
                    echo -e $str_output_lists_inequal
                    return 1
                fi

                return 0
            }

            function Parse_IOMMU_Are_Not_Empty_Lists
            {
                # <remarks> If any list is empty, fail. </remarks>
                local bool_is_empty_list=false
                IsString ${arr_class[@]} &> /dev/null || bool_is_empty_list=true
                # IsString "${arr_device_ID[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${arr_device_name[@]} &> /dev/null ||  bool_is_empty_list=true
                IsString ${_DRIVER_LIST[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${_HWID_LIST[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${_IOMMU_LIST[@]} &> /dev/null || bool_is_empty_list=true
                # IsString ${arr_vendor_ID[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${arr_vendor_name[@]} &> /dev/null || bool_is_empty_list=true

                if $bool_is_empty_list; then
                    echo -e $str_output_list_empty
                    return 1
                fi

                return 0
            }

            function Parse_IOMMU_Save_Lists
            {
                # <remarks> Save to lists each device's information. Lists should be of the same-size. </remarks>
                for var_device in ${arr_devices[@]}; do
                    local str_class=$( eval "${var_parse_name_ID}" )
                    str_class=$( echo -e "${str_class}" | grep -i "Class:" | cut -d ':' -f 2 | grep -oP "^\t\K.*" )
                    local str_device_name=$( eval "${var_parse_name_ID}" | grep -i "Device:" | grep -Eiv "SDevice:|${var_device}" | cut -d ':' -f 2 | uniq | grep -oP "^\t\K.*" )
                    local str_driver=$( eval "${var_parse_all_ID}" | grep -i "Driver:" | awk '{print $2}' | uniq )
                    local str_IOMMU=$( eval "${var_parse_all_ID}"| grep -i "IOMMUGroup:" | awk '{print $2}' | uniq )
                    local str_vendor_name=$( eval "${var_parse_name_ID}" | grep -i "Vendor:" | grep -Eiv "SVendor:" | cut -d ':' -f 2 | uniq | grep -oP "^\t\K.*" )
                    local str_HWID=$( lspci -n -s "${var_device}" | cut -d ' ' -f 3 )

                    case "${str_driver}" in
                         # <remarks> Match invalid input, and save as known null value. </remarks>
                        "" )
                            str_driver="N/A"
                            ;;

                        # <remarks> If system is setup for VFIO, exit. </remarks>
                        "vfio-pci" )
                            echo -e $str_output_is_setup_VFIO
                            return 1
                            ;;
                    esac

                    arr_class+=( "${str_class}" )
                    arr_device_name+=( "${str_device_name}" )
                    _DRIVER_LIST+=( "${str_driver}" )
                    _HWID_LIST+=( "${str_HWID}" )
                    _IOMMU_LIST+=( "${str_IOMMU}" )
                    arr_slot_ID+=( "${var_device}" )
                    arr_vendor_name+=( "${str_vendor_name}" )
                done

                return 0
            }

            function Parse_IOMMU_Set_Operation
            {
                # <remarks> Set commands for each parse type. </remarks>
                case $var_opt in

                    # <remarks> If parsing file and file does not exist, recursive call to parse internet. </remarks>
                    $str_opt_parse_file )
                        str_output=$str_output_parse_file
                        var_parse_all_ID+=" ${var_parse_args_file}"
                        var_parse_name_ID+=" ${var_parse_args_file}"
                        var_parse_slot_ID+=" ${var_parse_args_file}"
                        var_parse_quotes+=" ${var_parse_args_file}"
                        # PrintWait "${str_output}"
                        IsFile $str_filename_parse_IOMMU &> /dev/null
                        return $?
                        ;;

                    # <remarks> If internet is not available, exit. </remarks>
                    $str_opt_parse_internet )
                        str_output=$str_output_parse_internet
                        local var_parse_all_ID+=" ${var_parse_args_online}"
                        local var_parse_name_ID+=" ${var_parse_args_online}"
                        local var_parse_slot_ID+=" ${var_parse_args_online}"
                        local var_parse_quotes+=" ${var_parse_args_online}"
                        # PrintWait "${str_output}"
                        GetInternetStatus &> /dev/null
                        return $?
                        ;;

                    $str_output_parse_local | * )
                        str_output=$str_output_parse_local
                        # PrintWait "${str_output}"
                        ;;
                esac

                return 0
            }

            # <params>
                # <remarks> Save input params </remarks>
                var_opt=$1

                # <remarks> Output statements </remarks>
                local str_output_lists_inequal="${var_prefix_error} System PCI lists' sizes are inequal."
                local str_output_list_empty="${var_prefix_error} One or more system PCI lists are empty."
                local str_output_parse_file="Parsing PCI from file..."
                local str_output_parse_internet="Parsing PCI from Internet..."
                local str_output_parse_local="Parsing PCI from system..."
                local str_output_is_setup_VFIO="${var_prefix_error} Found existing VFIO setup."

                # <remarks> Declare lists </remarks>
                declare -ag arr_class arr_device_ID arr_device_name _DRIVER_LIST _HWID_LIST _IOMMU_LIST arr_slot_ID arr_vendor_ID arr_vendor_name

                # <remarks> Set commands </remarks>
                local var_parse='lspci -k -mm'
                local var_parse_args_file='-F "${str_filename_parse_IOMMU}"'
                local var_parse_args_online='-q'
                local var_parse_args_nums='-n'
                local var_parse_args_slot_ID='-s ${var_device}'
                local var_parse_args_verbose='-v'
                local var_parse_to_file='lspci -x >> "${str_filename_parse_IOMMU}"'
                local var_parse_all_ID="${var_parse} ${var_parse_args_nums} ${var_parse_args_verbose} ${var_parse_args_slot_ID}"
                local var_parse_HWID="${var_parse} ${var_parse_args_nums} ${var_parse_args_slot_ID}"
                local var_parse_name_ID="${var_parse} ${var_parse_args_verbose} ${var_parse_args_slot_ID}"
                local var_parse_slot_ID="${var_parse}"
                local var_parse_quotes="${var_parse} ${var_parse_args_nums}"
            # </params>

            # <remarks> Set commands for each parse type. </remarks>
            Parse_IOMMU_Set_Operation || return $?

            # <remarks> Get all devices from system. </remarks>
            declare -a arr_devices=( $( eval ${var_parse_slot_ID} | awk '{print $1}' ) )
            Parse_IOMMU_Save_Lists || return $?
            Parse_IOMMU_Are_Not_Empty_Lists || return $?
            Parse_IOMMU_Are_Inequal_Lists_Sizes || return $?

            # <remarks> Save output to file. </remarks>
            if [[ $? -eq 0 && $var_opt != $str_opt_parse_file ]]; then
                IsFile $str_filename_parse_IOMMU &> /dev/null && eval "${var_parse_to_file}"
            fi

            return 0
        }

        # <params>
            local str_output=""

            # <remarks> Set parse options </remarks>
            local str_opt_parse_file="FILE"
            local str_opt_parse_internet="DNS"
            local str_opt_parse_local="LOCAL"

            # <remarks> Save input params </remarks>
            local var_opt="${1}"
            local str_filename_parse_IOMMU="${2}"
        # </params>

        # <remarks> If an operation fails, try another. </remarks>
        case $var_opt in
            $str_opt_parse_internet )
                Parse_IOMMU_Main "${str_opt_parse_internet}" "${str_filename_parse_IOMMU}"
                ;;

            $str_opt_parse_file )
                Parse_IOMMU_Main "${str_opt_parse_file}" "${str_filename_parse_IOMMU}" || Parse_IOMMU_Main "${str_opt_parse_internet}" "${str_filename_parse_IOMMU}"
                ;;

            $str_opt_parse_local | * )
                Parse_IOMMU_Main "${str_opt_parse_local}" "${str_filename_parse_IOMMU}" || Parse_IOMMU_Main "${str_opt_parse_file}" "${str_filename_parse_IOMMU}" || Parse_IOMMU_Main "${str_opt_parse_internet}" "${str_filename_parse_IOMMU}"
                ;;
        esac

        PrintPassOrFail "${str_output}"
        return $int_exit_code
    }

    # <summary> Select IOMMU groups for VFIO setup. </summary>
    function Select_IOMMU
    {
        # <summary> Print all relevant information about the IOMMU group. </summary>
        function Select_IOMMU_Match_IOMMU_AndClass
        {
            # <params>
            local str_class="${arr_class[$int_key]}"
            local str_device_name="${arr_device_name[$int_key]}"
            local str_driver="${_DRIVER_LIST[$int_key]}"
            local str_HWID="${_HWID_LIST[$int_key]}"
            local str_slot_ID="${arr_slot_ID[$int_key]}"
            local str_vendor_name="${arr_vendor_name[$int_key]}"
            local str_domain_ID=$( echo "${str_slot_ID}" | cut -d ':' -f 1 )

                # <remarks> Regex: check if value is decimal or hexadecimal and greater than zero </remarks>
                local str_regex='[a-fA-F1-9]'

                # <remarks> Output statement </remarks>
                declare -a arr_output1=(
                    "Slot ID:\t'${str_slot_ID}'"
                    "Vendor name:\t'${str_vendor_name}'"
                    "Device name:\t'${str_device_name}'"
                    "Class/Type:\t'${str_class}'"
                    "Hardware ID:\t'${str_HWID}'"
                    "Kernel driver:\t'${str_driver}'"
                )
            # </params>

            # <remarks> Match IOMMU group </remarks>
            if [[ $int_IOMMU -eq $var_IOMMU ]]; then

                # <remarks> External PCI devices have domain IDs of '01' or greater. </remarks>
                if [[ $str_domain_ID =~ ${str_regex} ]]; then
                    bool_IOMMU_has_external_domain=true
                fi

                local str_class=$( echo "${arr_class[$int_key]}" | tr '[:upper:]' '[:lower:]' )
                PrintArray "arr_output1"

                # <remarks> Match Class </remarks>
                case $str_class in
                    *"graphics"* | *"vga"* | *"video"* )
                        bool_IOMMU_has_VGA=true
                        ;;

                    *"usb"* )
                        bool_IOMMU_has_USB=true
                        bool_IOMMU_PCISTUB=true
                        ;;
                esac
            fi

            return 0
        }

        function Select_IOMMU_Group
        {
            if $bool_IOMMU_has_USB; then
                _PCISTUB_IOMMU_LIST+=( "${var_IOMMU}" )
            else
                _PCISTUB_IOMMU_LIST+=( "" )
            fi

            if $bool_IOMMU_has_VGA; then
                _VFIOPCI_IOMMU_LIST+=( "" )
                _VGA_VFIOPCI_IOMMU_LIST+=( "${var_IOMMU}" )
            else
                _VFIOPCI_IOMMU_LIST+=( "${var_IOMMU}" )
                _VGA_VFIOPCI_IOMMU_LIST+=( "" )
            fi

            return 0
        }

        function Skip_IOMMU_Group
        {
            _VFIOPCI_IOMMU_LIST+=( "" )
            _PCISTUB_IOMMU_LIST+=( "" )
            _VGA_VFIOPCI_IOMMU_LIST+=( "" )
            echo -e "Skipped IOMMU group '${var_IOMMU}'."
            return 0
        }

        # <summary> Ask user to Select/Skip IOMMU group. </summary>
        function Select_IOMMU_Prompt
        {
            # <remarks> Append to list a valid array or empty value. </remarks>
            if $bool_IOMMU_has_external_domain && $bool_select_all_IOMMU; then
                Select_IOMMU_Group
                return 0
            fi

            if $bool_IOMMU_has_external_domain && ! $bool_select_all_IOMMU && ReadInput "Select IOMMU group '${var_IOMMU}'?"; then
                Select_IOMMU_Group
            fi

            if ! $bool_IOMMU_has_external_domain; then
                Skip_IOMMU_Group
            fi

            return 0
        }

        # <summary> Parse VFIO list for drivers and hardware IDs. </summary>
        function Get_IOMMU_Lists
        {
            for int_key in ${!_IOMMU_LIST[@]}; do
                local str_slot_ID="${arr_slot_ID[$int_key]}"
                local str_domain_ID=$( echo "${str_slot_ID}" | cut -d ':' -f 1 )
                declare -i int_domain_ID="${str_domain_ID##*0}"
                local str_driver=""
                local str_HWID=""
                local var_IOMMU=""

                if IsNum "${int_domain_ID}" &> /dev/null && [[ "${int_domain_ID}" -gt 0 ]]; then
                    local str_driver="${_DRIVER_LIST[$int_key]}"
                    local str_HWID="${_HWID_LIST[$int_key]}"
                    local var_IOMMU="${_IOMMU_LIST[$int_key]}"
                fi

                for var_driver_to_ignore in ${_DRIVER_LISTs_to_ignore[@]}; do
                    if [[ "${var_driver_to_ignore}" == "${str_driver}" ]]; then
                        str_driver=""
                        break
                    fi
                done

                # <remarks> Check if any IOMMU group exists in a given list. </remarks>
                if FindLineInArray "_PCISTUB_IOMMU_LIST" "${var_IOMMU}" &> /dev/null; then
                    _HWID_LIST_PCISTUB+=( "${str_HWID}" )
                fi

                if FindLineInArray "_VFIOPCI_IOMMU_LIST" "${var_IOMMU}" &> /dev/null; then
                    _HWID_LIST_VFIOPCI+=( "${str_HWID}" )
                fi

                if FindLineInArray "_VGA_VFIOPCI_IOMMU_LIST" "${var_IOMMU}" &> /dev/null; then
                    _DRIVER_LISTs_VFIOPCI_with_VGA+=( "${str_driver}" )
                    _HWID_LIST_VFIOPCI_with_VGA+=( "${str_HWID}" )
                fi

                if FindLineInArray "_PCISTUB_IOMMU_LIST" "${var_IOMMU}" &> /dev/null || FindLineInArray "_VFIOPCI_IOMMU_LIST" "${var_IOMMU}" &> /dev/null || FindLineInArray "_VGA_VFIOPCI_IOMMU_LIST" "${var_IOMMU}" &> /dev/null; then
                    _DRIVER_LISTs_VFIOPCI+=( "${str_driver}" )
                fi
            done

            if ! IsArray "_DRIVER_LISTs_VFIOPCI" &> /dev/null && ! IsArray "_DRIVER_LISTs_VFIOPCI_with_VGA" &> /dev/null && ! IsArray "_HWID_LIST_PCISTUB" &> /dev/null && ! IsArray "_HWID_LIST_VFIOPCI" &> /dev/null && ! IsArray "_DRIVER_LISTs_VFIOPCI_with_VGA" &> /dev/null; then
                return $?
            fi

            return 0
        }

        function Set_IOMMU_Lists
        {
            # <remarks> Remove duplicate entries. </remarks>
            for int_key in ${!_DRIVER_LISTs_VFIOPCI[@]}; do
                local var_driver="${_DRIVER_LISTs_VFIOPCI[$int_key]}"

                if FindLineInArray "_DRIVER_LISTs_VFIOPCI" "${var_driver}" &> /dev/null; then
                    _DRIVER_LISTs_VFIOPCI[int_key]=""
                fi
            done

            # <remarks> Remove duplicate entries. </remarks>
            for int_key in ${!_HWID_LIST_VFIOPCI[@]}; do
                local var_HWID="${_HWID_LIST_VFIOPCI[$int_key]}"

                if FindLineInArray "_HWID_LIST_PCISTUB" "${var_HWID}" &> /dev/null || FindLineInArray "_HWID_LIST_VFIOPCI_with_VGA" "${var_HWID}" &> /dev/null; then
                    _HWID_LIST_VFIOPCI[int_key]=""
                fi
            done

            # <remarks> Remove duplicate entries. </remarks>
            for int_key in ${!_HWID_LIST_PCISTUB[@]}; do
                local var_HWID="${_HWID_LIST_VFIOPCI[$int_key]}"

                if FindLineInArray "_HWID_LIST_VFIOPCI_with_VGA" "${var_HWID}" &> /dev/null; then
                    _HWID_LIST_PCISTUB[int_key]=""
                fi
            done

            # NOTE: possibly breaking here, because I just revised the array functions (undeclared vars, should declare.)

            TrimArray "_DRIVER_LISTs_VFIOPCI" || return $?
            TrimArray "_DRIVER_LISTs_VFIOPCI_with_VGA" || return $?
            TrimArray "_HWID_LIST_PCISTUB" || return $?
            TrimArray "_HWID_LIST_VFIOPCI" || return $?
            TrimArray "_HWID_LIST_VFIOPCI_with_VGA" || return $?

            SortArray "_DRIVER_LISTs_VFIOPCI"
            SortArray "_DRIVER_LISTs_VFIOPCI_with_VGA"
            SortArray "_HWID_LIST_PCISTUB"
            SortArray "_HWID_LIST_VFIOPCI"
            SortArray "_HWID_LIST_VFIOPCI_with_VGA"

            PrintArray "_DRIVER_LISTs_VFIOPCI"
            PrintArray "_DRIVER_LISTs_VFIOPCI_with_VGA"
            PrintArray "_HWID_LIST_PCISTUB"
            PrintArray "_HWID_LIST_VFIOPCI"
            PrintArray "_HWID_LIST_VFIOPCI_with_VGA"

            exit 0
            return 0
        }

        # <params>
        local str_output="Reviewing IOMMU groups..."
        local int_IOMMU_max=$( basename $( ls -1v /sys/kernel/iommu_groups/ | sort -hr | head -n1 ) )
        local var_get_IOMMU='seq 0 "${int_IOMMU_max}"'
        declare -a arr_this_IOMMU=( $( eval "${var_get_IOMMU}" ) )
        # </params>

        # PrintWait "${str_output}"

        for var_IOMMU in ${arr_this_IOMMU[@]}; do
            local bool_IOMMU_has_external_domain=false
            local bool_IOMMU_PCISTUB=false
            # local bool_IOMMU_VFIOPCI=false
            local bool_IOMMU_has_USB=false
            local bool_IOMMU_has_VGA=false

            for int_key in ${!_IOMMU_LIST[@]}; do
                declare -i int_IOMMU="${_IOMMU_LIST[$int_key]}"
                Select_IOMMU_Match_IOMMU_AndClass
            done

            Select_IOMMU_Prompt
        done

        # <remarks> Check if list is empty </remarks>
        IsArray "_VFIOPCI_IOMMU_LIST" &> /dev/null && bool_VFIO_has_IOMMU=true && Get_IOMMU_Lists && Set_IOMMU_Lists
        PrintPassOrFail "${str_output}"
        return $int_exit_code
    }
# </code>

# <params>
declare -ag _DRIVER_LISTs_VFIOPCI _PCISTUB_IOMMU_LIST _VFIOPCI_IOMMU_LIST _VGA_VFIOPCI_IOMMU_LIST _HWID_LIST_PCISTUB _HWID_LIST_VFIOPCI _HWID_LIST_VFIOPCI_with_VGA
declare -g bool_VFIO_has_IOMMU=false

    # <remarks> Known kernel drivers to ignore; drivers that cause issues when binded to vfio-pci/pci-stub. </remarks>
    declare -ag _DRIVER_LISTs_to_ignore=(
        "snd_hda_intel"
    )
# </params>