#!/bin/bash sh

#
# Filename:         vfiolib-iommu
# Description:      Parse and select IOMMU groups.
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <remarks> Using </remarks>
# <code>
    source bashlib-all
# </code>

# <code>
    # <summary> Is Virtualization enabled on the current system. If true, pass. </summary>
    function IsEnabled_IOMMU
    {
        if ! compgen -G "/sys/kernel/iommu_groups/*/devices/*";
            false
        fi

        PrintPassOrFail "Validating Virtualization..."
        return $int_exit_code
    }

    # <summary> Parse IOMMU groups for all relevant information. If a parse fails, attempt again another way. If all parses fail, fail. </summary>
    function Parse_IOMMU
    {
        function Parse_IOMMU_Main
        {
            function Parse_IOMMU_Are_Inequal_Lists_Sizes
            {
                local bool_are_inequal_lists=false
                [ ${#arr_IOMMU[@]} -eq ${#arr_class[@]} ] || bool_are_inequal_lists=true
                # [ ${#arr_IOMMU[@]} -eq ${#arr_device_ID[@]" ] || bool_are_inequal_lists=true
                [ ${#arr_IOMMU[@]} -eq ${#arr_device_name[@]} ] || bool_are_inequal_lists=true
                [ ${#arr_IOMMU[@]} -eq ${#arr_driver[@]} ] || bool_are_inequal_lists=true
                [ ${#arr_IOMMU[@]} -eq ${#arr_hardware_ID[@]} ] || bool_are_inequal_lists=true
                # [ ${#arr_IOMMU[@]} -eq ${#arr_vendor_ID[@]} ] || bool_are_inequal_lists=true
                [ ${#arr_IOMMU[@]} -eq ${#arr_vendor_name[@]} ] || bool_are_inequal_lists=true

                if $bool_are_inequal_lists; then
                    echo -e $str_output_lists_inequal
                    return 1
                fi

                return 0
            }

            function Parse_IOMMU_Are_Not_Empty_Lists
            {
                # <remarks> If any list is empty, fail. </remarks>
                local bool_is_empty_list=false
                IsString ${arr_class[@]} &> /dev/null || bool_is_empty_list=true
                # IsString "${arr_device_ID[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${arr_device_name[@]} &> /dev/null ||  bool_is_empty_list=true
                IsString ${arr_driver[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${arr_hardware_ID[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${arr_IOMMU[@]} &> /dev/null || bool_is_empty_list=true
                # IsString ${arr_vendor_ID[@]} &> /dev/null || bool_is_empty_list=true
                IsString ${arr_vendor_name[@]} &> /dev/null || bool_is_empty_list=true

                if $bool_is_empty_list; then
                    echo -e $str_output_list_empty
                    return 1
                fi

                return 0
            }

            function Parse_IOMMU_Save_Lists
            {
                # <remarks> Save to lists each device's information. Lists should be of the same-size. </remarks>
                for str_slot_ID in ${arr_devices[@]}; do
                    local str_class=$( eval "${var_parse_name_ID}" )
                    str_class=$( echo -e "${str_class}" | grep -i "Class:" | cut -d ':' -f 2 | grep -oP "^\t\K.*" )
                    local str_device_ID=$( eval "${var_parse_quotes}" | cut -d '"' -f 6 | uniq )
                    local str_device_name=$( eval "${var_parse_name_ID}" | grep -i "Device:" | grep -Eiv "SDevice:|${str_slot_ID}" | cut -d ':' -f 2 | uniq | grep -oP "^\t\K.*" )
                    local str_driver=$( eval "${var_parse_all_ID}" | grep -i "Driver:" | awk '{print $2}' | uniq )
                    local str_IOMMU=$( eval "${var_parse_all_ID}"| grep -i "IOMMUGroup:" | awk '{print $2}' | uniq )
                    local str_vendor_name=$( eval "${var_parse_name_ID}" | grep -i "Vendor:" | grep -Eiv "SVendor:" | cut -d ':' -f 2 | uniq | grep -oP "^\t\K.*" )
                    local str_vendor_ID=$( eval "${var_parse_quotes}" | cut -d '"' -f 4 | uniq )
                    local str_hardware_ID="${str_vendor_ID}:${str_device_ID}"

                    # <remarks> If system is setup for VFIO, exit. </remarks>
                    if [[ $str_driver == "vfio-pci" ]]; then
                        echo -e $str_output_is_setup_VFIO
                        return 1
                    fi

                    # <remarks> Match invalid input, and save as known null value. </remarks>
                    if ! IsString $str_driver &> /dev/null; then
                        local str_driver="N/A"
                    fi

                    arr_class+=( "${str_class}" )
                    arr_device_name+=( "${str_device_name}" )
                    arr_driver+=( "${str_driver}" )
                    arr_hardware_ID+=( "${str_hardware_ID}" )
                    arr_IOMMU+=( "${str_IOMMU}" )
                    arr_slot_ID+=( "${str_slot_ID}" )
                    arr_vendor_name+=( "${str_vendor_name}" )
                done

                return 0
            }

            function Parse_IOMMU_Set_Operation
            {
                # <remarks> Set commands for each parse type. </remarks>
                case $var_opt in

                    # <remarks> If parsing file and file does not exist, recursive call to parse internet. </remarks>
                    $str_opt_parse_file )
                        str_output=$str_output_parse_file
                        var_parse_all_ID+=$var_parse_args_file
                        var_parse_name_ID+=$var_parse_args_file
                        var_parse_slot_ID+=$var_parse_args_file
                        var_parse_quotes+=$var_parse_args_file
                        IsFile $str_file &> /dev/null
                        return $?
                        ;;

                    # <remarks> If internet is not available, exit. </remarks>
                    $str_opt_parse_internet )
                        str_output=$str_output_parse_internet
                        local var_parse_all_ID+=$var_parse_args_online
                        local var_parse_name_ID+=$var_parse_args_online
                        local var_parse_slot_ID+=$var_parse_args_online
                        local var_parse_quotes+=$var_parse_args_online
                        GetInternetStatus
                        return $?
                        ;;

                    $str_output_parse_local | * )
                        str_output=$str_output_parse_local
                        ;;
                esac

                return 0
            }

            # <params>
                # <remarks> Save input params </remarks>
                var_opt=$1

                # <remarks> Output statements </remarks>
                local str_output_lists_inequal="${var_prefix_error} System PCI lists' sizes are inequal."
                local str_output_list_empty="${var_prefix_error} One or more system PCI lists are empty."
                local str_output_parse_file="Parsing PCI from file..."
                local str_output_parse_internet="Parsing PCI from Internet..."
                local str_output_parse_local="Parsing PCI from system..."
                local str_output_is_setup_VFIO="${var_prefix_error} Found existing VFIO setup."

                # <remarks> Declare lists </remarks>
                declare -ag arr_class arr_device_ID arr_device_name arr_driver arr_hardware_ID arr_IOMMU arr_slot_ID arr_vendor_ID arr_vendor_name

                # <remarks> Set commands </remarks>
                local var_parse='lspci -k -mm'
                local var_parse_args_file='-F "${str_file}"'
                local var_parse_args_online='-q'
                local var_parse_args_nums='-n'
                local var_parse_args_slot_ID='-s ${str_slot_ID}'
                local var_parse_args_verbose='-v'
                local var_parse_to_file='lspci -x >> "${str_file}"'
                local var_parse_all_ID="${var_parse} ${var_parse_args_nums} ${var_parse_args_verbose} ${var_parse_args_slot_ID}"
                local var_parse_name_ID="${var_parse} ${var_parse_args_verbose} ${var_parse_args_slot_ID}"
                local var_parse_slot_ID="${var_parse}"
                local var_parse_quotes="${var_parse} ${var_parse_args_nums}"
            # </params>

            # <remarks> Set commands for each parse type. </remarks>
            Parse_IOMMU_Set_Operation || return $?

            # <remarks> Get all devices from system. </remarks>
            declare -a arr_devices=( $( eval ${var_parse_slot_ID} | awk '{print $1}' ) )
            Parse_IOMMU_Save_Lists || return $?
            Parse_IOMMU_Are_Not_Empty_Lists || return $?
            Parse_IOMMU_Are_Inequal_Lists_Sizes || return $?

            # <remarks> Save output to file. </remarks>
            if [[ $? -eq 0 && $var_opt != $str_opt_parse_file ]]; then
                IsFile $str_file &> /dev/null && eval "${var_parse_to_file}"
            fi

            return 0
        }

        # <params>
            local str_output=""

            # <remarks> Set parse options </remarks>
            local str_opt_parse_file="FILE"
            local str_opt_parse_internet="DNS"
            local str_opt_parse_local="LOCAL"

            # <remarks> Save input params </remarks>
            local var_opt="${1}"
            local str_file="${2}"
        # </params>

        # <remarks> If an operation fails, try another. </remarks>
        case $var_opt in
            $str_opt_parse_internet )
                Parse_IOMMU_Main $str_opt_parse_internet $str_file &> /dev/null
                ;;

            $str_opt_parse_file )
                Parse_IOMMU_Main $str_opt_parse_file $str_file &> /dev/null || Parse_IOMMU_Main $str_opt_parse_internet $str_file &> /dev/null
                ;;

            $str_opt_parse_local | * )
                Parse_IOMMU_Main $str_opt_parse_local $str_file &> /dev/null || Parse_IOMMU_Main $str_opt_parse_file $str_file &> /dev/null || Parse_IOMMU_Main $str_opt_parse_internet $str_file &> /dev/null
                ;;
        esac

        PrintPassOrFail $str_output
        return $int_exit_code
    }

    # <summary> Select IOMMU groups for VFIO setup. </summary>
    function Select_IOMMU
    {
        # <summary> Print all relevant information about the IOMMU group. </summary>
        function Select_IOMMU_Match_IOMMU_AndClass
        {
            # <params>
            local str_class="${arr_class[$int_key]}"
            local str_device_name="${arr_device_name[$int_key]}"
            local str_driver="${arr_driver[$int_key]}"
            local str_hardware_ID="${arr_hardware_ID[$int_key]}"
            local str_slot_ID="${arr_slot_ID[$int_key]}"
            local str_vendor_name="${arr_vendor_name[$int_key]}"
            local str_domain_ID=$( echo "${str_slot_ID}" | cut -d ':' -f 1 )

                # <remarks> Regex: check if value is decimal or hexadecimal and greater than zero </remarks>
                local str_regex='[a-fA-F1-9]'

                # <remarks> Output statement </remarks>
                declare -ar arr_output1=(
                    "Slot ID:\t'${str_slot_ID}'"
                    "Vendor name:\t'${str_vendor_name}'"
                    "Device name:\t'${str_device_name}'"
                    "Class/Type:\t'${str_class}'"
                    # "Hardware ID:\t'${str_hardware_ID}'"
                    "Kernel driver:\t'${str_driver}'"
                )
            # </params>

            # <remarks> Match IOMMU group </remarks>
            if [[ $int_IOMMU -eq $int_this_IOMMU_ID ]]; then

                # <remarks> External PCI devices have domain IDs of '01' or greater. </remarks>
                if [[ $str_domain_ID =~ ${str_regex} ]]; then
                    bool_IOMMU_has_external_domain=true
                fi

                local str_class=$( echo "${arr_class[$int_key]}" | tr '[:upper:]' '[:lower:]' )
                PrintArray "arr_output1"

                # <remarks> Match Class </remarks>
                case $str_class in
                    *"graphics"* | *"vga"* | *"video"* )
                        bool_IOMMU_has_VGA=true
                        ;;

                    *"usb"* )
                        bool_IOMMU_has_USB=true
                        bool_IOMMU_PCI_STUB=true
                        ;;
                esac
            fi

            return 0
        }

        function Select_IOMMU_Group
        {
            if $bool_IOMMU_has_USB; then
                arr_IOMMU_PCI_STUB+=( "${int_this_IOMMU_ID}" )
            else
                arr_IOMMU_PCI_STUB+=( "" )
            fi

            if $bool_IOMMU_has_VGA; then
                arr_IOMMU_VFIO_PCI+=( "" )
                arr_IOMMU_VFIO_PCI_with_VGA+=( "${int_this_IOMMU_ID}" )
            else
                arr_IOMMU_VFIO_PCI+=( "${int_this_IOMMU_ID}" )
                arr_IOMMU_VFIO_PCI_with_VGA+=( "" )
            fi

            return 0
        }

        function Skip_IOMMU_Group
        {
            arr_IOMMU_VFIO_PCI+=( "" )
            arr_IOMMU_PCI_STUB+=( "" )
            arr_IOMMU_VFIO_PCI_with_VGA+=( "" )
            echo -e $str_output_skip_select
            return 0
        }

        # <summary> Ask user to Select/Skip IOMMU group. </summary>
        function Select_IOMMU_Prompt
        {
            # <params>
            local str_output_do_select="Select IOMMU group '${int_this_IOMMU_ID}'?"
            local str_output_skip_select="Skipped IOMMU group '${int_this_IOMMU_ID}'."
            # </params>

            # <remarks> Append to list a valid array or empty value. </remarks>
            if $bool_IOMMU_has_external_domain && $bool_select_all_IOMMU; then
                Select_IOMMU_Group
                return 0
            fi

            if $bool_IOMMU_has_external_domain && ReadInput $str_output_do_select; then
                Select_IOMMU_Group
            else
                Skip_IOMMU_Group
            fi

            return 0
        }

        # <summary> Parse VFIO list for drivers and hardware IDs. </summary>
        function Get_IOMMU_Drivers
        {
            for int_key in ${!arr_IOMMU[@]}; do
                local str_driver=${arr_driver[$int_key]}
                local str_hardware_ID=${arr_hardware_ID[$int_key]}
                local str_IOMMU=${arr_IOMMU[$int_key]}

                if FindLineInArray "arr_IOMMU_PCI_STUB" $str_IOMMU || FindLineInArray "arr_IOMMU_VFIO_PCI" $str_IOMMU || FindLineInArray "arr_IOMMU_VFIO_PCI_with_VGA" $str_IOMMU; then
                    arr_drivers_VFIO_PCI+=( "${str_driver}" )
                    arr_hardware_ID_VFIO_PCI+=( "${str_hardware_ID}" )
                fi
            done

            IsArray "arr_drivers_VFIO_PCI" || return $?
            return 0
        }

        # <params>
        local str_output="Reviewing IOMMU groups..."
        local int_IOMMU_max=$( basename $( ls -1v /sys/kernel/iommu_groups/ | sort -hr | head -n1 ) )
        local var_get_IOMMU='seq 0 "${int_IOMMU_max}"'
        declare -ar arr_this_IOMMU=( $( eval "${var_get_IOMMU}" ) )
        # </params>

        echo -e $str_output

        for int_this_IOMMU_ID in ${arr_this_IOMMU[@]}; do
            local bool_IOMMU_has_external_domain=false
            local bool_IOMMU_PCI_STUB=false
            # local bool_IOMMU_VFIO_PCI=false
            local bool_IOMMU_has_USB=false
            local bool_IOMMU_has_VGA=false

            for int_key in ${!arr_IOMMU[@]}; do
                declare -i int_IOMMU=${arr_IOMMU[$int_key]}
                Select_IOMMU_Match_IOMMU_AndClass
            done

            Select_IOMMU_Prompt
        done

        # <remarks> Check if list is empty </remarks>
        IsArray "arr_IOMMU_VFIO_PCI" && bool_VFIO_has_IOMMU=true && Get_IOMMU_Drivers
        PrintPassOrFail $str_output
        return $int_exit_code
    }
# </code>

# <params>
declare -ga arr_drivers_VFIO_PCI arr_IOMMU_PCI_STUB arr_IOMMU_VFIO_PCI arr_IOMMU_VFIO_PCI_with_VGA arr_hardware_ID_VFIO_PCI
declare -g bool_VFIO_has_IOMMU=false
# </params>