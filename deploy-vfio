#!/bin/bash/env bash

#
# Filename:       deploy-vfio
# Description:    Main executable. See README for details and usage.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# sources
#
  declare -g SCRIPT_DIR="/usr/local/bin/"
  declare -g SCRIPT_BIN_DIR="${SCRIPT_DIR}deploy-vfio.d/"

  source "${SCRIPT_BIN_DIR}src_print" "${0}"
  source "${SCRIPT_BIN_DIR}src_privileges"
  source "${SCRIPT_BIN_DIR}src_compatibility"
  source "${SCRIPT_BIN_DIR}src_isolcpu"
  source "${SCRIPT_BIN_DIR}src_hugepages"
  source "${SCRIPT_BIN_DIR}src_vfio_setup"
  source "${SCRIPT_BIN_DIR}src_network"
  source "${SCRIPT_BIN_DIR}src_auto_xorg"
  source "${SCRIPT_BIN_DIR}src_libvirt_hooks"
  #source "${SCRIPT_BIN_DIR}src_looking_glass"
  #source "${SCRIPT_BIN_DIR}src_scream"
  source "${SCRIPT_BIN_DIR}src_zram_swap"

#
# params
#
  declare -ir INT_FREE_MAX_MEMORY_KILOBYTES=$( \
    cat /proc/meminfo | grep --ignore-case MemTotal | \
    cut --delimiter ":" --fields 2 | awk 'END {print $1}' \
  )

  #
  # DESC: Compatibility checks
  #
    BOOL_COMPATIBILITY_SKIP=false

  #
  # DESC: Pre setup
  #
    BOOL_PRE_SETUP_SKIP=false

    declare -A DICT_HUGEPAGES_ARGS=(
      ["COUNT"]="",
      ["COUNT_MAX_KILOBYTES"]=""
      ["COUNT_KILOBYTES"]="",
      ["FREE_MAX_MEMORY_KILOBYTES"]="${INT_FREE_MAX_MEMORY_KILOBYTES}"
      ["HELP"]=false,
      ["SIZE"]="",
      ["SIZE_KILOBYTES"]="",
      ["SKIP"]=false,
    )

    declare -A DICT_ISOLCPU_ARGS=(
      ["HELP"]=false,
      ["SKIP"]=false,
      ["THREAD_SETS"]="",
    )

  #
  # DESC: Main setup
  #
    BOOL_SKIP_MAIN_SETUP=false

    declare -A DICT_IOMMU_ARGS=(
      ["HELP"]=false,
      ["IOMMU_GROUPS"]="",
      ["SELECT_ALL"]=true,
      ["SELECT_ALL_NON_VGA"]=false,
      ["SKIP"]=false,
      ["USE_DEFAULT_XML"]="",
      ["XML_FILE_NAME"]="",
    )

    declare -A DICT_VFIO_SETUP_ARGS=(
      ["CUSTOM_CMDLINE_STRING"]="",
      ["HELP"]=false,
      ["HUGEPAGES_COUNT"]="",
      ["HUGEPAGES_SIZE"]="",
      ["IOMMU_GROUPS"]="",
      ["ISOLCPU_THREAD_SETS"]="",
      ["MULTI_BOOT_SETUP"]=true
      ["SKIP"]=false,
      ["STATIC_SETUP"]=false
    )

  #
  # DESC: Post setup
  #
    BOOL_SKIP_POST_SETUP=false

    declare -A DICT_AUTO_XORG_ARGS=(
      ["ARGS"]=""
      ["EXECUTE"]=false,
      ["HELP"]=false,
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_GENERATE_EVDEV_ARGS=(
      ["ARGS"]=""
      ["EXECUTE"]=false,
      ["HELP"]=false,
      ["HUGEPAGES_ENABLED"]=false
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_LIBVIRT_HOOKS_ARGS=(
      ["HELP"]=false,
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_LOOKING_GLASS_ARGS=(
      ["HELP"]=false,
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_ZRAM_SWAP_ARGS=(
      ["FRACTION"]="",
      ["HELP"]=false,
      ["HUGEPAGES_COUNT"]="",
      ["HUGEPAGES_SIZE"]="",
      ["INSTALL"]=false,
      ["MODIFY"]=false,
      ["RESTART"]=false,
      ["SKIP"]=false,
      ["UPDATE"]=false,
    )

#
# logic
#
  #
  # DESC:   Main function.
  # $*:     the command line arguments as an array.
  # RETURN: If script executes successfully, return 0.
  #         If not, return 1.
  #
    function main
    {
      if ! parse_arguments "$@"; then
        return 1
      fi

      print_and_log_work

      if ! compatibility \
        || ! pre_setup \
        || ! main_setup \
        || ! post_setup; then
        return 1
      fi

      print_and_log_pass
    }

  #
  # DESC:   Parse arguments.
  # $*:     the command line arguments as an array.
  # RETURN: If all arguments are valid, or none are passed, return 0
  #         If one or more arguments are not valid, return 1.
  #         If an exception occurs, return 2.
  #
    function parse_arguments
    {
      if ! is_string "${1}"; then
        return 0
      fi

      while is_string "${1}"; do
        if ! parse_this_argument "${1}"; then
          return 1
        fi

        shift
      done

      if "${DICT_HUGEPAGES_ARGS["SKIP"]}" \
        && "${DICT_ISOLCPU_ARGS["SKIP"]}"; then
        BOOL_PRE_SETUP_SKIP=true
      fi

      if "${DICT_IOMMU_ARGS["SKIP"]}" \
        && "${DICT_VFIO_SETUP_ARGS["SKIP"]}"; then
        BOOL_SKIP_MAIN_SETUP=true
      fi

      if "${DICT_AUTO_XORG_ARGS["SKIP"]}" \
        && "${DICT_ISOLCPU_ARGS["SKIP"]}" \
        && "${DICT_GENERATE_EVDEV_ARGS["SKIP"]}" \
        && "${DICT_LIBVIRT_HOOKS_ARGS["SKIP"]}" \
        && "${DICT_LOOKING_GLASS_ARGS["SKIP"]}" \
        && "${DICT_ZRAM_SWAP_ARGS["SKIP"]}"; then
        BOOL_SKIP_POST_SETUP=true
      fi

      return 0
    }

  #
  # DESC:   Parse one argument.
  # $*:     the command line arguments as an array.
  # RETURN: If all arguments are valid, or none are passed, return 0
  #         If one or more arguments are not valid, return 1.
  #         If an exception occurs, return 2.
  #
    function parse_this_argument
    {
      if ! is_string "${1}"; then
        return 0
      fi

      case "${1}" in
        "--auto-xorg" )
          if ! auto_xorg_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--compatibility" )
          if ! compatibility_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--generate-evdev" )
          if ! generate_evdev_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--hugepages" )
          if ! hugepages_usage "$@"; then
            return 1
          fi

          return 0
          ;;


        "--iommu" )
          if ! iommu_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--isolcpu" )
          if ! isolcpu_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--libvirt-hooks" )
          if ! libvirt_hooks_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--looking-glass" )
          if ! looking_glass_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        # "--scream" )
        #   if ! scream_usage "$@"; then
        #     return 1
        #   fi

        #   return 0
        #   ;;

        "--vfio-setup" )
          if ! vfio_setup_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--zram-swap" )
          if ! zram_swap_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--help" | "-h" )
          src_iommu_usage_prompt
          src_vfio_usage_prompt
          src_hugepages_usage_prompt
          src_isolcpu_usage_prompt
          src_auto_xorg_usage_prompt
          src_generate_evdev_usage_prompt
          src_libvirt_hooks_usage_prompt
          src_looking_glass_usage_prompt
          # src_scream_usage_prompt
          src_zram_swap_usage_prompt

          exit 0
          ;;

        * )
          print_and_log_invalid_argument "${1}"
          src_iommu_usage_prompt
          src_vfio_usage_prompt
          src_hugepages_usage_prompt
          src_isolcpu_usage_prompt
          src_auto_xorg_usage_prompt
          src_generate_evdev_usage_prompt
          src_libvirt_hooks_usage_prompt
          src_looking_glass_usage_prompt
          # src_scream_usage_prompt
          src_zram_swap_usage_prompt

          return 1
          ;;
      esac
    }

  #
  # DESC: Compatibility checks
  #
    #
    # DESC:   Call sources.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function compatibility_checks
      {
        if "${BOOL_COMPATIBILITY_SKIP}"; then
          print_and_log_output "Compatibility checks skipped."
          return 0
        fi

        if ! src_privileges_is_user_superuser \
          || ! is_system_supported \
          || ! src_privileges_add_user_to_required_groups; then
          return 1
        fi

        return 0
      }

  #
  # DESC: Pre setup
  #
    #
    # DESC:   Call sources.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function pre_setup
      {
        if "${BOOL_PRE_SETUP_SKIP}"; then
          print_and_log_output "Pre setup skipped."
          return 0
        fi

        print_and_log_work "Executing pre setup..."

        if ! hugepages \
          || ! isolcpu; then
          print_and_log_fail "Pre setup failed."
          return 1
        fi

        print_and_log_pass "Pre setup complete."
        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function hugepages
      {
        if ! src_hugepages_main \
            "${DICT_HUGEPAGES_ARGS["HELP"]}" \
            "${DICT_HUGEPAGES_ARGS["SKIP"]}" \
            "${DICT_HUGEPAGES_ARGS["SIZE"]}" \
            "DICT_HUGEPAGES_ARGS[\"SIZE_KILOBYTES\"]" \
            "DICT_HUGEPAGES_ARGS[\"COUNT\"]" \
            "DICT_HUGEPAGES_ARGS[\"COUNT_KILOBYTES\"]" \
            "${DICT_HUGEPAGES_ARGS["FREE_MAX_MEMORY_KILOBYTES"]}"
            "DICT_HUGEPAGES_ARGS[\"COUNT_MAX_KILOBYTES\"]"; then
          DICT_GENERATE_EVDEV_ARGS["HUGEPAGES_ENABLED"]=false
          return 1
        fi

        DICT_GENERATE_EVDEV_ARGS["HUGEPAGES_ENABLED"]=true
        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function isolcpu
      {
        if ! src_isolcpu_main \
            "${DICT_AUTO_XORG_ARGS["HELP"]}" \
            "${DICT_AUTO_XORG_ARGS["SKIP"]}" \
            "${DICT_AUTO_XORG_ARGS["THREAD_SETS"]}"; then
          return 1
        fi

        return 0
      }

  #
  # DESC: Main setup
  #
    #
    # DESC:   Call sources.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function main_setup
      {
        if "${BOOL_MAIN_SETUP_SKIP}"; then
          print_and_log_output "Main setup skipped."
          return 0
        fi

        print_and_log_work "Executing main setup..."

        if ! iommu \
          || ! vfio_setup; then
          print_and_log_fail "Main setup failed."
          return 1
        fi

        print_and_log_pass "Main setup complete."
        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function iommu
      {
        if ! src_iommu_main \
            "${DICT_IOMMU_ARGS["HELP"]}" \
            "${DICT_IOMMU_ARGS["SKIP"]}" \
            "${DICT_IOMMU_ARGS["USE_DEFAULT_XML"]}" \
            "${DICT_IOMMU_ARGS["XML_FILE_NAME"]}" \
            "${DICT_IOMMU_ARGS["SELECT_ALL"]}" \
            "${DICT_IOMMU_ARGS["SELECT_ALL_NON_VGA"]}" \
            "${DICT_IOMMU_ARGS["IOMMU_GROUPS"]}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function vfio_setup
      {
        DICT_VFIO_SETUP_ARGS["HUGEPAGES_COUNT"]="${DICT_HUGEPAGES_ARGS["COUNT"]}"
        DICT_VFIO_SETUP_ARGS["HUGEPAGES_SIZE"]="${DICT_HUGEPAGES_ARGS["SIZE"]}"

        DICT_VFIO_SETUP_ARGS["ISOLCPU_THREAD_SETS"]=\
          "${DICT_ISOLCPU_ARGS["THREAD_SETS"]}"

        DICT_VFIO_SETUP_ARGS["IOMMU_GROUPS"]="${DICT_IOMMU_ARGS["IOMMU_GROUPS"]}"

        if ! src_vfio_setup_main \
            "${DICT_VFIO_SETUP_ARGS["HELP"]}" \
            "${DICT_VFIO_SETUP_ARGS["SKIP"]}" \
            "${DICT_VFIO_SETUP_ARGS["MULTI_BOOT_SETUP"]}" \
            "${DICT_VFIO_SETUP_ARGS["STATIC_SETUP"]}" \
            "${DICT_VFIO_SETUP_ARGS["IOMMU_GROUPS"]}" \
            "${DICT_VFIO_SETUP_ARGS["HUGEPAGES_COUNT"]}" \
            "${DICT_VFIO_SETUP_ARGS["HUGEPAGES_SIZE"]}" \
            "${DICT_VFIO_SETUP_ARGS["ISOLCPU_THREAD_SETS"]}" \
            "${DICT_VFIO_SETUP_ARGS["CUSTOM_CMDLINE_STRING"]}"; then
          return 1
        fi

        return 0
      }

  #
  # DESC: Post setup
  #
    #
    # DESC:   Call sources.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function post_setup
      {
        if "${BOOL_POST_SETUP_SKIP}"; then
          print_and_log_output "Post setup skipped."
          return 0
        fi

        print_and_log_work "Executing post setup..."

        if ! auto_xorg \
          || ! generate_evdev \
          || ! libvirt_hooks \
          || ! zram_swap; then
          print_and_log_fail "Post setup failed."
          return 1
        fi

        print_and_log_pass "Post setup complete."
        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function auto_xorg
      {
        if ! src_auto_xorg_main \
            "${DICT_AUTO_XORG_ARGS["HELP"]}" \
            "${DICT_AUTO_XORG_ARGS["SKIP"]}" \
            "${DICT_AUTO_XORG_ARGS["EXECUTE"]}" \
            "${DICT_AUTO_XORG_ARGS["INSTALL"]}" \
            "${DICT_AUTO_XORG_ARGS["UNINSTALL"]}" \
            "${DICT_AUTO_XORG_ARGS["UPDATE"]}" \
            "DICT_AUTO_XORG_ARGS[\"ARGS\"]"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Parse, validate, and save selected arguments.
    # $*:     the arguments as a string.
    # RETURN: If none or all arguments are valid, return 0.
    #         If any argument is not valid, return 1.
    #
      function auto_xorg_usage
      {
        local -a str_arguments="$@"

        local -A dict_selected_arguments \
          dict_selected_options

        if ! src_auto_xorg_usage \
            "dict_selected_arguments" \
            "dict_selected_options" \
            "${str_arguments}"; then
          print_and_log_invalid_option
          return 2
        fi

        local -Ar dict_selected_flag_and_argument=(
          ["EXECUTE"]="execute"
          ["HELP"]="help"
          ["INSTALL"]="install"
          ["SKIP"]="skip"
          ["UNINSTALL"]="uninstall"
          ["UPDATE"]="update"
        )

        for str_flag in "${!dict_selected_flag_and_argument[*]}"; do
          local str_argument="${!dict_selected_flag_and_argument["${str_flag}"]}"

          if array_contains_value \
              "dict_selected_arguments" \
              "${str_argument}"; then
              dict_selected_arguments["${str_flag}"]=true
              continue
          fi
        done

        if ! is_xor \
            "${DICT_AUTO_XORG_ARGS["EXECUTE"]}" \
            "${DICT_AUTO_XORG_ARGS["INSTALL"]}"; then
          print_and_log_invalid_option "execute"
          print_and_log_invalid_option "install"
          return 1
        fi

        if is_dict_not_empty "dict_selected_options" \
          && ! "${DICT_AUTO_XORG_ARGS["EXECUTE"]}" \
          && ! "${DICT_AUTO_XORG_ARGS["INSTALL"]}"; then
          print_and_log_invalid_option "arguments="

          print_and_log_warn "Either 'execute' or 'install' must be set, but not "\
            "both."

          return 1
        fi

        if array_contains_value \
            "dict_selected_options" \
            "arguments="; then
          DICT_AUTO_XORG_ARGS["ARGS"]="${dict_selected_options["arguments="]}"
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function generate_evdev
      {
        local -r str_hugepages_argument="--hugepages"

        if DICT_GENERATE_EVDEV_ARGS["HUGEPAGES_ENABLED"] \
          && ! array_contains_value \
            "DICT_GENERATE_EVDEV_ARGS[\"ARGS\"]" \
            "${str_hugepages_argument}"; then
          DICT_GENERATE_EVDEV_ARGS["ARGS"]+="${str_hugepages_argument},"
        fi

        if ! src_generate_evdev_main \
            "${DICT_GENERATE_EVDEV_ARGS["HELP"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["SKIP"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["EXECUTE"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["INSTALL"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["UNINSTALL"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["UPDATE"]}" \
            "DICT_GENERATE_EVDEV_ARGS[\"ARGS\"]"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Parse, validate, and save selected arguments.
    # $*:     the arguments as a string.
    # RETURN: If none or all arguments are valid, return 0.
    #         If any argument is not valid, return 1.
    #
      function generate_evdev_usage
      {
        local -a str_arguments="$@"

        local -A dict_selected_arguments \
          dict_selected_options

        if ! src_generate_evdev_usage \
            "dict_selected_arguments" \
            "dict_selected_options" \
            "${str_arguments}"; then
          print_and_log_invalid_option
          return 2
        fi

        local -Ar dict_selected_flag_and_argument=(
          ["EXECUTE"]="execute"
          ["HELP"]="help"
          ["INSTALL"]="install"
          ["SKIP"]="skip"
          ["UNINSTALL"]="uninstall"
          ["UPDATE"]="update"
        )

        for str_flag in "${!dict_selected_flag_and_argument[*]}"; do
          local str_argument="${!dict_selected_flag_and_argument["${str_flag}"]}"

          if array_contains_value \
              "dict_selected_arguments" \
              "${str_argument}"; then
              dict_selected_arguments["${str_flag}"]=true
              continue
          fi
        done

        if ! is_xor \
            "${DICT_GENERATE_EVDEV_ARGS["EXECUTE"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["INSTALL"]}"; then
          print_and_log_invalid_option "execute"
          print_and_log_invalid_option "install"
          return 1
        fi

        if is_dict_not_empty "dict_selected_options" \
          && ! "${DICT_GENERATE_EVDEV_ARGS["EXECUTE"]}" \
          && ! "${DICT_GENERATE_EVDEV_ARGS["INSTALL"]}"; then
          print_and_log_invalid_option "arguments="

          print_and_log_warn "Either 'execute' or 'install' must be set, but not "\
            "both."

          return 1
        fi

        if array_contains_value \
            "dict_selected_options" \
            "arguments="; then
          DICT_GENERATE_EVDEV_ARGS["ARGS"]="${dict_selected_options["arguments="]}"
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function libvirt_hooks
      {
        if ! src_libvirt_hooks_main \
            "${DICT_LIBVIRT_HOOKS_ARGS["HELP"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["SKIP"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["INSTALL"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["UNINSTALL"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["UPDATE"]}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Parse, validate, and save selected arguments.
    # $*:     the arguments as a string.
    # RETURN: If none or all arguments are valid, return 0.
    #         If any argument is not valid, return 1.
    #
      function libvirt_hooks_usage
      {
        local -a str_arguments="$@"

        local -A dict_selected_arguments \
          dict_selected_options

        if ! src_generate_evdev_usage \
            "dict_selected_arguments" \
            "dict_selected_options" \
            "${str_arguments}"; then
          print_and_log_invalid_option
          return 2
        fi

        local -Ar dict_selected_flag_and_argument=(
          ["HELP"]="help"
          ["INSTALL"]="install"
          ["SKIP"]="skip"
          ["UNINSTALL"]="uninstall"
          ["UPDATE"]="update"
        )

        for str_flag in "${!dict_selected_flag_and_argument[*]}"; do
          local str_argument="${!dict_selected_flag_and_argument["${str_flag}"]}"

          if array_contains_value \
              "dict_selected_arguments" \
              "${str_argument}"; then
              dict_selected_arguments["${str_flag}"]=true
              continue
          fi
        done

        if ! is_xor \
            "${DICT_GENERATE_EVDEV_ARGS["EXECUTE"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["INSTALL"]}"; then
          print_and_log_invalid_option "execute"
          print_and_log_invalid_option "install"
          return 1
        fi

        if is_dict_not_empty "dict_selected_options" \
          && ! "${DICT_GENERATE_EVDEV_ARGS["EXECUTE"]}" \
          && ! "${DICT_GENERATE_EVDEV_ARGS["INSTALL"]}"; then
          print_and_log_invalid_option "arguments="

          print_and_log_warn "Either 'execute' or 'install' must be set, but not "\
            "both."

          return 1
        fi

        if array_contains_value \
            "dict_selected_options" \
            "arguments="; then
          DICT_GENERATE_EVDEV_ARGS["ARGS"]="${dict_selected_options["arguments="]}"
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function zram_swap
      {
        local bool_use_default_fraction=false

        if ! is_string "${DICT_ZRAM_SWAP_ARGS["FRACTION"]}" \
          && ( "${DICT_ZRAM_SWAP_ARGS["INSTALL"]}" \
            || "${DICT_ZRAM_SWAP_ARGS["MODIFY"]}" ); then
          bool_use_default_fraction=true
        fi

        if is_string "${DICT_HUGEPAGES_ARGS["COUNT"]}" \
            && is_string "${DICT_HUGEPAGES_ARGS["SIZE"]}"; then
          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]="${DICT_HUGEPAGES_ARGS["COUNT"]}"
          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_SIZE"]="${DICT_HUGEPAGES_ARGS["SIZE"]}"
        fi

        local -i int_hugepages_maximum_count_kilobytes=0
        local -i int_hugepages_size_kilobytes=0

        if is_int "${DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]}"; then
          if ! src_hugepages_get_kilobytes_size \
              "${DICT_ZRAM_SWAP_ARGS["HUGEPAGES_SIZE"]}" \
              "${int_hugepages_size_kilobytes}" \
            || ! src_hugepages_get_count \
              "${DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]}" \
              "${int_hugepages_size_kilobytes}" \
              "${INT_FREE_MAX_MEMORY_KILOBYTES}" \
              "${int_hugepages_maximum_count_kilobytes}"; then
            return 1
          fi
        fi

        if ! src_zram_swap_main \
            "${DICT_ZRAM_SWAP_ARGS["HELP"]}" \
            "${DICT_ZRAM_SWAP_ARGS["SKIP"]}" \
            "${DICT_ZRAM_SWAP_ARGS["MODIFY"]}" \
            "${DICT_ZRAM_SWAP_ARGS["INSTALL"]}" \
            "${DICT_ZRAM_SWAP_ARGS["UNINSTALL"]}" \
            "${DICT_ZRAM_SWAP_ARGS["UPDATE"]}" \
            "${DICT_ZRAM_SWAP_ARGS["RESTART"]}" \
            "${DICT_ZRAM_SWAP_ARGS["FRACTION"]}" \
            "${int_hugepages_maximum_count_kilobytes}" \
            "${bool_use_default_fraction}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Parse, validate, and save selected arguments.
    # $*:     the arguments as a string.
    # RETURN: If none or all arguments are valid, return 0.
    #         If any argument is not valid, return 1.
    #
      function zram_swap_usage
      {
        local -a str_arguments="$@"

        local -A dict_selected_arguments \
          dict_selected_options

        if ! src_zram_swap_usage \
            "dict_selected_arguments" \
            "dict_selected_options" \
            "${str_arguments}"; then
          print_and_log_invalid_option
          return 2
        fi

        local -Ar dict_selected_flag_and_argument=(
          ["HELP"]="help"
          ["INSTALL"]="install"
          ["MODIFY"]="modify"
          ["RESTART"]="restart"
          ["SKIP"]="skip"
          ["UNINSTALL"]="uninstall"
          ["UPDATE"]="update"
        )

        for str_flag in "${!dict_selected_flag_and_argument[*]}"; do
          local str_argument="${!dict_selected_flag_and_argument["${str_flag}"]}"

          if array_contains_value \
              "dict_selected_arguments" \
              "${str_argument}"; then
              dict_selected_arguments["${str_flag}"]=true
              continue
          fi
        done

        if is_dict_not_empty "dict_selected_options" \
          && ! "${DICT_ZRAM_SWAP_ARGS["INSTALL"]}" \
          && ! "${DICT_ZRAM_SWAP_ARGS["MODIFY"]}"; then
          print_and_log_invalid_option "arguments="
          print_and_log_warn "Either 'install' or 'modify' must be set, but not both."
          return 1
        fi

        if ! is_xor \
            "${DICT_ZRAM_SWAP_ARGS["INSTALL"]}" \
            "${DICT_ZRAM_SWAP_ARGS["MODIFY"]}"; then
          print_and_log_invalid_option "install"
          print_and_log_invalid_option "modify"
          return 1
        fi

        if array_contains_value \
            "dict_selected_options" \
            "fraction="; then
          DICT_ZRAM_SWAP_ARGS["FRACTION"]=\
            "${dict_selected_options["fraction="]}"
        fi

        local bool_has_hugepages_count=false

        if dict_contains_key_value_pair \
            "dict_selected_options" \
            "hugepages-count="; then
          bool_has_hugepages_count=true
        fi

        local bool_has_hugepages_size=false

        if dict_contains_key_value_pair \
            "dict_selected_options" \
            "hugepages-size="; then
          bool_has_hugepages_size=true
        fi

        if ( "${bool_has_hugepages_count}" \
          && "${bool_has_hugepages_size}" ); then
          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]=\
            "${dict_selected_options["hugepages-count"]}"

          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_SIZE"]=\
            "${dict_selected_options["hugepages-size"]}"

        elif is_xor \
            "${bool_has_hugepages_count}" \
            "${bool_has_hugepages_size}"; then
          print_and_log_invalid_option

          print_and_log_warn "Both 'hugepages-count=' and 'hugepages-size' must be "\
            "set, or neither."

          return 1

        else
          return 0
        fi
      }

#
# main logic
#
  main "$@"