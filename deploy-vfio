#!/bin/bash/env bash

#
# Filename:       deploy-vfio
# Description:    Main executable. See README for details and usage.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

#
# sources
#
  declare -g SCRIPT_DIR="/usr/local/bin/"
  declare -g SCRIPT_BIN_DIR="${SCRIPT_DIR}deploy-vfio.d/"

  source "${SCRIPT_BIN_DIR}src_print" "${0}"
  source "${SCRIPT_BIN_DIR}src_privileges"
  source "${SCRIPT_BIN_DIR}src_compatibility"
  source "${SCRIPT_BIN_DIR}src_isolcpu"
  source "${SCRIPT_BIN_DIR}src_hugepages"
  source "${SCRIPT_BIN_DIR}src_vfio_setup"
  source "${SCRIPT_BIN_DIR}src_network"
  source "${SCRIPT_BIN_DIR}src_auto_xorg"
  source "${SCRIPT_BIN_DIR}src_libvirt_hooks"
  source "${SCRIPT_BIN_DIR}src_looking_glass"
  source "${SCRIPT_BIN_DIR}src_scream"
  source "${SCRIPT_BIN_DIR}src_zram_swap"

#
# params
#
  declare -ir INT_FREE_MAX_MEMORY_KILOBYTES=$( \
    cat /proc/meminfo | grep --ignore-case MemTotal | \
    cut --delimiter ":" --fields 2 | awk 'END {print $1}' \
  )

  #
  # DESC: Compatibility checks
  #
    BOOL_COMPATIBILITY_SKIP=false

  #
  # DESC: Pre setup
  #
    BOOL_PRE_SETUP_SKIP=false

    declare -A DICT_HUGEPAGES_ARGS=(
      ["COUNT"]="",
      ["COUNT_MAX_KILOBYTES"]=""
      ["COUNT_KILOBYTES"]="",
      ["FREE_MAX_MEMORY_KILOBYTES"]="${INT_FREE_MAX_MEMORY_KILOBYTES}"
      ["SIZE"]="",
      ["SIZE_KILOBYTES"]="",
      ["SKIP"]=false,
    )

    declare -A DICT_ISOLCPU_ARGS=(
      ["SKIP"]=false,
      ["THREAD_SETS"]="",
    )

  #
  # DESC: Main setup
  #
    BOOL_SKIP_MAIN_SETUP=false

    declare -A DICT_IOMMU_ARGS=(
      ["IOMMU_GROUPS"]="",
      ["SELECT_ALL"]=true,
      ["SELECT_ALL_NON_VGA"]=false,
      ["SKIP"]=false,
      ["USE_DEFAULT_XML"]="",
      ["XML_FILE_NAME"]="",
    )

    declare -A DICT_VFIO_ARGS=(
      ["CUSTOM_CMDLINE_STRING"]="",
      ["HUGEPAGES_COUNT"]="",
      ["HUGEPAGES_SIZE"]="",
      ["IOMMU_GROUPS"]="",
      ["ISOLCPU_THREAD_SETS"]="",
      ["MULTI_BOOT_SETUP"]=true
      ["SKIP"]=false,
      ["STATIC_SETUP"]=false
    )

  #
  # DESC: Post setup
  #
    BOOL_SKIP_POST_SETUP=false

    declare -A DICT_AUTO_XORG_ARGS=(
      ["ARGS"]=""
      ["EXECUTE"]=false,
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_GENERATE_EVDEV_ARGS=(
      ["ARGS"]=""
      ["EXECUTE"]=false,
      ["HUGEPAGES_ENABLED"]=false
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_LIBVIRT_HOOKS_ARGS=(
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_LOOKING_GLASS_ARGS=(
      ["INSTALL"]=false,
      ["SKIP"]=false,
      ["UNINSTALL"]=false,
      ["UPDATE"]=false,
    )

    declare -A DICT_ZRAM_SWAP_ARGS=(
      ["FRACTION"]="",
      ["HUGEPAGES_COUNT"]="",
      ["HUGEPAGES_SIZE"]="",
      ["INSTALL"]=false,
      ["MODIFY"]=false,
      ["RESTART"]=false,
      ["SKIP"]=false,
      ["UPDATE"]=false,
      ["USE_CACULATED_FRACTION"]=false,
      ["USE_DEFAULT_FRACTION"]=true,
    )

#
# logic
#
  #
  # DESC:   Main function.
  # $*:     the command line arguments as an array.
  # RETURN: If script executes successfully, return 0.
  #         If not, return 1.
  #
    function main
    {
      if ! parse_arguments "$@"; then
        return 1
      fi

      print_and_log_work

      if ! src_privileges_is_user_superuser \
        || ! is_system_supported; then
        return 1
      fi

      print_and_log_work "Executing pre setup..."

      if ! hugepages \
        || ! isolcpu; then
        print_and_log_fail "Pre setup failed."
        return 1
      fi

      print_and_log_pass "Pre setup complete."
      print_and_log_work "Executing main setup..."

      if ! iommu \
        || ! vfio_setup; then
        print_and_log_fail "Main setup failed."
        return 1
      fi

      print_and_log_pass "Main setup complete."
      print_and_log_work "Executing post setup..."

      if ! auto_xorg \
        || ! libvirt_hooks \
        || ! looking_glass \
        || ! scream \
        || ! zram_swap; then
        print_and_log_fail "Post setup failed."
        return 1
      fi

      print_and_log_pass "Post setup complete."
      print_and_log_pass
    }

  #
  # DESC:   Parse arguments.
  # $*:     the command line arguments as an array.
  # RETURN: If all arguments are valid, or none are passed, return 0
  #         If one or more arguments are not valid, return 1.
  #         If an exception occurs, return 2.
  #
    function parse_arguments
    {
      if ! is_string "${1}"; then
        return 0
      fi

      while is_string "${1}"; do
        if ! parse_this_argument "${1}"; then
          return 1
        fi

        shift
      done

      return 0
    }

  #
  # DESC:   Parse one argument.
  # $*:     the command line arguments as an array.
  # RETURN: If all arguments are valid, or none are passed, return 0
  #         If one or more arguments are not valid, return 1.
  #         If an exception occurs, return 2.
  #
    function parse_this_argument
    {
      if ! is_string "${1}"; then
        return 0
      fi

      case "${1}" in
        "--auto-xorg" )
          if ! auto_xorg_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--compatibility" )
          if ! compatibility_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--generate-evdev" )
          if ! generate_evdev_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--hugepages" )
          if ! hugepages_usage "$@"; then
            return 1
          fi

          return 0
          ;;


        "--iommu" )
          if ! iommu_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--isolcpu" )
          if ! isolcpu_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--libvirt-hooks" )
          if ! libvirt_hooks_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--looking-glass" )
          if ! looking_glass_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--scream" )
          if ! scream_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--vfio-setup" )
          if ! vfio_setup_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--zram-swap" )
          if ! zram_swap_usage "$@"; then
            return 1
          fi

          return 0
          ;;

        "--help" | "-h" )
          src_iommu_usage_prompt
          src_vfio_usage_prompt
          src_hugepages_usage_prompt
          src_isolcpu_usage_prompt
          src_auto_xorg_usage_prompt
          src_generate_evdev_usage_prompt
          src_libvirt_hooks_usage_prompt
          src_looking_glass_usage_prompt
          src_scream_usage_prompt
          src_zram_swap_usage_prompt

          exit 0
          ;;

        * )
          print_and_log_invalid_argument "${1}"
          src_iommu_usage_prompt
          src_vfio_usage_prompt
          src_hugepages_usage_prompt
          src_isolcpu_usage_prompt
          src_auto_xorg_usage_prompt
          src_generate_evdev_usage_prompt
          src_libvirt_hooks_usage_prompt
          src_looking_glass_usage_prompt
          src_scream_usage_prompt
          src_zram_swap_usage_prompt

          return 1
          ;;
      esac
    }

  #
  # DESC: Pre setup
  #
    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function hugepages
      {
        if ! src_hugepages_main \
            "${DICT_HUGEPAGES_ARGS["SKIP"]}" \
            "${DICT_HUGEPAGES_ARGS["SIZE"]}" \
            "DICT_HUGEPAGES_ARGS[\"SIZE_KILOBYTES\"]" \
            "DICT_HUGEPAGES_ARGS[\"COUNT\"]" \
            "DICT_HUGEPAGES_ARGS[\"COUNT_KILOBYTES\"]" \
            "${DICT_HUGEPAGES_ARGS["FREE_MAX_MEMORY_KILOBYTES"]}"
            "DICT_HUGEPAGES_ARGS[\"COUNT_MAX_KILOBYTES\"]"; then
          DICT_GENERATE_EVDEV_ARGS["HUGEPAGES_ENABLED"]=false
          return 1
        fi

        DICT_GENERATE_EVDEV_ARGS["HUGEPAGES_ENABLED"]=true
        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function isolcpu
      {
        if ! src_isolcpu_main \
            "${DICT_AUTO_XORG_ARGS["SKIP"]}" \
            "${DICT_AUTO_XORG_ARGS["THREAD_SETS"]}"; then
          return 1
        fi

        return 0
      }

  #
  # DESC: Main setup
  #
    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function iommu
      {
        if ! src_iommu_main \
            "${DICT_AUTO_XORG_ARGS["SKIP"]}" \
            "${DICT_AUTO_XORG_ARGS["USE_DEFAULT_XML"]}" \
            "${DICT_AUTO_XORG_ARGS["XML_FILE_NAME"]}" \
            "${DICT_AUTO_XORG_ARGS["SELECT_ALL"]}" \
            "${DICT_AUTO_XORG_ARGS["SELECT_ALL_NON_VGA"]}" \
            "${DICT_AUTO_XORG_ARGS["IOMMU_GROUPS"]}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function vfio_setup
      {
        DICT_VFIO_ARGS["HUGEPAGES_COUNT"]="${DICT_HUGEPAGES_ARGS["COUNT"]}"
        DICT_VFIO_ARGS["HUGEPAGES_SIZE"]="${DICT_HUGEPAGES_ARGS["SIZE"]}"
        DICT_VFIO_ARGS["ISOLCPU_THREAD_SETS"]="${DICT_ISOLCPU_ARGS["THREAD_SETS"]}"
        DICT_VFIO_ARGS["IOMMU_GROUPS"]="${DICT_IOMMU_ARGS["IOMMU_GROUPS"]}"

        if ! src_vfio_setup_main \
            "${DICT_VFIO_ARGS["SKIP"]}" \
            "${DICT_VFIO_ARGS["MULTI_BOOT_SETUP"]}" \
            "${DICT_VFIO_ARGS["STATIC_SETUP"]}" \
            "${DICT_VFIO_ARGS["IOMMU_GROUPS"]}" \
            "${DICT_VFIO_ARGS["HUGEPAGES_COUNT"]}" \
            "${DICT_VFIO_ARGS["HUGEPAGES_SIZE"]}" \
            "${DICT_VFIO_ARGS["ISOLCPU_THREAD_SETS"]}" \
            "${DICT_VFIO_ARGS["CUSTOM_CMDLINE_STRING"]}"; then
          return 1
        fi

        return 0
      }

  #
  # DESC: Post setup
  #
    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function auto_xorg
      {
        if ! src_auto_xorg_main \
            "${DICT_AUTO_XORG_ARGS["HELP"]}" \
            "${DICT_AUTO_XORG_ARGS["SKIP"]}" \
            "${DICT_AUTO_XORG_ARGS["EXECUTE"]}" \
            "${DICT_AUTO_XORG_ARGS["INSTALL"]}" \
            "${DICT_AUTO_XORG_ARGS["UNINSTALL"]}" \
            "${DICT_AUTO_XORG_ARGS["UPDATE"]}" \
            "DICT_AUTO_XORG_ARGS[\"ARGS\"]"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Parse, validate, and save selected arguments.
    # $*:     the arguments as a string.
    # RETURN: If none or all arguments are valid, return 0.
    #         If any argument is not valid, return 1.
    #
      function auto_xorg_usage
      {
        local -a str_arguments="$@"

        local -A dict_selected_arguments \
          dict_selected_options

        if ! src_auto_xorg_usage \
            "dict_selected_arguments" \
            "dict_selected_options" \
            "${str_arguments}"; then
          print_and_log_invalid_option
          return 2
        fi

        if array_contains_value \
            "dict_selected_arguments" \
            "help"; then
          DICT_AUTO_XORG_ARGS["HELP"]=true
        fi

        if array_contains_value \
            "dict_selected_arguments" \
            "skip"; then
          DICT_AUTO_XORG_ARGS["SKIP"]=true
        fi

        if array_contains_value \
            "dict_selected_arguments" \
            "uninstall"; then
          DICT_AUTO_XORG_ARGS["UNINSTALL"]=true
        fi

        if array_contains_value \
            "dict_selected_arguments" \
            "update"; then
          DICT_AUTO_XORG_ARGS["UPDATE"]=true
        fi

        local bool_has_execute=false

        if array_contains_value \
            "dict_selected_arguments" \
            "execute"; then
          bool_has_execute=true
        fi

        local bool_has_install=false

        if array_contains_value \
            "dict_selected_arguments" \
            "install"; then
          bool_has_install=true
        fi

        if "${bool_has_execute}" \
          && "${bool_has_install}"; then
          return 0
        fi

        if ! is_xor \
            "${bool_has_install}" \
            "${bool_has_execute}"; then
          print_and_log_invalid_option "execute"
          print_and_log_invalid_option "install"
          return 1
        fi

        if array_contains_value \
            "dict_selected_options" \
            "arguments="; then
          DICT_ZRAM_SWAP_ARGS["ARGS"]="${dict_selected_options["arguments="]}"
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function generate_evdev
      {
        local -r str_hugepages_argument=" --hugepages "

        if DICT_GENERATE_EVDEV_ARGS["HUGEPAGES_ENABLED"] \
          && ! array_contains_value \
            "DICT_GENERATE_EVDEV_ARGS[\"ARGS\"]" \
            "${str_hugepages_argument}"; then
          DICT_GENERATE_EVDEV_ARGS["ARGS"]+="${str_hugepages_argument}"
        fi

        if ! src_generate_evdev_main \
            "${DICT_GENERATE_EVDEV_ARGS["SKIP"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["EXECUTE"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["INSTALL"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["UNINSTALL"]}" \
            "${DICT_GENERATE_EVDEV_ARGS["UPDATE"]}" \
            "DICT_GENERATE_EVDEV_ARGS[\"ARGS\"]"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function libvirt_hooks
      {
        if ! src_libvirt_hooks_main \
            "${DICT_LIBVIRT_HOOKS_ARGS["SKIP"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["INSTALL"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["UNINSTALL"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["UPDATE"]}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function looking_glass
      {
        if ! src_looking_glass_main \
            "${DICT_LOOKING_GLASS_ARGS["SKIP"]}" \
            "${DICT_LOOKING_GLASS_ARGS["INSTALL"]}" \
            "${DICT_LOOKING_GLASS_ARGS["UNINSTALL"]}" \
            "${DICT_LOOKING_GLASS_ARGS["UPDATE"]}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function scream
      {
        if ! src_scream_main \
            "${DICT_LIBVIRT_HOOKS_ARGS["SKIP"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["INSTALL"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["UNINSTALL"]}" \
            "${DICT_LIBVIRT_HOOKS_ARGS["UPDATE"]}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Call source.
    # RETURN: If successful, return 0.
    #         If not, return 1.
    #
      function zram_swap
      {
        DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT_MAX_KILOBYTES"]=\
          "${DICT_HUGEPAGES_ARGS["COUNT_MAX_KILOBYTES"]}"

        local -i int_hugepages_maximum_count_kilobytes=0
        local -i int_hugepages_size_kilobytes=0

        if is_int "${DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]}"; then
          if ! src_hugepages_get_kilobytes_size \
              "${DICT_ZRAM_SWAP_ARGS["HUGEPAGES_SIZE"]}" \
              "${int_hugepages_size_kilobytes}" \
            || ! src_hugepages_get_count \
              "${DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]}" \
              "${int_hugepages_size_kilobytes}" \
              "${INT_FREE_MAX_MEMORY_KILOBYTES}" \
              "${int_hugepages_maximum_count_kilobytes}"; then
            return 1
          fi
        fi

        if ! src_zram_swap_main \
            "${DICT_ZRAM_SWAP_ARGS["SKIP"]}" \
            "${DICT_ZRAM_SWAP_ARGS["MODIFY"]}" \
            "${DICT_ZRAM_SWAP_ARGS["INSTALL"]}" \
            "${DICT_ZRAM_SWAP_ARGS["UNINSTALL"]}" \
            "${DICT_ZRAM_SWAP_ARGS["UPDATE"]}" \
            "${DICT_ZRAM_SWAP_ARGS["RESTART"]}" \
            "${DICT_ZRAM_SWAP_ARGS["USE_CACULATED_FRACTION"]}" \
            "${DICT_ZRAM_SWAP_ARGS["USE_DEFAULT_FRACTION"]}" \
            "${DICT_ZRAM_SWAP_ARGS["FRACTION"]}" \
            "${int_hugepages_maximum_count_kilobytes}"; then
          return 1
        fi

        return 0
      }

    #
    # DESC:   Parse, validate, and save selected arguments.
    # $*:     the arguments as a string.
    # RETURN: If none or all arguments are valid, return 0.
    #         If any argument is not valid, return 1.
    #
      function zram_swap_usage
      {
        local -a str_arguments="$@"

        local -A dict_selected_arguments \
          dict_selected_options

        if ! src_zram_swap_usage \
            "dict_selected_arguments" \
            "dict_selected_options" \
            "${str_arguments}"; then
          print_and_log_invalid_option
          return 2
        fi

        if array_contains_value \
            "dict_selected_arguments" \
            "skip"; then
          DICT_ZRAM_SWAP_ARGS["SKIP"]=true
        fi

        if array_contains_value \
            "dict_selected_arguments" \
            "uninstall"; then
          DICT_ZRAM_SWAP_ARGS["UNINSTALL"]=true
        fi

        if array_contains_value \
            "dict_selected_arguments" \
            "update"; then
          DICT_ZRAM_SWAP_ARGS["UPDATE"]=true
        fi

        local bool_has_install=false

        if array_contains_value \
            "dict_selected_arguments" \
            "install"; then
          bool_has_install=true
        fi

        local bool_has_modify=false

        if array_contains_value \
            "dict_selected_arguments" \
            "modify"; then
          bool_has_modify=true
        fi

        if "${bool_has_install}" \
          && "${bool_has_modify}"; then
          return 0
        fi

        if ! is_xor \
            "${bool_has_install}" \
            "${bool_has_modify}"; then
          print_and_log_invalid_option "install"
          print_and_log_invalid_option "modify"
          return 1
        fi

        local bool_is_calculated_fraction=false

        if array_contains_value \
            "dict_selected_options" \
            "restart"; then
          DICT_ZRAM_SWAP_ARGS["RESTART"]=true
        fi

        if dict_contains_key_value_pair \
            "dict_selected_options" \
            "fraction=" \
            "calculated"; then
          bool_is_calculated_fraction=true
        fi

        if ${bool_is_calculated_fraction}; then
          DICT_ZRAM_SWAP_ARGS["USE_CACULATED_FRACTION"]=true
          DICT_ZRAM_SWAP_ARGS["USE_DEFAULT_FRACTION"]=false
        fi

        if array_contains_value \
            "dict_selected_options" \
            "fraction=" \
          && ! ${bool_is_calculated_fraction}; then
          DICT_ZRAM_SWAP_ARGS["FRACTION"]=\
            "${dict_selected_options["fraction="]}"

          DICT_ZRAM_SWAP_ARGS["USE_DEFAULT_FRACTION"]=false
        fi

        local bool_has_hugepages_count=false

        if dict_contains_key_value_pair \
            "dict_selected_options" \
            "hugepages-count"; then
          bool_has_hugepages_count=true
        fi

        local bool_has_hugepages_size=false

        if dict_contains_key_value_pair \
            "dict_selected_options" \
            "hugepages-size"; then
          bool_has_hugepages_size=true
        fi

        if is_string "${DICT_HUGEPAGES_ARGS["COUNT"]}" \
            && is_string "${DICT_HUGEPAGES_ARGS["SIZE"]}"; then
          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]="${DICT_HUGEPAGES_ARGS["COUNT"]}"
          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_SIZE"]="${DICT_HUGEPAGES_ARGS["SIZE"]}"
        fi

        if ( "${bool_has_hugepages_count}" \
          && "${bool_has_hugepages_size}" ); then
          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_COUNT"]=\
            "${dict_selected_options["hugepages-count"]}"

          DICT_ZRAM_SWAP_ARGS["HUGEPAGES_SIZE"]=\
            "${dict_selected_options["hugepages-size"]}"
        elif is_xor \
            "${bool_has_hugepages_count}" \
            "${bool_has_hugepages_size}"; then
          print_and_log_invalid_option
          print_and_log_warn "Both Hugepages count and size must be set, or neither."
          return 1
        fi

        return 0
      }

#
# main logic
#
  parse_args "$@"
  main